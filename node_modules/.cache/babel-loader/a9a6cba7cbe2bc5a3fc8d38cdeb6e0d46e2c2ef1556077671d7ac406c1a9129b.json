{"ast":null,"code":"import _slicedToArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\", \"compute\", \"renderPriority\", \"eventPriority\", \"frames\", \"stencilBuffer\", \"depthBuffer\", \"generateMipmaps\", \"resolution\", \"near\", \"far\", \"flip\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"matrix\", \"matrixAutoUpdate\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nvar RenderCubeTexture = /* @__PURE__ */React.forwardRef(function (_ref, forwardRef) {\n  var children = _ref.children,\n    compute = _ref.compute,\n    _ref$renderPriority = _ref.renderPriority,\n    renderPriority = _ref$renderPriority === void 0 ? -1 : _ref$renderPriority,\n    _ref$eventPriority = _ref.eventPriority,\n    eventPriority = _ref$eventPriority === void 0 ? 0 : _ref$eventPriority,\n    _ref$frames = _ref.frames,\n    frames = _ref$frames === void 0 ? Infinity : _ref$frames,\n    _ref$stencilBuffer = _ref.stencilBuffer,\n    stencilBuffer = _ref$stencilBuffer === void 0 ? false : _ref$stencilBuffer,\n    _ref$depthBuffer = _ref.depthBuffer,\n    depthBuffer = _ref$depthBuffer === void 0 ? true : _ref$depthBuffer,\n    _ref$generateMipmaps = _ref.generateMipmaps,\n    generateMipmaps = _ref$generateMipmaps === void 0 ? false : _ref$generateMipmaps,\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? 896 : _ref$resolution,\n    _ref$near = _ref.near,\n    near = _ref$near === void 0 ? 0.1 : _ref$near,\n    _ref$far = _ref.far,\n    far = _ref$far === void 0 ? 1000 : _ref$far,\n    _ref$flip = _ref.flip,\n    flip = _ref$flip === void 0 ? false : _ref$flip,\n    position = _ref.position,\n    rotation = _ref.rotation,\n    scale = _ref.scale,\n    quaternion = _ref.quaternion,\n    matrix = _ref.matrix,\n    matrixAutoUpdate = _ref.matrixAutoUpdate,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var _useThree = useThree(),\n    size = _useThree.size,\n    viewport = _useThree.viewport;\n  var camera = React.useRef(null);\n  var fbo = React.useMemo(function () {\n    var fbo = new THREE.WebGLCubeRenderTarget(Math.max((resolution || size.width) * viewport.dpr, (resolution || size.height) * viewport.dpr), {\n      stencilBuffer: stencilBuffer,\n      depthBuffer: depthBuffer,\n      generateMipmaps: generateMipmaps\n    });\n    fbo.texture.isRenderTargetTexture = !flip;\n    fbo.texture.flipY = true;\n    fbo.texture.type = THREE.HalfFloatType;\n    return fbo;\n  }, [resolution, flip]);\n  React.useEffect(function () {\n    return function () {\n      return fbo.dispose();\n    };\n  }, [fbo]);\n  var _React$useState = React.useState(function () {\n      return new THREE.Scene();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    vScene = _React$useState2[0];\n  React.useImperativeHandle(forwardRef, function () {\n    return {\n      scene: vScene,\n      fbo: fbo,\n      camera: camera.current\n    };\n  }, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    camera: camera\n  }, children, /*#__PURE__*/React.createElement(\"group\", {\n    onPointerOver: function onPointerOver() {\n      return null;\n    }\n  })), vScene, {\n    events: {\n      compute: compute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)), /*#__PURE__*/React.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo],\n    position: position,\n    rotation: rotation,\n    scale: scale,\n    quaternion: quaternion,\n    matrix: matrix,\n    matrixAutoUpdate: matrixAutoUpdate\n  }));\n});\n\n// The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\nfunction Container(_ref2) {\n  var frames = _ref2.frames,\n    renderPriority = _ref2.renderPriority,\n    children = _ref2.children,\n    camera = _ref2.camera;\n  var count = 0;\n  useFrame(function (state) {\n    if (frames === Infinity || count < frames) {\n      camera.current.update(state.gl, state.scene);\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\nexport { RenderCubeTexture };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}