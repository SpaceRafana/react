{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { mix } from '../math/MathNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, tslFn, nodeObject, nodeProxy, vec4 } from '../shadernode/ShaderNode.js';\nimport { LinearSRGBColorSpace, SRGBColorSpace } from 'three';\nconst sRGBToLinearShader = tslFn(inputs => {\n  const {\n    value\n  } = inputs;\n  const {\n    rgb\n  } = value;\n  const a = rgb.mul(0.9478672986).add(0.0521327014).pow(2.4);\n  const b = rgb.mul(0.0773993808);\n  const factor = rgb.lessThanEqual(0.04045);\n  const rgbResult = mix(a, b, factor);\n  return vec4(rgbResult, value.a);\n});\nconst LinearTosRGBShader = tslFn(inputs => {\n  const {\n    value\n  } = inputs;\n  const {\n    rgb\n  } = value;\n  const a = rgb.pow(0.41666).mul(1.055).sub(0.055);\n  const b = rgb.mul(12.92);\n  const factor = rgb.lessThanEqual(0.0031308);\n  const rgbResult = mix(a, b, factor);\n  return vec4(rgbResult, value.a);\n});\nconst getColorSpaceMethod = colorSpace => {\n  let method = null;\n  if (colorSpace === LinearSRGBColorSpace) {\n    method = 'Linear';\n  } else if (colorSpace === SRGBColorSpace) {\n    method = 'sRGB';\n  }\n  return method;\n};\nconst getMethod = (source, target) => {\n  return getColorSpaceMethod(source) + 'To' + getColorSpaceMethod(target);\n};\nclass ColorSpaceNode extends TempNode {\n  constructor(method, node) {\n    super('vec4');\n    this.method = method;\n    this.node = node;\n  }\n  setup() {\n    const {\n      method,\n      node\n    } = this;\n    if (method === ColorSpaceNode.LINEAR_TO_LINEAR) return node;\n    return Methods[method]({\n      value: node\n    });\n  }\n}\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\nColorSpaceNode.LINEAR_TO_sRGB = 'LinearTosRGB';\nColorSpaceNode.sRGB_TO_LINEAR = 'sRGBToLinear';\nconst Methods = {\n  [ColorSpaceNode.LINEAR_TO_sRGB]: LinearTosRGBShader,\n  [ColorSpaceNode.sRGB_TO_LINEAR]: sRGBToLinearShader\n};\nexport default ColorSpaceNode;\nexport const linearToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(LinearSRGBColorSpace, colorSpace), nodeObject(node)));\nexport const colorSpaceToLinear = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(colorSpace, LinearSRGBColorSpace), nodeObject(node)));\nexport const linearTosRGB = nodeProxy(ColorSpaceNode, ColorSpaceNode.LINEAR_TO_sRGB);\nexport const sRGBToLinear = nodeProxy(ColorSpaceNode, ColorSpaceNode.sRGB_TO_LINEAR);\naddNodeElement('linearTosRGB', linearTosRGB);\naddNodeElement('sRGBToLinear', sRGBToLinear);\naddNodeElement('linearToColorSpace', linearToColorSpace);\naddNodeElement('colorSpaceToLinear', colorSpaceToLinear);\naddNodeClass('ColorSpaceNode', ColorSpaceNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}