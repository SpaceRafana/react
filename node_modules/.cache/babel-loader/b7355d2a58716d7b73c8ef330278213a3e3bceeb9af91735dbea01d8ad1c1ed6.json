{"ast":null,"code":"import _slicedToArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectWithoutProperties from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\", \"material\", \"texture\", \"range\", \"limit\"],\n  _excluded2 = [\"opacity\", \"speed\", \"bounds\", \"segments\", \"color\", \"fade\", \"volume\", \"smallestVolume\", \"distribute\", \"growth\", \"concentrate\", \"seed\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Quaternion, Vector3, DynamicDrawUsage, MeshLambertMaterial, Matrix4, Color } from 'three';\nimport { extend, useFrame, applyProps } from '@react-three/fiber';\nimport { useTexture } from './useTexture.js';\nimport { v4 } from 'uuid';\nvar CLOUD_URL = 'https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png';\nvar parentMatrix = /* @__PURE__ */new Matrix4();\nvar translation = /* @__PURE__ */new Vector3();\nvar rotation = /* @__PURE__ */new Quaternion();\nvar cpos = /* @__PURE__ */new Vector3();\nvar cquat = /* @__PURE__ */new Quaternion();\nvar scale = /* @__PURE__ */new Vector3();\nvar context = /* @__PURE__ */React.createContext(null);\nvar Clouds = /* @__PURE__ */React.forwardRef(function (_ref, fref) {\n  var children = _ref.children,\n    _ref$material = _ref.material,\n    material = _ref$material === void 0 ? MeshLambertMaterial : _ref$material,\n    _ref$texture = _ref.texture,\n    texture = _ref$texture === void 0 ? CLOUD_URL : _ref$texture,\n    range = _ref.range,\n    _ref$limit = _ref.limit,\n    limit = _ref$limit === void 0 ? 200 : _ref$limit,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var _image$width, _image$height;\n  var CloudMaterial = React.useMemo(function () {\n    return /*#__PURE__*/function (_material) {\n      _inherits(_class, _material);\n      var _super = _createSuper(_class);\n      function _class() {\n        var _this;\n        _classCallCheck(this, _class);\n        _this = _super.call(this);\n        _this.onBeforeCompile = function (shader) {\n          shader.vertexShader = \"attribute float opacity;\\n               varying float vOpacity;\\n              \" + shader.vertexShader.replace('#include <fog_vertex>', \"#include <fog_vertex>\\n                 vOpacity = opacity;\\n                \");\n          shader.fragmentShader = \"varying float vOpacity;\\n              \" + shader.fragmentShader.replace('#include <opaque_fragment>', \"#include <opaque_fragment>\\n                 gl_FragColor = vec4(outgoingLight, diffuseColor.a * vOpacity);\\n                \");\n        };\n        return _this;\n      }\n      return _createClass(_class);\n    }(material);\n  }, [material]);\n  extend({\n    CloudMaterial: CloudMaterial\n  });\n  var instance = React.useRef(null);\n  var clouds = React.useRef([]);\n  var opacities = React.useMemo(function () {\n    return new Float32Array(Array.from({\n      length: limit\n    }, function () {\n      return 1;\n    }));\n  }, [limit]);\n  var colors = React.useMemo(function () {\n    return new Float32Array(Array.from({\n      length: limit\n    }, function () {\n      return [1, 1, 1];\n    }).flat());\n  }, [limit]);\n  var cloudTexture = useTexture(texture);\n  var t = 0;\n  var index = 0;\n  var config;\n  var qat = new Quaternion();\n  var dir = new Vector3(0, 0, 1);\n  var pos = new Vector3();\n  useFrame(function (state, delta) {\n    t = state.clock.getElapsedTime();\n    parentMatrix.copy(instance.current.matrixWorld).invert();\n    state.camera.matrixWorld.decompose(cpos, cquat, scale);\n    for (index = 0; index < clouds.current.length; index++) {\n      config = clouds.current[index];\n      config.ref.current.matrixWorld.decompose(translation, rotation, scale);\n      translation.add(pos.copy(config.position).applyQuaternion(rotation).multiply(scale));\n      rotation.copy(cquat).multiply(qat.setFromAxisAngle(dir, config.rotation += delta * config.rotationFactor));\n      scale.multiplyScalar(config.volume + (1 + Math.sin(t * config.density * config.speed)) / 2 * config.growth);\n      config.matrix.compose(translation, rotation, scale).premultiply(parentMatrix);\n      config.dist = translation.distanceTo(cpos);\n    }\n\n    // Depth-sort. Instances have no specific draw order, w/o sorting z would be random\n    clouds.current.sort(function (a, b) {\n      return b.dist - a.dist;\n    });\n    for (index = 0; index < clouds.current.length; index++) {\n      config = clouds.current[index];\n      opacities[index] = config.opacity * (config.dist < config.fade - 1 ? config.dist / config.fade : 1);\n      instance.current.setMatrixAt(index, config.matrix);\n      instance.current.setColorAt(index, config.color);\n    }\n\n    // Update instance\n    instance.current.geometry.attributes.opacity.needsUpdate = true;\n    instance.current.instanceMatrix.needsUpdate = true;\n    if (instance.current.instanceColor) instance.current.instanceColor.needsUpdate = true;\n  });\n  React.useLayoutEffect(function () {\n    var updateRange = Math.min(limit, range !== undefined ? range : limit, clouds.current.length);\n    instance.current.count = updateRange;\n    instance.current.instanceMatrix.updateRange.count = updateRange * 16;\n    if (instance.current.instanceColor) instance.current.instanceColor.updateRange.count = updateRange * 3;\n    instance.current.geometry.attributes.opacity.updateRange.count = updateRange;\n  });\n  var imageBounds = [(_image$width = cloudTexture.image.width) !== null && _image$width !== void 0 ? _image$width : 1, (_image$height = cloudTexture.image.height) !== null && _image$height !== void 0 ? _image$height : 1];\n  var max = Math.max(imageBounds[0], imageBounds[1]);\n  imageBounds = [imageBounds[0] / max, imageBounds[1] / max];\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: fref\n  }, props), /*#__PURE__*/React.createElement(context.Provider, {\n    value: clouds\n  }, children, /*#__PURE__*/React.createElement(\"instancedMesh\", {\n    matrixAutoUpdate: false,\n    ref: instance,\n    args: [null, null, limit]\n  }, /*#__PURE__*/React.createElement(\"instancedBufferAttribute\", {\n    usage: DynamicDrawUsage,\n    attach: \"instanceColor\",\n    args: [colors, 3]\n  }), /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: _toConsumableArray(imageBounds)\n  }, /*#__PURE__*/React.createElement(\"instancedBufferAttribute\", {\n    usage: DynamicDrawUsage,\n    attach: \"attributes-opacity\",\n    args: [opacities, 1]\n  })), /*#__PURE__*/React.createElement(\"cloudMaterial\", {\n    key: material.name,\n    map: cloudTexture,\n    transparent: true,\n    depthWrite: false\n  }))));\n});\nvar CloudInstance = /* @__PURE__ */React.forwardRef(function (_ref2, fref) {\n  var _ref2$opacity = _ref2.opacity,\n    opacity = _ref2$opacity === void 0 ? 1 : _ref2$opacity,\n    _ref2$speed = _ref2.speed,\n    speed = _ref2$speed === void 0 ? 0 : _ref2$speed,\n    _ref2$bounds = _ref2.bounds,\n    bounds = _ref2$bounds === void 0 ? [5, 1, 1] : _ref2$bounds,\n    _ref2$segments = _ref2.segments,\n    segments = _ref2$segments === void 0 ? 20 : _ref2$segments,\n    _ref2$color = _ref2.color,\n    color = _ref2$color === void 0 ? '#ffffff' : _ref2$color,\n    _ref2$fade = _ref2.fade,\n    fade = _ref2$fade === void 0 ? 10 : _ref2$fade,\n    _ref2$volume = _ref2.volume,\n    volume = _ref2$volume === void 0 ? 6 : _ref2$volume,\n    _ref2$smallestVolume = _ref2.smallestVolume,\n    smallestVolume = _ref2$smallestVolume === void 0 ? 0.25 : _ref2$smallestVolume,\n    _ref2$distribute = _ref2.distribute,\n    distribute = _ref2$distribute === void 0 ? null : _ref2$distribute,\n    _ref2$growth = _ref2.growth,\n    growth = _ref2$growth === void 0 ? 4 : _ref2$growth,\n    _ref2$concentrate = _ref2.concentrate,\n    concentrate = _ref2$concentrate === void 0 ? 'inside' : _ref2$concentrate,\n    _ref2$seed = _ref2.seed,\n    seed = _ref2$seed === void 0 ? Math.random() : _ref2$seed,\n    props = _objectWithoutProperties(_ref2, _excluded2);\n  function random() {\n    var x = Math.sin(seed++) * 10000;\n    return x - Math.floor(x);\n  }\n  var parent = React.useContext(context);\n  var ref = React.useRef(null);\n  var _React$useState = React.useState(function () {\n      return v4();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    uuid = _React$useState2[0];\n  var clouds = React.useMemo(function () {\n    return _toConsumableArray(new Array(segments)).map(function (_, index) {\n      return {\n        segments: segments,\n        bounds: new Vector3(1, 1, 1),\n        position: new Vector3(),\n        uuid: uuid,\n        index: index,\n        ref: ref,\n        dist: 0,\n        matrix: new Matrix4(),\n        color: new Color(),\n        rotation: index * (Math.PI / segments)\n      };\n    });\n  }, [segments, uuid]);\n  React.useLayoutEffect(function () {\n    clouds.forEach(function (cloud, index) {\n      var _distributed$point;\n      applyProps(cloud, {\n        volume: volume,\n        color: color,\n        speed: speed,\n        growth: growth,\n        opacity: opacity,\n        fade: fade,\n        bounds: bounds,\n        density: Math.max(0.5, random()),\n        rotationFactor: Math.max(0.2, 0.5 * random()) * speed\n      });\n      // Only distribute randomly if there are multiple segments\n\n      var distributed = distribute == null ? void 0 : distribute(cloud, index);\n      if (distributed || segments > 1) cloud.position.copy(cloud.bounds).multiply((_distributed$point = distributed == null ? void 0 : distributed.point) !== null && _distributed$point !== void 0 ? _distributed$point : {\n        x: random() * 2 - 1,\n        y: random() * 2 - 1,\n        z: random() * 2 - 1\n      });\n      var xDiff = Math.abs(cloud.position.x);\n      var yDiff = Math.abs(cloud.position.y);\n      var zDiff = Math.abs(cloud.position.z);\n      var max = Math.max(xDiff, yDiff, zDiff);\n      cloud.length = 1;\n      if (xDiff === max) cloud.length -= xDiff / cloud.bounds.x;\n      if (yDiff === max) cloud.length -= yDiff / cloud.bounds.y;\n      if (zDiff === max) cloud.length -= zDiff / cloud.bounds.z;\n      cloud.volume = ((distributed == null ? void 0 : distributed.volume) !== undefined ? distributed.volume : Math.max(Math.max(0, smallestVolume), concentrate === 'random' ? random() : concentrate === 'inside' ? cloud.length : 1 - cloud.length)) * volume;\n    });\n  }, [concentrate, bounds, fade, color, opacity, growth, volume, seed, segments, speed]);\n  React.useLayoutEffect(function () {\n    var temp = clouds;\n    parent.current = [].concat(_toConsumableArray(parent.current), _toConsumableArray(temp));\n    return function () {\n      parent.current = parent.current.filter(function (item) {\n        return item.uuid !== uuid;\n      });\n    };\n  }, [clouds]);\n  React.useImperativeHandle(fref, function () {\n    return ref.current;\n  }, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props));\n});\nvar Cloud = /* @__PURE__ */React.forwardRef(function (props, fref) {\n  var parent = React.useContext(context);\n  if (parent) return /*#__PURE__*/React.createElement(CloudInstance, _extends({\n    ref: fref\n  }, props));else return /*#__PURE__*/React.createElement(Clouds, null, /*#__PURE__*/React.createElement(CloudInstance, _extends({\n    ref: fref\n  }, props)));\n});\nexport { Cloud, CloudInstance, Clouds };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}