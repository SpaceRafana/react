{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport SetNode from '../utils/SetNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport { getValueFromType, getValueType } from '../core/NodeUtils.js';\nconst NodeElements = new Map(); // @TODO: Currently only a few nodes are added, probably also add others\n\nexport function addNodeElement(name, nodeElement) {\n  if (NodeElements.has(name)) throw new Error(`Redefinition of node element ${name}`);\n  if (typeof nodeElement !== 'function') throw new Error(`Node element ${name} is not a function`);\n  NodeElements.set(name, nodeElement);\n}\nconst parseSwizzle = props => props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\nconst shaderNodeHandler = {\n  setup(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(nodeObjects(inputs), ...params);\n  },\n  get: function (node, prop, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (NodeElements.has(prop)) {\n        const nodeElement = NodeElements.get(prop);\n        return (...params) => nodeElement(nodeObj, ...params);\n      } else if (prop === 'self') {\n        return node;\n      } else if (prop.endsWith('Assign') && NodeElements.has(prop.slice(0, prop.length - 'Assign'.length))) {\n        const nodeElement = NodeElements.get(prop.slice(0, prop.length - 'Assign'.length));\n        return (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));\n      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n\n        prop = parseSwizzle(prop);\n        return nodeObject(new SplitNode(node, prop));\n      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        // set properties ( swizzle )\n\n        prop = parseSwizzle(prop.slice(3).toLowerCase());\n\n        // sort to xyzw sequence\n\n        prop = prop.split('').sort().join('');\n        return value => nodeObject(new SetNode(node, prop, value));\n      } else if (prop === 'width' || prop === 'height' || prop === 'depth') {\n        // accessing property\n\n        if (prop === 'width') prop = 'x';else if (prop === 'height') prop = 'y';else if (prop === 'depth') prop = 'z';\n        return nodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n\n        return nodeObject(new ArrayElementNode(node, new ConstNode(Number(prop), 'uint')));\n      }\n    }\n    return node[prop];\n  }\n};\nconst nodeObjectsCacheMap = new WeakMap();\nconst ShaderNodeObject = function (obj, altType = null) {\n  const type = getValueType(obj);\n  if (type === 'node') {\n    let nodeObject = nodeObjectsCacheMap.get(obj);\n    if (nodeObject === undefined) {\n      nodeObject = new Proxy(obj, shaderNodeHandler);\n      nodeObjectsCacheMap.set(obj, nodeObject);\n      nodeObjectsCacheMap.set(nodeObject, nodeObject);\n    }\n    return nodeObject;\n  } else if (altType === null && (type === 'float' || type === 'boolean') || type && type !== 'shader' && type !== 'string') {\n    return nodeObject(getConstNode(obj, altType));\n  } else if (type === 'shader') {\n    return tslFn(obj);\n  }\n  return obj;\n};\nconst ShaderNodeObjects = function (objects, altType = null) {\n  for (const name in objects) {\n    objects[name] = nodeObject(objects[name], altType);\n  }\n  return objects;\n};\nconst ShaderNodeArray = function (array, altType = null) {\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    array[i] = nodeObject(array[i], altType);\n  }\n  return array;\n};\nconst ShaderNodeProxy = function (NodeClass, scope = null, factor = null, settings = null) {\n  const assignNode = node => nodeObject(settings !== null ? Object.assign(node, settings) : node);\n  if (scope === null) {\n    return (...params) => {\n      return assignNode(new NodeClass(...nodeArray(params)));\n    };\n  } else if (factor !== null) {\n    factor = nodeObject(factor);\n    return (...params) => {\n      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));\n    };\n  } else {\n    return (...params) => {\n      return assignNode(new NodeClass(scope, ...nodeArray(params)));\n    };\n  }\n};\nconst ShaderNodeImmutable = function (NodeClass, ...params) {\n  return nodeObject(new NodeClass(...nodeArray(params)));\n};\nclass ShaderCallNodeInternal extends Node {\n  constructor(shaderNode, inputNodes) {\n    super();\n    this.shaderNode = shaderNode;\n    this.inputNodes = inputNodes;\n  }\n  getNodeType(builder) {\n    const {\n      outputNode\n    } = builder.getNodeProperties(this);\n    return outputNode ? outputNode.getNodeType(builder) : super.getNodeType(builder);\n  }\n  call(builder) {\n    const {\n      shaderNode,\n      inputNodes\n    } = this;\n    const jsFunc = shaderNode.jsFunc;\n    const outputNode = inputNodes !== null ? jsFunc(nodeObjects(inputNodes), builder.stack, builder) : jsFunc(builder.stack, builder);\n    return nodeObject(outputNode);\n  }\n  setup(builder) {\n    builder.addStack();\n    builder.stack.outputNode = this.call(builder);\n    return builder.removeStack();\n  }\n  generate(builder, output) {\n    const {\n      outputNode\n    } = builder.getNodeProperties(this);\n    if (outputNode === null) {\n      // TSL: It's recommended to use `tslFn` in setup() pass.\n\n      return this.call(builder).build(builder, output);\n    }\n    return super.generate(builder, output);\n  }\n}\nclass ShaderNodeInternal extends Node {\n  constructor(jsFunc) {\n    super();\n    this.jsFunc = jsFunc;\n  }\n  call(inputs = null) {\n    return nodeObject(new ShaderCallNodeInternal(this, inputs));\n  }\n  setup() {\n    return this.call();\n  }\n}\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\nfor (const bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\nconst uintsCacheMap = new Map();\nfor (const uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\nfor (const int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\nfor (const float of floats) floatsCacheMap.set(float, new ConstNode(float));\nfor (const float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\nconst cacheMaps = {\n  bool: boolsCacheMap,\n  uint: uintsCacheMap,\n  ints: intsCacheMap,\n  float: floatsCacheMap\n};\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nconst getConstNode = (value, type) => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value, type);\n  }\n};\nconst safeGetNodeType = node => {\n  try {\n    return node.getNodeType();\n  } catch (_) {\n    return undefined;\n  }\n};\nconst ConvertType = function (type, cacheMap = null) {\n  return (...params) => {\n    if (params.length === 0 || !['bool', 'float', 'int', 'uint'].includes(type) && params.every(param => typeof param !== 'object')) {\n      params = [getValueFromType(type, ...params)];\n    }\n    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n      return nodeObject(cacheMap.get(params[0]));\n    }\n    if (params.length === 1) {\n      const node = getConstNode(params[0], type);\n      if (safeGetNodeType(node) === type) return nodeObject(node);\n      return nodeObject(new ConvertNode(node, type));\n    }\n    const nodes = params.map(param => getConstNode(param));\n    return nodeObject(new JoinNode(nodes, type));\n  };\n};\n\n// exports\n\n// utils\n\nexport const getConstNodeType = value => value !== undefined && value !== null ? value.nodeType || value.convertTo || (typeof value === 'string' ? value : null) : null;\n\n// shader node base\n\nexport function ShaderNode(jsFunc) {\n  return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);\n}\nexport const nodeObject = (val, altType = null) => /* new */ShaderNodeObject(val, altType);\nexport const nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);\nexport const nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);\nexport const nodeProxy = (...params) => new ShaderNodeProxy(...params);\nexport const nodeImmutable = (...params) => new ShaderNodeImmutable(...params);\nexport const shader = jsFunc => {\n  // @deprecated, r154\n\n  console.warn('TSL: shader() is deprecated. Use tslFn() instead.');\n  return new ShaderNode(jsFunc);\n};\nexport const tslFn = jsFunc => {\n  const shaderNode = new ShaderNode(jsFunc);\n  return inputs => shaderNode.call(inputs);\n};\naddNodeClass('ShaderNode', ShaderNode);\n\n// types\n// @TODO: Maybe export from ConstNode.js?\n\nexport const color = new ConvertType('color');\nexport const float = new ConvertType('float', cacheMaps.float);\nexport const int = new ConvertType('int', cacheMaps.int);\nexport const uint = new ConvertType('uint', cacheMaps.uint);\nexport const bool = new ConvertType('bool', cacheMaps.bool);\nexport const vec2 = new ConvertType('vec2');\nexport const ivec2 = new ConvertType('ivec2');\nexport const uvec2 = new ConvertType('uvec2');\nexport const bvec2 = new ConvertType('bvec2');\nexport const vec3 = new ConvertType('vec3');\nexport const ivec3 = new ConvertType('ivec3');\nexport const uvec3 = new ConvertType('uvec3');\nexport const bvec3 = new ConvertType('bvec3');\nexport const vec4 = new ConvertType('vec4');\nexport const ivec4 = new ConvertType('ivec4');\nexport const uvec4 = new ConvertType('uvec4');\nexport const bvec4 = new ConvertType('bvec4');\nexport const mat3 = new ConvertType('mat3');\nexport const imat3 = new ConvertType('imat3');\nexport const umat3 = new ConvertType('umat3');\nexport const bmat3 = new ConvertType('bmat3');\nexport const mat4 = new ConvertType('mat4');\nexport const imat4 = new ConvertType('imat4');\nexport const umat4 = new ConvertType('umat4');\nexport const bmat4 = new ConvertType('bmat4');\nexport const string = (value = '') => nodeObject(new ConstNode(value, 'string'));\nexport const arrayBuffer = value => nodeObject(new ConstNode(value, 'ArrayBuffer'));\naddNodeElement('color', color);\naddNodeElement('float', float);\naddNodeElement('int', int);\naddNodeElement('uint', uint);\naddNodeElement('bool', bool);\naddNodeElement('vec2', vec2);\naddNodeElement('ivec2', ivec2);\naddNodeElement('uvec2', uvec2);\naddNodeElement('bvec2', bvec2);\naddNodeElement('vec3', vec3);\naddNodeElement('ivec3', ivec3);\naddNodeElement('uvec3', uvec3);\naddNodeElement('bvec3', bvec3);\naddNodeElement('vec4', vec4);\naddNodeElement('ivec4', ivec4);\naddNodeElement('uvec4', uvec4);\naddNodeElement('bvec4', bvec4);\naddNodeElement('mat3', mat3);\naddNodeElement('imat3', imat3);\naddNodeElement('umat3', umat3);\naddNodeElement('bmat3', bmat3);\naddNodeElement('mat4', mat4);\naddNodeElement('imat4', imat4);\naddNodeElement('umat4', umat4);\naddNodeElement('bmat4', bmat4);\naddNodeElement('string', string);\naddNodeElement('arrayBuffer', arrayBuffer);\n\n// basic nodes\n// HACK - we cannot export them from the corresponding files because of the cyclic dependency\nexport const element = nodeProxy(ArrayElementNode);\nexport const convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));\nexport const split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));\naddNodeElement('element', element);\naddNodeElement('convert', convert);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}