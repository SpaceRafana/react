{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { nodeProxy } from '../shadernode/ShaderNode.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { reference } from './ReferenceNode.js';\nimport { bufferAttribute } from './BufferAttributeNode.js';\nimport { positionLocal } from './PositionNode.js';\nclass MorphNode extends Node {\n  constructor(mesh) {\n    super('void');\n    this.mesh = mesh;\n    this.morphBaseInfluence = uniform(1);\n    this.updateType = NodeUpdateType.OBJECT;\n  }\n  setupAttribute(builder, name, assignNode = positionLocal) {\n    const mesh = this.mesh;\n    const attributes = mesh.geometry.morphAttributes[name];\n    builder.stack.assign(assignNode, assignNode.mul(this.morphBaseInfluence));\n    for (let i = 0; i < attributes.length; i++) {\n      const attribute = attributes[i];\n      const bufferAttrib = bufferAttribute(attribute.array, 'vec3');\n      const influence = reference(i, 'float', mesh.morphTargetInfluences);\n      builder.stack.assign(assignNode, assignNode.add(bufferAttrib.mul(influence)));\n    }\n  }\n  setup(builder) {\n    this.setupAttribute(builder, 'position');\n  }\n  update() {\n    const morphBaseInfluence = this.morphBaseInfluence;\n    if (this.mesh.geometry.morphTargetsRelative) {\n      morphBaseInfluence.value = 1;\n    } else {\n      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);\n    }\n  }\n}\nexport default MorphNode;\nexport const morph = nodeProxy(MorphNode);\naddNodeClass('MorphNode', MorphNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}