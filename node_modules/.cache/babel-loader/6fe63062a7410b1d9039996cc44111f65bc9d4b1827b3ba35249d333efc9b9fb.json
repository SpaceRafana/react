{"ast":null,"code":"import _toConsumableArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncToGenerator from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { PropertyBinding, InterpolateLinear, Color, Vector3, CompressedTexture, Texture, MathUtils, RGBAFormat, DoubleSide, BufferAttribute, InterpolateDiscrete, Matrix4, Scene, PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, WebGLRenderer, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nfunction readAsDataURL(_x) {\n  return _readAsDataURL.apply(this, arguments);\n}\nfunction _readAsDataURL() {\n  _readAsDataURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blob) {\n    var buffer, data;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return blob.arrayBuffer();\n        case 2:\n          buffer = _context2.sent;\n          data = btoa(String.fromCharCode.apply(String, _toConsumableArray(new Uint8Array(buffer))));\n          return _context2.abrupt(\"return\", \"data:\".concat(blob.type || \"\", \";base64,\").concat(data));\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _readAsDataURL.apply(this, arguments);\n}\nvar _renderer;\nvar fullscreenQuadGeometry;\nvar fullscreenQuadMaterial;\nvar fullscreenQuad;\nfunction decompress(texture) {\n  var maxTextureSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var renderer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial) fullscreenQuadMaterial = new ShaderMaterial({\n    uniforms: {\n      blitTexture: new Uniform(texture)\n    },\n    vertexShader: /* glsl */\"\\n        varying vec2 vUv;\\n        void main(){\\n            vUv = uv;\\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\\n        }\\n      \",\n    fragmentShader: /* glsl */\"\\n          uniform sampler2D blitTexture; \\n          varying vec2 vUv;\\n\\n          void main(){ \\n              gl_FragColor = vec4(vUv.xy, 0, 1);\\n              \\n              #ifdef IS_SRGB\\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\\n              #else\\n              gl_FragColor = texture2D( blitTexture, vUv);\\n              #endif\\n          }\\n      \"\n  });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n  var _camera = new PerspectiveCamera();\n  var _scene = new Scene();\n  _scene.add(fullscreenQuad);\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({\n      antialias: false\n    });\n  }\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  var readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n  if (_renderer) {\n    _renderer.dispose();\n    _renderer = null;\n  }\n  return readableTexture;\n}\nvar KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\"byte\", \"byte normalized\", \"unsigned byte\", \"unsigned byte normalized\", \"short\", \"short normalized\", \"unsigned short\", \"unsigned short normalized\"],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nvar GLTFExporter = /*#__PURE__*/function () {\n  function GLTFExporter() {\n    _classCallCheck(this, GLTFExporter);\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer);\n    });\n  }\n  _createClass(GLTFExporter, [{\n    key: \"register\",\n    value: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Function} onError  Callback on errors\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(input, onDone, onError, options) {\n      var writer = new GLTFWriter();\n      var plugins = [];\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options).catch(onError);\n    }\n  }, {\n    key: \"parseAsync\",\n    value: function parseAsync(input, options) {\n      var scope = this;\n      return new Promise(function (resolve, reject) {\n        scope.parse(input, resolve, reject, options);\n      });\n    }\n  }]);\n  return GLTFExporter;\n}();\n/**\n * Static utility functions\n */\n__publicField(GLTFExporter, \"Utils\", {\n  insertKeyframe: function insertKeyframe(track, time) {\n    var tolerance = 1e-3;\n    var valueSize = track.getValueSize();\n    var times = new track.TimeBufferType(track.times.length + 1);\n    var values = new track.ValueBufferType(track.values.length + valueSize);\n    var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    var index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (var i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (var _i = 0; _i < track.times.length; _i++) {\n        if (Math.abs(track.times[_i] - time) < tolerance) return _i;\n        if (track.times[_i] < time && track.times[_i + 1] > time) {\n          times.set(track.times.slice(0, _i + 1), 0);\n          times[_i + 1] = time;\n          times.set(track.times.slice(_i + 1), _i + 2);\n          values.set(track.values.slice(0, (_i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (_i + 1) * valueSize);\n          values.set(track.values.slice((_i + 1) * valueSize), (_i + 2) * valueSize);\n          index = _i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\n    var tracks = [];\n    var mergedTracks = {};\n    var sourceTracks = clip.tracks;\n    for (var i = 0; i < sourceTracks.length; ++i) {\n      var sourceTrack = sourceTracks[i];\n      var sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      var sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n        }\n        console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      var targetCount = sourceTrackNode.morphTargetInfluences.length;\n      var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === void 0) {\n        throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n      }\n      var mergedTrack = void 0;\n      if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n        mergedTrack = sourceTrack.clone();\n        var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (var j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n        mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n      for (var _j = 0; _j < mergedTrack.times.length; _j++) {\n        mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\n      }\n      for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\n        var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n});\nvar WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nvar KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nvar THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nvar PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nvar DEFAULT_SPECULAR_COLOR = new Color();\nvar GLB_HEADER_BYTES = 12;\nvar GLB_HEADER_MAGIC = 1179937895;\nvar GLB_VERSION = 2;\nvar GLB_CHUNK_PREFIX_BYTES = 8;\nvar GLB_CHUNK_TYPE_JSON = 1313821514;\nvar GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  var output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (var i = start; i < start + count; i++) {\n    for (var a = 0; a < attribute.itemSize; a++) {\n      var value = void 0;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer) {\n  var paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    var array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise(function (resolve) {\n      return canvas.toBlob(resolve, mimeType);\n    });\n  }\n  var quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality\n  });\n}\nvar GLTFWriter = /*#__PURE__*/function () {\n  function GLTFWriter() {\n    _classCallCheck(this, GLTFWriter);\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */new Map(),\n      attributes: /* @__PURE__ */new Map(),\n      attributesNormalized: /* @__PURE__ */new Map(),\n      materials: /* @__PURE__ */new Map(),\n      textures: /* @__PURE__ */new Map(),\n      images: /* @__PURE__ */new Map()\n    };\n  }\n  _createClass(GLTFWriter, [{\n    key: \"setPlugins\",\n    value: function setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"write\",\n    value: function () {\n      var _write = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(input, onDone) {\n        var options,\n          writer,\n          buffers,\n          json,\n          extensionsUsed,\n          extensionsRequired,\n          blob,\n          extensionsUsedList,\n          extensionsRequiredList,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n              this.options = Object.assign({\n                // default options\n                binary: false,\n                trs: false,\n                onlyVisible: true,\n                maxTextureSize: Infinity,\n                animations: [],\n                includeCustomExtensions: false\n              }, options);\n              if (this.options.animations.length > 0) {\n                this.options.trs = true;\n              }\n              this.processInput(input);\n              _context.next = 6;\n              return Promise.all(this.pending);\n            case 6:\n              writer = this;\n              buffers = writer.buffers;\n              json = writer.json;\n              options = writer.options;\n              extensionsUsed = writer.extensionsUsed;\n              extensionsRequired = writer.extensionsRequired;\n              blob = new Blob(buffers, {\n                type: \"application/octet-stream\"\n              });\n              extensionsUsedList = Object.keys(extensionsUsed);\n              extensionsRequiredList = Object.keys(extensionsRequired);\n              if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n              if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;\n              if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n              if (options.binary === true) {\n                blob.arrayBuffer().then(function (result) {\n                  var binaryChunk = getPaddedArrayBuffer(result);\n                  var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                  binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n                  binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n                  var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n                  var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                  jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n                  jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n                  var header = new ArrayBuffer(GLB_HEADER_BYTES);\n                  var headerView = new DataView(header);\n                  headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n                  headerView.setUint32(4, GLB_VERSION, true);\n                  var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n                  headerView.setUint32(8, totalByteLength, true);\n                  var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n                    type: \"application/octet-stream\"\n                  });\n                  glbBlob.arrayBuffer().then(onDone);\n                });\n              } else {\n                if (json.buffers && json.buffers.length > 0) {\n                  readAsDataURL(blob).then(function (uri) {\n                    json.buffers[0].uri = uri;\n                  });\n                }\n                onDone(json);\n              }\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function write(_x2, _x3) {\n        return _write.apply(this, arguments);\n      }\n      return write;\n    }()\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n  }, {\n    key: \"serializeUserData\",\n    value: function serializeUserData(object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      var options = this.options;\n      var extensionsUsed = this.extensionsUsed;\n      try {\n        var json = JSON.parse(JSON.stringify(object.userData));\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === void 0) objectDef.extensions = {};\n          for (var extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n          delete json.gltfExtensions;\n        }\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message);\n      }\n    }\n    /**\n     * Returns ids for buffer attributes.\n     * @param  {Object} object\n     * @return {Integer}\n     */\n  }, {\n    key: \"getUID\",\n    value: function getUID(attribute) {\n      var isRelativeCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.uids.has(attribute) === false) {\n        var uids2 = /* @__PURE__ */new Map();\n        uids2.set(true, this.uid++);\n        uids2.set(false, this.uid++);\n        this.uids.set(attribute, uids2);\n      }\n      var uids = this.uids.get(attribute);\n      return uids.get(isRelativeCopy);\n    }\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isNormalizedNormalAttribute\",\n    value: function isNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      var v = new Vector3();\n      for (var i = 0, il = normal.count; i < il; i++) {\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return false;\n      }\n      return true;\n    }\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n  }, {\n    key: \"createNormalizedNormalAttribute\",\n    value: function createNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      var attribute = normal.clone();\n      var v = new Vector3();\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          v.setX(1);\n        } else {\n          v.normalize();\n        }\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    }\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n  }, {\n    key: \"applyTextureTransform\",\n    value: function applyTextureTransform(mapDef, texture) {\n      var didTransform = false;\n      var transformDef = {};\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n        this.extensionsUsed[\"KHR_texture_transform\"] = true;\n      }\n    }\n  }, {\n    key: \"buildMetalRoughTexture\",\n    value: function buildMetalRoughTexture(metalnessMap, roughnessMap) {\n      if (metalnessMap === roughnessMap) return metalnessMap;\n      function getEncodingConversion(map) {\n        if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n          return function SRGBToLinear(c) {\n            return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n          };\n        }\n        return function LinearToLinear(c) {\n          return c;\n        };\n      }\n      console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n      if (metalnessMap instanceof CompressedTexture) {\n        metalnessMap = decompress(metalnessMap);\n      }\n      if (roughnessMap instanceof CompressedTexture) {\n        roughnessMap = decompress(roughnessMap);\n      }\n      var metalness = metalnessMap ? metalnessMap.image : null;\n      var roughness = roughnessMap ? roughnessMap.image : null;\n      var width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n      var height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n      var canvas = getCanvas();\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext(\"2d\");\n      context.fillStyle = \"#00ffff\";\n      context.fillRect(0, 0, width, height);\n      var composite = context.getImageData(0, 0, width, height);\n      if (metalness) {\n        context.drawImage(metalness, 0, 0, width, height);\n        var convert = getEncodingConversion(metalnessMap);\n        var data = context.getImageData(0, 0, width, height).data;\n        for (var i = 2; i < data.length; i += 4) {\n          composite.data[i] = convert(data[i] / 256) * 256;\n        }\n      }\n      if (roughness) {\n        context.drawImage(roughness, 0, 0, width, height);\n        var _convert = getEncodingConversion(roughnessMap);\n        var _data = context.getImageData(0, 0, width, height).data;\n        for (var _i2 = 1; _i2 < _data.length; _i2 += 4) {\n          composite.data[_i2] = _convert(_data[_i2] / 256) * 256;\n        }\n      }\n      context.putImageData(composite, 0, 0);\n      var reference = metalnessMap || roughnessMap;\n      var texture = reference.clone();\n      texture.source = new Texture(canvas).source;\n      if (\"colorSpace\" in texture) texture.colorSpace = \"\";else texture.encoding = 3e3;\n      texture.channel = (metalnessMap || roughnessMap).channel;\n      if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n        console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n      }\n      return texture;\n    }\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n  }, {\n    key: \"processBuffer\",\n    value: function processBuffer(buffer) {\n      var json = this.json;\n      var buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }];\n      buffers.push(buffer);\n      return 0;\n    }\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n  }, {\n    key: \"processBufferView\",\n    value: function processBufferView(attribute, componentType, start, count, target) {\n      var json = this.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      var componentSize;\n      switch (componentType) {\n        case WEBGL_CONSTANTS.BYTE:\n        case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n          componentSize = 1;\n          break;\n        case WEBGL_CONSTANTS.SHORT:\n        case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n          componentSize = 2;\n          break;\n        default:\n          componentSize = 4;\n      }\n      var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      var dataView = new DataView(new ArrayBuffer(byteLength));\n      var offset = 0;\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n          if (attribute.itemSize > 4) {\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n            if (attribute.normalized === true) {\n              value = MathUtils.normalize(value, attribute.array);\n            }\n          }\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.INT) {\n            dataView.setInt32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n            dataView.setInt16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n            dataView.setInt8(offset, value);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n          offset += componentSize;\n        }\n      }\n      var bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength: byteLength\n      };\n      if (target !== void 0) bufferViewDef.target = target;\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef);\n      var output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    }\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n  }, {\n    key: \"processBufferViewImage\",\n    value: function processBufferViewImage(blob) {\n      var writer = this;\n      var json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return blob.arrayBuffer().then(function (result) {\n        var buffer = getPaddedArrayBuffer(result);\n        var bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        return json.bufferViews.push(bufferViewDef) - 1;\n      });\n    }\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n  }, {\n    key: \"processAccessor\",\n    value: function processAccessor(attribute, geometry, start, count) {\n      var json = this.json;\n      var types = {\n        1: \"SCALAR\",\n        2: \"VEC2\",\n        3: \"VEC3\",\n        4: \"VEC4\",\n        9: \"MAT3\",\n        16: \"MAT4\"\n      };\n      var componentType;\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Int32Array) {\n        componentType = WEBGL_CONSTANTS.INT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Int16Array) {\n        componentType = WEBGL_CONSTANTS.SHORT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Int8Array) {\n        componentType = WEBGL_CONSTANTS.BYTE;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error(\"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name);\n      }\n      if (start === void 0) start = 0;\n      if (count === void 0) count = attribute.count;\n      if (count === 0) return null;\n      var minMax = getMinMax(attribute, start, count);\n      var bufferViewTarget;\n      if (geometry !== void 0) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n      var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      var accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized === true) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    }\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (RGBAFormat)\n     * @param  {Boolean} flipY before writing out the image\n     * @param  {String} mimeType export format\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n  }, {\n    key: \"processImage\",\n    value: function processImage(image, format, flipY) {\n      var mimeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"image/png\";\n      if (image !== null) {\n        var writer = this;\n        var cache = writer.cache;\n        var json = writer.json;\n        var options = writer.options;\n        var pending = writer.pending;\n        if (!cache.images.has(image)) cache.images.set(image, {});\n        var cachedImages = cache.images.get(image);\n        var key = mimeType + \":flipY/\" + flipY.toString();\n        if (cachedImages[key] !== void 0) return cachedImages[key];\n        if (!json.images) json.images = [];\n        var imageDef = {\n          mimeType: mimeType\n        };\n        var canvas = getCanvas();\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        var ctx = canvas.getContext(\"2d\");\n        if (flipY === true) {\n          ctx.translate(0, canvas.height);\n          ctx.scale(1, -1);\n        }\n        if (image.data !== void 0) {\n          if (format !== RGBAFormat) {\n            console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n          }\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n          }\n          var data = new Uint8ClampedArray(image.height * image.width * 4);\n          for (var i = 0; i < data.length; i += 4) {\n            data[i + 0] = image.data[i + 0];\n            data[i + 1] = image.data[i + 1];\n            data[i + 2] = image.data[i + 2];\n            data[i + 3] = image.data[i + 3];\n          }\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        } else {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        }\n        if (options.binary === true) {\n          pending.push(getToBlobPromise(canvas, mimeType).then(function (blob) {\n            return writer.processBufferViewImage(blob);\n          }).then(function (bufferViewIndex) {\n            imageDef.bufferView = bufferViewIndex;\n          }));\n        } else {\n          if (canvas.toDataURL !== void 0) {\n            imageDef.uri = canvas.toDataURL(mimeType);\n          } else {\n            pending.push(getToBlobPromise(canvas, mimeType).then(readAsDataURL).then(function (uri) {\n              imageDef.uri = uri;\n            }));\n          }\n        }\n        var index = json.images.push(imageDef) - 1;\n        cachedImages[key] = index;\n        return index;\n      } else {\n        throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n      }\n    }\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n  }, {\n    key: \"processSampler\",\n    value: function processSampler(map) {\n      var json = this.json;\n      if (!json.samplers) json.samplers = [];\n      var samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    }\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(map) {\n      var writer = this;\n      var options = writer.options;\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      if (map instanceof CompressedTexture) {\n        map = decompress(map, options.maxTextureSize);\n      }\n      var mimeType = map.userData.mimeType;\n      if (mimeType === \"image/webp\") mimeType = \"image/png\";\n      var textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY, mimeType)\n      };\n      if (map.name) textureDef.name = map.name;\n      this._invokeAll(function (ext) {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n      var index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    }\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(material) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n      if (material.isShaderMaterial) {\n        console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n        return null;\n      }\n      if (!json.materials) json.materials = [];\n      var materialDef = {\n        pbrMetallicRoughness: {}\n      };\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n        console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n      }\n      var color = material.color.toArray().concat([material.opacity]);\n      if (!equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n      if (material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      }\n      if (material.metalnessMap || material.roughnessMap) {\n        var metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n        var metalRoughMapDef = {\n          index: this.processTexture(metalRoughTexture),\n          channel: metalRoughTexture.channel\n        };\n        this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      }\n      if (material.map) {\n        var baseColorMapDef = {\n          index: this.processTexture(material.map),\n          texCoord: material.map.channel\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n      if (material.emissive) {\n        var emissive = material.emissive;\n        var maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n        if (maxEmissiveComponent > 0) {\n          materialDef.emissiveFactor = material.emissive.toArray();\n        }\n        if (material.emissiveMap) {\n          var emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap),\n            texCoord: material.emissiveMap.channel\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      }\n      if (material.normalMap) {\n        var normalMapDef = {\n          index: this.processTexture(material.normalMap),\n          texCoord: material.normalMap.channel\n        };\n        if (material.normalScale && material.normalScale.x !== 1) {\n          normalMapDef.scale = material.normalScale.x;\n        }\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      }\n      if (material.aoMap) {\n        var occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: material.aoMap.channel\n        };\n        if (material.aoMapIntensity !== 1) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      }\n      if (material.transparent) {\n        materialDef.alphaMode = \"BLEND\";\n      } else {\n        if (material.alphaTest > 0) {\n          materialDef.alphaMode = \"MASK\";\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      }\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== \"\") materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n      this._invokeAll(function (ext) {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n      var index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    }\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n  }, {\n    key: \"processMesh\",\n    value: function processMesh(mesh) {\n      var cache = this.cache;\n      var json = this.json;\n      var meshCacheKeyParts = [mesh.geometry.uuid];\n      if (Array.isArray(mesh.material)) {\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n      var meshCacheKey = meshCacheKeyParts.join(\":\");\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      var geometry = mesh.geometry;\n      var mode;\n      if (mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n      var meshDef = {};\n      var attributes = {};\n      var primitives = [];\n      var targets = [];\n      var nameConversion = _objectSpread(_objectSpread({}, version >= 152 ? {\n        uv: \"TEXCOORD_0\",\n        uv1: \"TEXCOORD_1\",\n        uv2: \"TEXCOORD_2\",\n        uv3: \"TEXCOORD_3\"\n      } : {\n        uv: \"TEXCOORD_0\",\n        uv2: \"TEXCOORD_1\"\n      }), {}, {\n        color: \"COLOR_0\",\n        skinWeight: \"WEIGHTS_0\",\n        skinIndex: \"JOINTS_0\"\n      });\n      var originalNormal = geometry.getAttribute(\"normal\");\n      if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n        geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n      }\n      var modifiedAttribute = null;\n      for (var attributeName in geometry.attributes) {\n        if (attributeName.slice(0, 5) === \"morph\") continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = \"_\" + attributeName;\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        }\n        modifiedAttribute = null;\n        var array = attribute.array;\n        if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n        var accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n        if (accessor !== null) {\n          if (!attributeName.startsWith(\"_\")) {\n            this.detectMeshQuantization(attributeName, attribute);\n          }\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n      if (originalNormal !== void 0) geometry.setAttribute(\"normal\", originalNormal);\n      if (Object.keys(attributes).length === 0) return null;\n      if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n        var weights = [];\n        var targetNames = [];\n        var reverseDictionary = {};\n        if (mesh.morphTargetDictionary !== void 0) {\n          for (var key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n        for (var _i3 = 0; _i3 < mesh.morphTargetInfluences.length; ++_i3) {\n          var target = {};\n          var warned = false;\n          for (var _attributeName in geometry.morphAttributes) {\n            if (_attributeName !== \"position\" && _attributeName !== \"normal\") {\n              if (!warned) {\n                console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n                warned = true;\n              }\n              continue;\n            }\n            var _attribute = geometry.morphAttributes[_attributeName][_i3];\n            var gltfAttributeName = _attributeName.toUpperCase();\n            var baseAttribute = geometry.attributes[_attributeName];\n            if (cache.attributes.has(this.getUID(_attribute, true))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(_attribute, true));\n              continue;\n            }\n            var relativeAttribute = _attribute.clone();\n            if (!geometry.morphTargetsRelative) {\n              for (var j = 0, jl = _attribute.count; j < jl; j++) {\n                for (var a = 0; a < _attribute.itemSize; a++) {\n                  if (a === 0) relativeAttribute.setX(j, _attribute.getX(j) - baseAttribute.getX(j));\n                  if (a === 1) relativeAttribute.setY(j, _attribute.getY(j) - baseAttribute.getY(j));\n                  if (a === 2) relativeAttribute.setZ(j, _attribute.getZ(j) - baseAttribute.getZ(j));\n                  if (a === 3) relativeAttribute.setW(j, _attribute.getW(j) - baseAttribute.getW(j));\n                }\n              }\n            }\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n            cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n          }\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[_i3]);\n          if (mesh.morphTargetDictionary !== void 0) targetNames.push(reverseDictionary[_i3]);\n        }\n        meshDef.weights = weights;\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n      var isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\n      var groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: void 0,\n        count: void 0\n      }];\n      for (var _i4 = 0, il = groups.length; _i4 < il; _i4++) {\n        var primitive = {\n          mode: mode,\n          attributes: attributes\n        };\n        this.serializeUserData(geometry, primitive);\n        if (targets.length > 0) primitive.targets = targets;\n        if (geometry.index !== null) {\n          var cacheKey = this.getUID(geometry.index);\n          if (groups[_i4].start !== void 0 || groups[_i4].count !== void 0) {\n            cacheKey += \":\" + groups[_i4].start + \":\" + groups[_i4].count;\n          }\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i4].start, groups[_i4].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n          if (primitive.indices === null) delete primitive.indices;\n        }\n        var material = this.processMaterial(materials[groups[_i4].materialIndex]);\n        if (material !== null) primitive.material = material;\n        primitives.push(primitive);\n      }\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n      this._invokeAll(function (ext) {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n      var index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    }\n    /**\n     * If a vertex attribute with a\n     * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n     * is used, it is checked whether it is a valid data type according to the\n     * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n     * extension.\n     * In this case the extension is automatically added to the list of used extensions.\n     *\n     * @param {string} attributeName\n     * @param {THREE.BufferAttribute} attribute\n     */\n  }, {\n    key: \"detectMeshQuantization\",\n    value: function detectMeshQuantization(attributeName, attribute) {\n      if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;\n      var attrType = void 0;\n      switch (attribute.array.constructor) {\n        case Int8Array:\n          attrType = \"byte\";\n          break;\n        case Uint8Array:\n          attrType = \"unsigned byte\";\n          break;\n        case Int16Array:\n          attrType = \"short\";\n          break;\n        case Uint16Array:\n          attrType = \"unsigned short\";\n          break;\n        default:\n          return;\n      }\n      if (attribute.normalized) attrType += \" normalized\";\n      var attrNamePrefix = attributeName.split(\"_\", 1)[0];\n      if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n        this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n        this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n      }\n    }\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n  }, {\n    key: \"processCamera\",\n    value: function processCamera(camera) {\n      var json = this.json;\n      if (!json.cameras) json.cameras = [];\n      var isOrtho = camera.isOrthographicCamera;\n      var cameraDef = {\n        type: isOrtho ? \"orthographic\" : \"perspective\"\n      };\n      if (isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 1e-3 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 1e-3 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      }\n      if (camera.name !== \"\") cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    }\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n  }, {\n    key: \"processAnimation\",\n    value: function processAnimation(clip, root) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      var tracks = clip.tracks;\n      var channels = [];\n      var samplers = [];\n      for (var i = 0; i < tracks.length; ++i) {\n        var track = tracks[i];\n        var trackBinding = PropertyBinding.parseTrackName(track.name);\n        var trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n        if (trackBinding.objectName === \"bones\") {\n          if (trackNode.isSkinnedMesh === true) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = void 0;\n          }\n        }\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n        var inputItemSize = 1;\n        var outputItemSize = track.values.length / track.times.length;\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n        var interpolation = void 0;\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n          interpolation = \"CUBICSPLINE\";\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = \"STEP\";\n        } else {\n          interpolation = \"LINEAR\";\n        }\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation: interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n      json.animations.push({\n        name: clip.name || \"clip_\" + json.animations.length,\n        samplers: samplers,\n        channels: channels\n      });\n      return json.animations.length - 1;\n    }\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n  }, {\n    key: \"processSkin\",\n    value: function processSkin(object) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      var node = json.nodes[nodeMap.get(object)];\n      var skeleton = object.skeleton;\n      if (skeleton === void 0) return null;\n      var rootJoint = object.skeleton.bones[0];\n      if (rootJoint === void 0) return null;\n      var joints = [];\n      var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      var temporaryBoneInverse = new Matrix4();\n      for (var i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n      if (json.skins === void 0) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      var skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    }\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n  }, {\n    key: \"processNode\",\n    value: function processNode(object) {\n      var json = this.json;\n      var options = this.options;\n      var nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      var nodeDef = {};\n      if (options.trs) {\n        var rotation = object.quaternion.toArray();\n        var position = object.position.toArray();\n        var scale = object.scale.toArray();\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n        if (!equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n        if (!equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n        if (isIdentityMatrix(object.matrix) === false) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      }\n      if (object.name !== \"\") nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n      if (object.isMesh || object.isLine || object.isPoints) {\n        var meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n      if (object.isSkinnedMesh) this.skins.push(object);\n      if (object.children.length > 0) {\n        var children = [];\n        for (var i = 0, l = object.children.length; i < l; i++) {\n          var child = object.children[i];\n          if (child.visible || options.onlyVisible === false) {\n            var nodeIndex2 = this.processNode(child);\n            if (nodeIndex2 !== null) children.push(nodeIndex2);\n          }\n        }\n        if (children.length > 0) nodeDef.children = children;\n      }\n      this._invokeAll(function (ext) {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    }\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n  }, {\n    key: \"processScene\",\n    value: function processScene(scene) {\n      var json = this.json;\n      var options = this.options;\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n      var sceneDef = {};\n      if (scene.name !== \"\") sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      var nodes = [];\n      for (var i = 0, l = scene.children.length; i < l; i++) {\n        var child = scene.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          var nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    }\n    /**\n     * Creates a Scene to hold a list of objects and parse it\n     * @param  {Array} objects List of objects to process\n     */\n  }, {\n    key: \"processObjects\",\n    value: function processObjects(objects) {\n      var scene = new Scene();\n      scene.name = \"AuxScene\";\n      for (var i = 0; i < objects.length; i++) {\n        scene.children.push(objects[i]);\n      }\n      this.processScene(scene);\n    }\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n  }, {\n    key: \"processInput\",\n    value: function processInput(input) {\n      var options = this.options;\n      input = input instanceof Array ? input : [input];\n      this._invokeAll(function (ext) {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n      var objectsWithoutScene = [];\n      for (var i = 0; i < input.length; i++) {\n        if (input[i] instanceof Scene) {\n          this.processScene(input[i]);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n      for (var _i5 = 0; _i5 < this.skins.length; ++_i5) {\n        this.processSkin(this.skins[_i5]);\n      }\n      for (var _i6 = 0; _i6 < options.animations.length; ++_i6) {\n        this.processAnimation(options.animations[_i6], input[0]);\n      }\n      this._invokeAll(function (ext) {\n        ext.afterParse && ext.afterParse(input);\n      });\n    }\n  }, {\n    key: \"_invokeAll\",\n    value: function _invokeAll(func) {\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    }\n  }]);\n  return GLTFWriter;\n}();\nvar GLTFLightExtension = /*#__PURE__*/function () {\n  function GLTFLightExtension(writer) {\n    _classCallCheck(this, GLTFLightExtension);\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  _createClass(GLTFLightExtension, [{\n    key: \"writeNode\",\n    value: function writeNode(light, nodeDef) {\n      if (!light.isLight) return;\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n        console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n        return;\n      }\n      var writer = this.writer;\n      var json = writer.json;\n      var extensionsUsed = writer.extensionsUsed;\n      var lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n      if (light.isDirectionalLight) {\n        lightDef.type = \"directional\";\n      } else if (light.isPointLight) {\n        lightDef.type = \"point\";\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light.isSpotLight) {\n        lightDef.type = \"spot\";\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n      if (light.decay !== void 0 && light.decay !== 2) {\n        console.warn(\"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\");\n      }\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn(\"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\");\n      }\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n      var lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  }]);\n  return GLTFLightExtension;\n}();\nvar GLTFMaterialsUnlitExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsUnlitExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  _createClass(GLTFMaterialsUnlitExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshBasicMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  }]);\n  return GLTFMaterialsUnlitExtension;\n}();\nvar GLTFMaterialsClearcoatExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsClearcoatExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsClearcoatExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  _createClass(GLTFMaterialsClearcoatExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.clearcoatFactor = material.clearcoat;\n      if (material.clearcoatMap) {\n        var clearcoatMapDef = {\n          index: writer.processTexture(material.clearcoatMap),\n          texCoord: material.clearcoatMap.channel\n        };\n        writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n        extensionDef.clearcoatTexture = clearcoatMapDef;\n      }\n      extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n      if (material.clearcoatRoughnessMap) {\n        var clearcoatRoughnessMapDef = {\n          index: writer.processTexture(material.clearcoatRoughnessMap),\n          texCoord: material.clearcoatRoughnessMap.channel\n        };\n        writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n        extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n      }\n      if (material.clearcoatNormalMap) {\n        var clearcoatNormalMapDef = {\n          index: writer.processTexture(material.clearcoatNormalMap),\n          texCoord: material.clearcoatNormalMap.channel\n        };\n        writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n        extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsClearcoatExtension;\n}();\nvar GLTFMaterialsIridescenceExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsIridescenceExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsIridescenceExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  _createClass(GLTFMaterialsIridescenceExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.iridescenceFactor = material.iridescence;\n      if (material.iridescenceMap) {\n        var iridescenceMapDef = {\n          index: writer.processTexture(material.iridescenceMap),\n          texCoord: material.iridescenceMap.channel\n        };\n        writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n        extensionDef.iridescenceTexture = iridescenceMapDef;\n      }\n      extensionDef.iridescenceIor = material.iridescenceIOR;\n      extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n      extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n      if (material.iridescenceThicknessMap) {\n        var iridescenceThicknessMapDef = {\n          index: writer.processTexture(material.iridescenceThicknessMap),\n          texCoord: material.iridescenceThicknessMap.channel\n        };\n        writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n        extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsIridescenceExtension;\n}();\nvar GLTFMaterialsTransmissionExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsTransmissionExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  _createClass(GLTFMaterialsTransmissionExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.transmissionFactor = material.transmission;\n      if (material.transmissionMap) {\n        var transmissionMapDef = {\n          index: writer.processTexture(material.transmissionMap),\n          texCoord: material.transmissionMap.channel\n        };\n        writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n        extensionDef.transmissionTexture = transmissionMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsTransmissionExtension;\n}();\nvar GLTFMaterialsVolumeExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsVolumeExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  _createClass(GLTFMaterialsVolumeExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.thicknessFactor = material.thickness;\n      if (material.thicknessMap) {\n        var thicknessMapDef = {\n          index: writer.processTexture(material.thicknessMap),\n          texCoord: material.thicknessMap.channel\n        };\n        writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n        extensionDef.thicknessTexture = thicknessMapDef;\n      }\n      extensionDef.attenuationDistance = material.attenuationDistance;\n      extensionDef.attenuationColor = material.attenuationColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsVolumeExtension;\n}();\nvar GLTFMaterialsIorExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsIorExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsIorExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  _createClass(GLTFMaterialsIorExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.ior = material.ior;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsIorExtension;\n}();\nvar GLTFMaterialsSpecularExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsSpecularExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsSpecularExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  _createClass(GLTFMaterialsSpecularExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (material.specularIntensityMap) {\n        var specularIntensityMapDef = {\n          index: writer.processTexture(material.specularIntensityMap),\n          texCoord: material.specularIntensityMap.channel\n        };\n        writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n        extensionDef.specularTexture = specularIntensityMapDef;\n      }\n      if (material.specularColorMap) {\n        var specularColorMapDef = {\n          index: writer.processTexture(material.specularColorMap),\n          texCoord: material.specularColorMap.channel\n        };\n        writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n        extensionDef.specularColorTexture = specularColorMapDef;\n      }\n      extensionDef.specularFactor = material.specularIntensity;\n      extensionDef.specularColorFactor = material.specularColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsSpecularExtension;\n}();\nvar GLTFMaterialsSheenExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsSheenExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsSheenExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  _createClass(GLTFMaterialsSheenExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.sheen == 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (material.sheenRoughnessMap) {\n        var sheenRoughnessMapDef = {\n          index: writer.processTexture(material.sheenRoughnessMap),\n          texCoord: material.sheenRoughnessMap.channel\n        };\n        writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n        extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n      }\n      if (material.sheenColorMap) {\n        var sheenColorMapDef = {\n          index: writer.processTexture(material.sheenColorMap),\n          texCoord: material.sheenColorMap.channel\n        };\n        writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n        extensionDef.sheenColorTexture = sheenColorMapDef;\n      }\n      extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n      extensionDef.sheenColorFactor = material.sheenColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsSheenExtension;\n}();\nvar GLTFMaterialsAnisotropyExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsAnisotropyExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsAnisotropyExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  _createClass(GLTFMaterialsAnisotropyExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.anisotropy == 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (material.anisotropyMap) {\n        var anisotropyMapDef = {\n          index: writer.processTexture(material.anisotropyMap)\n        };\n        writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n        extensionDef.anisotropyTexture = anisotropyMapDef;\n      }\n      extensionDef.anisotropyStrength = material.anisotropy;\n      extensionDef.anisotropyRotation = material.anisotropyRotation;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsAnisotropyExtension;\n}();\nvar GLTFMaterialsEmissiveStrengthExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsEmissiveStrengthExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsEmissiveStrengthExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  _createClass(GLTFMaterialsEmissiveStrengthExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.emissiveStrength = material.emissiveIntensity;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsEmissiveStrengthExtension;\n}();\nexport { GLTFExporter };\n//# sourceMappingURL=GLTFExporter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}