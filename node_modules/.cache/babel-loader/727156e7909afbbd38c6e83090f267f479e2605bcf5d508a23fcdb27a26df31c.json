{"ast":null,"code":"import NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { temp } from '../core/VarNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor } from '../accessors/MaterialNode.js';\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { abs, mix, mod, dot, clamp, smoothstep } from '../math/MathNode.js';\nimport { tslFn, ShaderNode, float, vec2, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { materialLineScale, materialLineDashSize, materialLineGapSize, materialLineDashOffset, materialLineWidth } from '../accessors/LineMaterialNode.js';\nimport { viewport } from '../display/ViewportNode.js';\nimport { dashSize, gapSize } from '../core/PropertyNode.js';\nimport { LineDashedMaterial } from 'three';\nconst defaultValues = new LineDashedMaterial();\nclass Line2NodeMaterial extends NodeMaterial {\n  constructor(params = {}) {\n    super();\n    this.normals = false;\n    this.lights = false;\n    this.setDefaultValues(defaultValues);\n    this.useAlphaToCoverage = true;\n    this.useColor = params.vertexColors;\n    this.useDash = params.dashed;\n    this.useWorldUnits = false;\n    this.dashOffset = 0;\n    this.lineWidth = 1;\n    this.lineColorNode = null;\n    this.offsetNode = null;\n    this.dashScaleNode = null;\n    this.dashSizeNode = null;\n    this.gapSizeNode = null;\n    this.setupShaders();\n    this.setValues(params);\n  }\n  setupShaders() {\n    const useAlphaToCoverage = this.alphaToCoverage;\n    const useColor = this.useColor;\n    const useDash = this.dashed;\n    const useWorldUnits = this.worldUnits;\n    const trimSegment = tslFn(({\n      start,\n      end\n    }) => {\n      const a = cameraProjectionMatrix.element(2).element(2); // 3nd entry in 3th column\n      const b = cameraProjectionMatrix.element(3).element(2); // 3nd entry in 4th column\n      const nearEstimate = b.mul(-0.5).div(a);\n      const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));\n      return vec4(mix(start.xyz, end.xyz, alpha), end.w);\n    });\n    this.vertexNode = new ShaderNode(stack => {\n      stack.assign(varying(vec2(), 'vUv'), uv());\n      const instanceStart = attribute('instanceStart');\n      const instanceEnd = attribute('instanceEnd');\n\n      // camera space\n\n      const start = property('vec4', 'start');\n      const end = property('vec4', 'end');\n      stack.assign(start, modelViewMatrix.mul(vec4(instanceStart, 1.0))); // force assignment into correct place in flow\n      stack.assign(end, modelViewMatrix.mul(vec4(instanceEnd, 1.0)));\n      if (useWorldUnits) {\n        stack.assign(varying(vec3(), 'worldStart'), start.xyz);\n        stack.assign(varying(vec3(), 'worldEnd'), end.xyz);\n      }\n      const aspect = viewport.z.div(viewport.w);\n\n      // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n      // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n      // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n      // perhaps there is a more elegant solution -- WestLangley\n\n      const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1.0); // 4th entry in the 3rd column\n\n      stack.if(perspective, stack => {\n        stack.if(start.z.lessThan(0.0).and(end.z.greaterThan(0.0)), stack => {\n          stack.assign(end, trimSegment({\n            start: start,\n            end: end\n          }));\n        }).elseif(end.z.lessThan(0.0).and(start.z.greaterThanEqual(0.0)), stack => {\n          stack.assign(start, trimSegment({\n            start: end,\n            end: start\n          }));\n        });\n      });\n\n      // clip space\n      const clipStart = cameraProjectionMatrix.mul(start);\n      const clipEnd = cameraProjectionMatrix.mul(end);\n\n      // ndc space\n      const ndcStart = clipStart.xyz.div(clipStart.w);\n      const ndcEnd = clipEnd.xyz.div(clipEnd.w);\n\n      // direction\n      const dir = ndcEnd.xy.sub(ndcStart.xy);\n\n      // account for clip-space aspect ratio\n      stack.assign(dir.x, dir.x.mul(aspect));\n      stack.assign(dir, dir.normalize());\n      const clip = temp(vec4());\n      if (useWorldUnits) {\n        // get the offset direction as perpendicular to the view vector\n        const worldDir = end.xyz.sub(start.xyz).normalize();\n        const offset = positionGeometry.y.lessThan(0.5).cond(start.xyz.cross(worldDir).normalize(), end.xyz.cross(worldDir).normalize());\n\n        // sign flip\n        stack.assign(offset, positionGeometry.x.lessThan(0.0).cond(offset.negate(), offset));\n        const forwardOffset = worldDir.dot(vec3(0.0, 0.0, 1.0));\n\n        // don't extend the line if we're rendering dashes because we\n        // won't be rendering the endcaps\n        if (!useDash) {\n          // extend the line bounds to encompass endcaps\n          stack.assign(start, start.sub(vec4(worldDir.mul(materialLineWidth).mul(0.5), 0)));\n          stack.assign(end, end.add(vec4(worldDir.mul(materialLineWidth).mul(0.5), 0)));\n\n          // shift the position of the quad so it hugs the forward edge of the line\n          stack.assign(offset, offset.sub(vec3(dir.mul(forwardOffset), 0)));\n          stack.assign(offset.z, offset.z.add(0.5));\n        }\n\n        // endcaps\n\n        stack.if(positionGeometry.y.greaterThan(1.0).or(positionGeometry.y.lessThan(0.0)), stack => {\n          stack.assign(offset, offset.add(vec3(dir.mul(2.0).mul(forwardOffset), 0)));\n        });\n\n        // adjust for linewidth\n        stack.assign(offset, offset.mul(materialLineWidth).mul(0.5));\n\n        // set the world position\n\n        const worldPos = varying(vec4(), 'worldPos');\n        stack.assign(worldPos, positionGeometry.y.lessThan(0.5).cond(start, end));\n        stack.assign(worldPos, worldPos.add(vec4(offset, 0)));\n\n        // project the worldpos\n        stack.assign(clip, cameraProjectionMatrix.mul(worldPos));\n\n        // shift the depth of the projected points so the line\n        // segments overlap neatly\n        const clipPose = temp(vec3());\n        stack.assign(clipPose, positionGeometry.y.lessThan(0.5).cond(ndcStart, ndcEnd));\n        stack.assign(clip.z, clipPose.z.mul(clip.w));\n      } else {\n        const offset = property('vec2', 'offset');\n        stack.assign(offset, vec2(dir.y, dir.x.negate()));\n\n        // undo aspect ratio adjustment\n        stack.assign(dir.x, dir.x.div(aspect));\n        stack.assign(offset.x, offset.x.div(aspect));\n\n        // sign flip\n        stack.assign(offset, positionGeometry.x.lessThan(0.0).cond(offset.negate(), offset));\n\n        // endcaps\n        stack.if(positionGeometry.y.lessThan(0.0), stack => {\n          stack.assign(offset, offset.sub(dir));\n        }).elseif(positionGeometry.y.greaterThan(1.0), stack => {\n          stack.assign(offset, offset.add(dir));\n        });\n\n        // adjust for linewidth\n        stack.assign(offset, offset.mul(materialLineWidth));\n\n        // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n        stack.assign(offset, offset.div(viewport.w));\n\n        // select end\n        stack.assign(clip, positionGeometry.y.lessThan(0.5).cond(clipStart, clipEnd));\n\n        // back to clip space\n        stack.assign(offset, offset.mul(clip.w));\n        stack.assign(clip, clip.add(vec4(offset, 0, 0)));\n      }\n      return clip;\n    });\n    const closestLineToLine = tslFn(({\n      p1,\n      p2,\n      p3,\n      p4\n    }) => {\n      const p13 = p1.sub(p3);\n      const p43 = p4.sub(p3);\n      const p21 = p2.sub(p1);\n      const d1343 = dot(p13, p43);\n      const d4321 = dot(p43, p21);\n      const d1321 = dot(p13, p21);\n      const d4343 = dot(p43, p43);\n      const d2121 = dot(p21, p21);\n      const denom = d2121.mul(d4343).sub(d4321.mul(d4321));\n      const numer = d1343.mul(d4321).sub(d1321.mul(d4343));\n      const mua = clamp(numer.div(denom), 0, 1);\n      const mub = clamp(d1343.add(d4321.mul(mua)).div(d4343), 0, 1);\n      return vec2(mua, mub);\n    });\n    this.colorNode = new ShaderNode(stack => {\n      const vUv = varying(vec2(), 'vUv');\n      if (useDash) {\n        const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;\n        const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;\n        const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;\n        const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;\n        stack.assign(dashSize, dashSizeNode);\n        stack.assign(gapSize, gapSizeNode);\n        const instanceDistanceStart = attribute('instanceDistanceStart');\n        const instanceDistanceEnd = attribute('instanceDistanceEnd');\n        const lineDistance = positionGeometry.y.lessThan(0.5).cond(dashScaleNode.mul(instanceDistanceStart), materialLineScale.mul(instanceDistanceEnd));\n        const vLineDistance = varying(lineDistance.add(materialLineDashOffset));\n        const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;\n        stack.add(vUv.y.lessThan(-1.0).or(vUv.y.greaterThan(1.0)).discard()); // discard endcaps\n        stack.add(mod(vLineDistanceOffset, dashSize.add(gapSize)).greaterThan(dashSize).discard()); // todo - FIX\n      }\n\n      // force assignment into correct place in flow\n      const alpha = property('float', 'alpha');\n      stack.assign(alpha, 1);\n      if (useWorldUnits) {\n        let worldStart = varying(vec3(), 'worldStart');\n        let worldEnd = varying(vec3(), 'worldEnd');\n\n        // Find the closest points on the view ray and the line segment\n        const rayEnd = varying(vec4(), 'worldPos').xyz.normalize().mul(1e5);\n        const lineDir = worldEnd.sub(worldStart);\n        const params = closestLineToLine({\n          p1: worldStart,\n          p2: worldEnd,\n          p3: vec3(0.0, 0.0, 0.0),\n          p4: rayEnd\n        });\n        const p1 = worldStart.add(lineDir.mul(params.x));\n        const p2 = rayEnd.mul(params.y);\n        const delta = p1.sub(p2);\n        const len = delta.length();\n        const norm = len.div(materialLineWidth);\n        if (!useDash) {\n          if (useAlphaToCoverage) {\n            const dnorm = norm.fwidth();\n            stack.assign(alpha, smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());\n          } else {\n            stack.add(norm.greaterThan(0.5).discard());\n          }\n        }\n      } else {\n        // round endcaps\n\n        if (useAlphaToCoverage) {\n          const a = vUv.x;\n          const b = vUv.y.greaterThan(0.0).cond(vUv.y.sub(1.0), vUv.y.add(1.0));\n          const len2 = a.mul(a).add(b.mul(b));\n\n          // force assignment out of following 'if' statement - to avoid uniform control flow errors\n          const dlen = property('float', 'dlen');\n          stack.assign(dlen, len2.fwidth());\n          stack.if(abs(vUv.y).greaterThan(1.0), stack => {\n            stack.assign(alpha, smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n          });\n        } else {\n          stack.if(abs(vUv.y).greaterThan(1.0), stack => {\n            const a = vUv.x;\n            const b = vUv.y.greaterThan(0.0).cond(vUv.y.sub(1.0), vUv.y.add(1.0));\n            const len2 = a.mul(a).add(b.mul(b));\n            stack.add(len2.greaterThan(1.0).discard());\n          });\n        }\n      }\n      let lineColorNode;\n      if (this.lineColorNode) {\n        lineColorNode = this.lineColorNode;\n      } else {\n        if (useColor) {\n          const instanceColorStart = attribute('instanceColorStart');\n          const instanceColorEnd = attribute('instanceColorEnd');\n          lineColorNode = varying(positionGeometry.y.lessThan(0.5).cond(instanceColorStart, instanceColorEnd));\n        } else {\n          lineColorNode = materialColor;\n        }\n      }\n      return vec4(lineColorNode, alpha);\n    });\n    this.needsUpdate = true;\n  }\n  get worldUnits() {\n    return this.useWorldUnits;\n  }\n  set worldUnits(value) {\n    if (this.useWorldUnits !== value) {\n      this.useWorldUnits = value;\n      this.setupShaders();\n    }\n  }\n  get dashed() {\n    return this.useDash;\n  }\n  set dashed(value) {\n    if (this.useDash !== value) {\n      this.useDash = value;\n      this.setupShaders();\n    }\n  }\n  get alphaToCoverage() {\n    return this.useAlphaToCoverage;\n  }\n  set alphaToCoverage(value) {\n    if (this.useAlphaToCoverage !== value) {\n      this.useAlphaToCoverage = value;\n      this.setupShaders();\n    }\n  }\n}\nexport default Line2NodeMaterial;\naddNodeMaterial('Line2NodeMaterial', Line2NodeMaterial);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}