{"ast":null,"code":"import _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BufferGeometry, Vector3, Matrix4, Float32BufferAttribute } from \"three\";\nvar DecalGeometry = /*#__PURE__*/function (_BufferGeometry) {\n  _inherits(DecalGeometry, _BufferGeometry);\n  var _super = _createSuper(DecalGeometry);\n  function DecalGeometry(mesh, position, orientation, size) {\n    var _this;\n    _classCallCheck(this, DecalGeometry);\n    _this = _super.call(this);\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n    var plane = new Vector3();\n    var projectorMatrix = new Matrix4();\n    projectorMatrix.makeRotationFromEuler(orientation);\n    projectorMatrix.setPosition(position);\n    var projectorMatrixInverse = new Matrix4();\n    projectorMatrixInverse.copy(projectorMatrix).invert();\n    generate();\n    _this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    _this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    _this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function generate() {\n      var i;\n      var decalVertices = [];\n      var vertex = new Vector3();\n      var normal = new Vector3();\n      if (mesh.geometry.isGeometry === true) {\n        console.error(\"THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.\");\n        return;\n      }\n      var geometry = mesh.geometry;\n      var positionAttribute = geometry.attributes.position;\n      var normalAttribute = geometry.attributes.normal;\n      if (geometry.index !== null) {\n        var index = geometry.index;\n        for (i = 0; i < index.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i));\n          normal.fromBufferAttribute(normalAttribute, index.getX(i));\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } else {\n        for (i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n          normal.fromBufferAttribute(normalAttribute, i);\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      }\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1));\n      for (i = 0; i < decalVertices.length; i++) {\n        var decalVertex = decalVertices[i];\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y);\n        decalVertex.position.applyMatrix4(projectorMatrix);\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\n      }\n    }\n    function pushDecalVertex(decalVertices, vertex, normal) {\n      vertex.applyMatrix4(mesh.matrixWorld);\n      vertex.applyMatrix4(projectorMatrixInverse);\n      normal.transformDirection(mesh.matrixWorld);\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\n    }\n    function clipGeometry(inVertices, plane2) {\n      var outVertices = [];\n      var s = 0.5 * Math.abs(size.dot(plane2));\n      for (var i = 0; i < inVertices.length; i += 3) {\n        var v1Out = void 0,\n          v2Out = void 0,\n          v3Out = void 0,\n          total = 0;\n        var nV1 = void 0,\n          nV2 = void 0,\n          nV3 = void 0,\n          nV4 = void 0;\n        var d1 = inVertices[i + 0].position.dot(plane2) - s;\n        var d2 = inVertices[i + 1].position.dot(plane2) - s;\n        var d3 = inVertices[i + 2].position.dot(plane2) - s;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0;\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n        switch (total) {\n          case 0:\n            {\n              outVertices.push(inVertices[i]);\n              outVertices.push(inVertices[i + 1]);\n              outVertices.push(inVertices[i + 2]);\n              break;\n            }\n          case 1:\n            {\n              if (v1Out) {\n                nV1 = inVertices[i + 1];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i], nV1, plane2, s);\n                nV4 = clip(inVertices[i], nV2, plane2, s);\n              }\n              if (v2Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i + 1], nV1, plane2, s);\n                nV4 = clip(inVertices[i + 1], nV2, plane2, s);\n                outVertices.push(nV3);\n                outVertices.push(nV2.clone());\n                outVertices.push(nV1.clone());\n                outVertices.push(nV2.clone());\n                outVertices.push(nV3.clone());\n                outVertices.push(nV4);\n                break;\n              }\n              if (v3Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 1];\n                nV3 = clip(inVertices[i + 2], nV1, plane2, s);\n                nV4 = clip(inVertices[i + 2], nV2, plane2, s);\n              }\n              outVertices.push(nV1.clone());\n              outVertices.push(nV2.clone());\n              outVertices.push(nV3);\n              outVertices.push(nV4);\n              outVertices.push(nV3.clone());\n              outVertices.push(nV2.clone());\n              break;\n            }\n          case 2:\n            {\n              if (!v1Out) {\n                nV1 = inVertices[i].clone();\n                nV2 = clip(nV1, inVertices[i + 1], plane2, s);\n                nV3 = clip(nV1, inVertices[i + 2], plane2, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n              if (!v2Out) {\n                nV1 = inVertices[i + 1].clone();\n                nV2 = clip(nV1, inVertices[i + 2], plane2, s);\n                nV3 = clip(nV1, inVertices[i], plane2, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n              if (!v3Out) {\n                nV1 = inVertices[i + 2].clone();\n                nV2 = clip(nV1, inVertices[i], plane2, s);\n                nV3 = clip(nV1, inVertices[i + 1], plane2, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n              break;\n            }\n        }\n      }\n      return outVertices;\n    }\n    function clip(v0, v1, p, s) {\n      var d0 = v0.position.dot(p) - s;\n      var d1 = v1.position.dot(p) - s;\n      var s0 = d0 / (d0 - d1);\n      var v = new DecalVertex(new Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z)));\n      return v;\n    }\n    return _this;\n  }\n  return _createClass(DecalGeometry);\n}(BufferGeometry);\nvar DecalVertex = /*#__PURE__*/function () {\n  function DecalVertex(position, normal) {\n    _classCallCheck(this, DecalVertex);\n    this.position = position;\n    this.normal = normal;\n  }\n  _createClass(DecalVertex, [{\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.position.clone(), this.normal.clone());\n    }\n  }]);\n  return DecalVertex;\n}();\nexport { DecalGeometry, DecalVertex };\n//# sourceMappingURL=DecalGeometry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}