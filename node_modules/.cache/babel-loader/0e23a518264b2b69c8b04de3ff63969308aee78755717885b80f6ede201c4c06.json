{"ast":null,"code":"import _objectSpread from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _get from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport * as THREE from \"three\";\nfunction memcpy(src, srcOffset, dst, dstOffset, length) {\n  var i;\n  src = src.subarray || src.slice ? src : src.buffer;\n  dst = dst.subarray || dst.slice ? dst : dst.buffer;\n  src = srcOffset ? src.subarray ? src.subarray(srcOffset, length && srcOffset + length) : src.slice(srcOffset, length && srcOffset + length) : src;\n  if (dst.set) {\n    dst.set(src, dstOffset);\n  } else {\n    for (i = 0; i < src.length; i++) dst[i + dstOffset] = src[i];\n  }\n  return dst;\n}\nfunction convertPoints(points) {\n  if (points instanceof Float32Array) return points;\n  if (points instanceof THREE.BufferGeometry) return points.getAttribute(\"position\").array;\n  return points.map(function (p) {\n    var isArray = Array.isArray(p);\n    return p instanceof THREE.Vector3 ? [p.x, p.y, p.z] : p instanceof THREE.Vector2 ? [p.x, p.y, 0] : isArray && p.length === 3 ? [p[0], p[1], p[2]] : isArray && p.length === 2 ? [p[0], p[1], 0] : p;\n  }).flat();\n}\nvar MeshLineGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(MeshLineGeometry, _THREE$BufferGeometry);\n  var _super = _createSuper(MeshLineGeometry);\n  function MeshLineGeometry() {\n    var _this;\n    _classCallCheck(this, MeshLineGeometry);\n    _this = _super.call(this);\n    __publicField(_assertThisInitialized(_this), \"type\", \"MeshLine\");\n    __publicField(_assertThisInitialized(_this), \"isMeshLine\", true);\n    __publicField(_assertThisInitialized(_this), \"positions\", []);\n    __publicField(_assertThisInitialized(_this), \"previous\", []);\n    __publicField(_assertThisInitialized(_this), \"next\", []);\n    __publicField(_assertThisInitialized(_this), \"side\", []);\n    __publicField(_assertThisInitialized(_this), \"width\", []);\n    __publicField(_assertThisInitialized(_this), \"indices_array\", []);\n    __publicField(_assertThisInitialized(_this), \"uvs\", []);\n    __publicField(_assertThisInitialized(_this), \"counters\", []);\n    __publicField(_assertThisInitialized(_this), \"widthCallback\", null);\n    __publicField(_assertThisInitialized(_this), \"_attributes\");\n    __publicField(_assertThisInitialized(_this), \"_points\", []);\n    __publicField(_assertThisInitialized(_this), \"points\");\n    __publicField(_assertThisInitialized(_this), \"matrixWorld\", new THREE.Matrix4());\n    Object.defineProperties(_assertThisInitialized(_this), {\n      points: {\n        enumerable: true,\n        get: function get() {\n          return this._points;\n        },\n        set: function set(value) {\n          this.setPoints(value, this.widthCallback);\n        }\n      }\n    });\n    return _this;\n  }\n  _createClass(MeshLineGeometry, [{\n    key: \"setMatrixWorld\",\n    value: function setMatrixWorld(matrixWorld) {\n      this.matrixWorld = matrixWorld;\n    }\n  }, {\n    key: \"setPoints\",\n    value: function setPoints(points, wcb) {\n      points = convertPoints(points);\n      this._points = points;\n      this.widthCallback = wcb != null ? wcb : null;\n      this.positions = [];\n      this.counters = [];\n      if (points.length && points[0] instanceof THREE.Vector3) {\n        for (var j = 0; j < points.length; j++) {\n          var p = points[j];\n          var c = j / (points.length - 1);\n          this.positions.push(p.x, p.y, p.z);\n          this.positions.push(p.x, p.y, p.z);\n          this.counters.push(c);\n          this.counters.push(c);\n        }\n      } else {\n        for (var _j = 0; _j < points.length; _j += 3) {\n          var _c = _j / (points.length - 1);\n          this.positions.push(points[_j], points[_j + 1], points[_j + 2]);\n          this.positions.push(points[_j], points[_j + 1], points[_j + 2]);\n          this.counters.push(_c);\n          this.counters.push(_c);\n        }\n      }\n      this.process();\n    }\n  }, {\n    key: \"compareV3\",\n    value: function compareV3(a, b) {\n      var aa = a * 6;\n      var ab = b * 6;\n      return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];\n    }\n  }, {\n    key: \"copyV3\",\n    value: function copyV3(a) {\n      var aa = a * 6;\n      return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];\n    }\n  }, {\n    key: \"process\",\n    value: function process() {\n      var l = this.positions.length / 6;\n      this.previous = [];\n      this.next = [];\n      this.side = [];\n      this.width = [];\n      this.indices_array = [];\n      this.uvs = [];\n      var w;\n      var v;\n      if (this.compareV3(0, l - 1)) {\n        v = this.copyV3(l - 2);\n      } else {\n        v = this.copyV3(0);\n      }\n      this.previous.push(v[0], v[1], v[2]);\n      this.previous.push(v[0], v[1], v[2]);\n      for (var j = 0; j < l; j++) {\n        this.side.push(1);\n        this.side.push(-1);\n        if (this.widthCallback) w = this.widthCallback(j / (l - 1));else w = 1;\n        this.width.push(w);\n        this.width.push(w);\n        this.uvs.push(j / (l - 1), 0);\n        this.uvs.push(j / (l - 1), 1);\n        if (j < l - 1) {\n          v = this.copyV3(j);\n          this.previous.push(v[0], v[1], v[2]);\n          this.previous.push(v[0], v[1], v[2]);\n          var n = j * 2;\n          this.indices_array.push(n, n + 1, n + 2);\n          this.indices_array.push(n + 2, n + 1, n + 3);\n        }\n        if (j > 0) {\n          v = this.copyV3(j);\n          this.next.push(v[0], v[1], v[2]);\n          this.next.push(v[0], v[1], v[2]);\n        }\n      }\n      if (this.compareV3(l - 1, 0)) {\n        v = this.copyV3(1);\n      } else {\n        v = this.copyV3(l - 1);\n      }\n      this.next.push(v[0], v[1], v[2]);\n      this.next.push(v[0], v[1], v[2]);\n      if (!this._attributes || this._attributes.position.count !== this.positions.length) {\n        this._attributes = {\n          position: new THREE.BufferAttribute(new Float32Array(this.positions), 3),\n          previous: new THREE.BufferAttribute(new Float32Array(this.previous), 3),\n          next: new THREE.BufferAttribute(new Float32Array(this.next), 3),\n          side: new THREE.BufferAttribute(new Float32Array(this.side), 1),\n          width: new THREE.BufferAttribute(new Float32Array(this.width), 1),\n          uv: new THREE.BufferAttribute(new Float32Array(this.uvs), 2),\n          index: new THREE.BufferAttribute(new Uint16Array(this.indices_array), 1),\n          counters: new THREE.BufferAttribute(new Float32Array(this.counters), 1)\n        };\n      } else {\n        this._attributes.position.copyArray(new Float32Array(this.positions));\n        this._attributes.position.needsUpdate = true;\n        this._attributes.previous.copyArray(new Float32Array(this.previous));\n        this._attributes.previous.needsUpdate = true;\n        this._attributes.next.copyArray(new Float32Array(this.next));\n        this._attributes.next.needsUpdate = true;\n        this._attributes.side.copyArray(new Float32Array(this.side));\n        this._attributes.side.needsUpdate = true;\n        this._attributes.width.copyArray(new Float32Array(this.width));\n        this._attributes.width.needsUpdate = true;\n        this._attributes.uv.copyArray(new Float32Array(this.uvs));\n        this._attributes.uv.needsUpdate = true;\n        this._attributes.index.copyArray(new Uint16Array(this.indices_array));\n        this._attributes.index.needsUpdate = true;\n      }\n      this.setAttribute(\"position\", this._attributes.position);\n      this.setAttribute(\"previous\", this._attributes.previous);\n      this.setAttribute(\"next\", this._attributes.next);\n      this.setAttribute(\"side\", this._attributes.side);\n      this.setAttribute(\"width\", this._attributes.width);\n      this.setAttribute(\"uv\", this._attributes.uv);\n      this.setAttribute(\"counters\", this._attributes.counters);\n      this.setAttribute(\"position\", this._attributes.position);\n      this.setAttribute(\"previous\", this._attributes.previous);\n      this.setAttribute(\"next\", this._attributes.next);\n      this.setAttribute(\"side\", this._attributes.side);\n      this.setAttribute(\"width\", this._attributes.width);\n      this.setAttribute(\"uv\", this._attributes.uv);\n      this.setAttribute(\"counters\", this._attributes.counters);\n      this.setIndex(this._attributes.index);\n      this.computeBoundingSphere();\n      this.computeBoundingBox();\n    }\n  }, {\n    key: \"advance\",\n    value: function advance(_ref) {\n      var x = _ref.x,\n        y = _ref.y,\n        z = _ref.z;\n      var positions = this._attributes.position.array;\n      var previous = this._attributes.previous.array;\n      var next = this._attributes.next.array;\n      var l = positions.length;\n      memcpy(positions, 0, previous, 0, l);\n      memcpy(positions, 6, positions, 0, l - 6);\n      positions[l - 6] = x;\n      positions[l - 5] = y;\n      positions[l - 4] = z;\n      positions[l - 3] = x;\n      positions[l - 2] = y;\n      positions[l - 1] = z;\n      memcpy(positions, 6, next, 0, l - 6);\n      next[l - 6] = x;\n      next[l - 5] = y;\n      next[l - 4] = z;\n      next[l - 3] = x;\n      next[l - 2] = y;\n      next[l - 1] = z;\n      this._attributes.position.needsUpdate = true;\n      this._attributes.previous.needsUpdate = true;\n      this._attributes.next.needsUpdate = true;\n    }\n  }]);\n  return MeshLineGeometry;\n}(THREE.BufferGeometry);\nvar vertexShader = \"\\n  #include <common>\\n  #include <logdepthbuf_pars_vertex>\\n  #include <fog_pars_vertex>\\n\\n  attribute vec3 previous;\\n  attribute vec3 next;\\n  attribute float side;\\n  attribute float width;\\n  attribute float counters;\\n  \\n  uniform vec2 resolution;\\n  uniform float lineWidth;\\n  uniform vec3 color;\\n  uniform float opacity;\\n  uniform float sizeAttenuation;\\n  \\n  varying vec2 vUV;\\n  varying vec4 vColor;\\n  varying float vCounters;\\n  \\n  vec2 fix(vec4 i, float aspect) {\\n    vec2 res = i.xy / i.w;\\n    res.x *= aspect;\\n  \\tvCounters = counters;\\n    return res;\\n  }\\n  \\n  void main() {\\n    float aspect = resolution.x / resolution.y;\\n    vColor = vec4(color, opacity);\\n    vUV = uv;\\n  \\n    mat4 m = projectionMatrix * modelViewMatrix;\\n    vec4 finalPosition = m * vec4(position, 1.0);\\n    vec4 prevPos = m * vec4(previous, 1.0);\\n    vec4 nextPos = m * vec4(next, 1.0);\\n  \\n    vec2 currentP = fix(finalPosition, aspect);\\n    vec2 prevP = fix(prevPos, aspect);\\n    vec2 nextP = fix(nextPos, aspect);\\n  \\n    float w = lineWidth * width;\\n  \\n    vec2 dir;\\n    if (nextP == currentP) dir = normalize(currentP - prevP);\\n    else if (prevP == currentP) dir = normalize(nextP - currentP);\\n    else {\\n      vec2 dir1 = normalize(currentP - prevP);\\n      vec2 dir2 = normalize(nextP - currentP);\\n      dir = normalize(dir1 + dir2);\\n  \\n      vec2 perp = vec2(-dir1.y, dir1.x);\\n      vec2 miter = vec2(-dir.y, dir.x);\\n      //w = clamp(w / dot(miter, perp), 0., 4. * lineWidth * width);\\n    }\\n  \\n    //vec2 normal = (cross(vec3(dir, 0.), vec3(0., 0., 1.))).xy;\\n    vec4 normal = vec4(-dir.y, dir.x, 0., 1.);\\n    normal.xy *= .5 * w;\\n    //normal *= projectionMatrix;\\n    if (sizeAttenuation == 0.) {\\n      normal.xy *= finalPosition.w;\\n      normal.xy /= (vec4(resolution, 0., 1.) * projectionMatrix).xy;\\n    }\\n  \\n    finalPosition.xy += normal.xy * side;\\n    gl_Position = finalPosition;\\n    #include <logdepthbuf_vertex>\\n    #include <fog_vertex>\\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n    #include <fog_vertex>\\n  }\\n\";\nvar fragmentShader = \"\\n  #include <fog_pars_fragment>\\n  #include <logdepthbuf_pars_fragment>\\n  \\n  uniform sampler2D map;\\n  uniform sampler2D alphaMap;\\n  uniform float useMap;\\n  uniform float useAlphaMap;\\n  uniform float useDash;\\n  uniform float dashArray;\\n  uniform float dashOffset;\\n  uniform float dashRatio;\\n  uniform float visibility;\\n  uniform float alphaTest;\\n  uniform vec2 repeat;\\n  \\n  varying vec2 vUV;\\n  varying vec4 vColor;\\n  varying float vCounters;\\n  \\n  void main() {\\n    #include <logdepthbuf_fragment>\\n    vec4 c = vColor;\\n    if (useMap == 1.) c *= texture2D(map, vUV * repeat);\\n    if (useAlphaMap == 1.) c.a *= texture2D(alphaMap, vUV * repeat).a;\\n    if (c.a < alphaTest) discard;\\n    if (useDash == 1.) {\\n      c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\\n    }\\n    gl_FragColor = c;\\n    gl_FragColor.a *= step(vCounters, visibility);\\n    #include <fog_fragment>\\n    #include <tonemapping_fragment>\\n    #include <encodings_fragment>\\n  }\\n\";\nvar MeshLineMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial) {\n  _inherits(MeshLineMaterial, _THREE$ShaderMaterial);\n  var _super2 = _createSuper(MeshLineMaterial);\n  function MeshLineMaterial(parameters) {\n    var _this2;\n    _classCallCheck(this, MeshLineMaterial);\n    _this2 = _super2.call(this, {\n      uniforms: _objectSpread(_objectSpread({}, THREE.UniformsLib.fog), {}, {\n        lineWidth: {\n          value: 1\n        },\n        map: {\n          value: null\n        },\n        useMap: {\n          value: 0\n        },\n        alphaMap: {\n          value: null\n        },\n        useAlphaMap: {\n          value: 0\n        },\n        color: {\n          value: new THREE.Color(16777215)\n        },\n        opacity: {\n          value: 1\n        },\n        resolution: {\n          value: new THREE.Vector2(1, 1)\n        },\n        sizeAttenuation: {\n          value: 1\n        },\n        dashArray: {\n          value: 0\n        },\n        dashOffset: {\n          value: 0\n        },\n        dashRatio: {\n          value: 0.5\n        },\n        useDash: {\n          value: 0\n        },\n        visibility: {\n          value: 1\n        },\n        alphaTest: {\n          value: 0\n        },\n        repeat: {\n          value: new THREE.Vector2(1, 1)\n        }\n      }),\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    });\n    __publicField(_assertThisInitialized(_this2), \"lineWidth\");\n    __publicField(_assertThisInitialized(_this2), \"map\");\n    __publicField(_assertThisInitialized(_this2), \"useMap\");\n    __publicField(_assertThisInitialized(_this2), \"alphaMap\");\n    __publicField(_assertThisInitialized(_this2), \"useAlphaMap\");\n    __publicField(_assertThisInitialized(_this2), \"color\");\n    __publicField(_assertThisInitialized(_this2), \"resolution\");\n    __publicField(_assertThisInitialized(_this2), \"sizeAttenuation\");\n    __publicField(_assertThisInitialized(_this2), \"dashArray\");\n    __publicField(_assertThisInitialized(_this2), \"dashOffset\");\n    __publicField(_assertThisInitialized(_this2), \"dashRatio\");\n    __publicField(_assertThisInitialized(_this2), \"useDash\");\n    __publicField(_assertThisInitialized(_this2), \"visibility\");\n    __publicField(_assertThisInitialized(_this2), \"repeat\");\n    _this2.type = \"MeshLineMaterial\";\n    Object.defineProperties(_assertThisInitialized(_this2), {\n      lineWidth: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.lineWidth.value;\n        },\n        set: function set(value) {\n          this.uniforms.lineWidth.value = value;\n        }\n      },\n      map: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.map.value;\n        },\n        set: function set(value) {\n          this.uniforms.map.value = value;\n        }\n      },\n      useMap: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useMap.value;\n        },\n        set: function set(value) {\n          this.uniforms.useMap.value = value;\n        }\n      },\n      alphaMap: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.alphaMap.value;\n        },\n        set: function set(value) {\n          this.uniforms.alphaMap.value = value;\n        }\n      },\n      useAlphaMap: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useAlphaMap.value;\n        },\n        set: function set(value) {\n          this.uniforms.useAlphaMap.value = value;\n        }\n      },\n      color: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.color.value;\n        },\n        set: function set(value) {\n          this.uniforms.color.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.resolution.value;\n        },\n        set: function set(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      sizeAttenuation: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.sizeAttenuation.value;\n        },\n        set: function set(value) {\n          this.uniforms.sizeAttenuation.value = value;\n        }\n      },\n      dashArray: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashArray.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashArray.value = value;\n          this.useDash = value !== 0 ? 1 : 0;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      dashRatio: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashRatio.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashRatio.value = value;\n        }\n      },\n      useDash: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useDash.value;\n        },\n        set: function set(value) {\n          this.uniforms.useDash.value = value;\n        }\n      },\n      visibility: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.visibility.value;\n        },\n        set: function set(value) {\n          this.uniforms.visibility.value = value;\n        }\n      },\n      alphaTest: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.alphaTest.value;\n        },\n        set: function set(value) {\n          this.uniforms.alphaTest.value = value;\n        }\n      },\n      repeat: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.repeat.value;\n        },\n        set: function set(value) {\n          this.uniforms.repeat.value.copy(value);\n        }\n      }\n    });\n    _this2.setValues(parameters);\n    return _this2;\n  }\n  _createClass(MeshLineMaterial, [{\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(MeshLineMaterial.prototype), \"copy\", this).call(this, source);\n      this.lineWidth = source.lineWidth;\n      this.map = source.map;\n      this.useMap = source.useMap;\n      this.alphaMap = source.alphaMap;\n      this.useAlphaMap = source.useAlphaMap;\n      this.color.copy(source.color);\n      this.opacity = source.opacity;\n      this.resolution.copy(source.resolution);\n      this.sizeAttenuation = source.sizeAttenuation;\n      this.dashArray = source.dashArray;\n      this.dashOffset = source.dashOffset;\n      this.dashRatio = source.dashRatio;\n      this.useDash = source.useDash;\n      this.visibility = source.visibility;\n      this.alphaTest = source.alphaTest;\n      this.repeat.copy(source.repeat);\n      return this;\n    }\n  }]);\n  return MeshLineMaterial;\n}(THREE.ShaderMaterial);\nfunction raycast(raycaster, intersects) {\n  var inverseMatrix = new THREE.Matrix4();\n  var ray = new THREE.Ray();\n  var sphere = new THREE.Sphere();\n  var interRay = new THREE.Vector3();\n  var geometry = this.geometry;\n  sphere.copy(geometry.boundingSphere);\n  sphere.applyMatrix4(this.matrixWorld);\n  if (!raycaster.ray.intersectSphere(sphere, interRay)) return;\n  inverseMatrix.copy(this.matrixWorld).invert();\n  ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n  var vStart = new THREE.Vector3();\n  var vEnd = new THREE.Vector3();\n  var interSegment = new THREE.Vector3();\n  var step = this instanceof THREE.LineSegments ? 2 : 1;\n  var index = geometry.index;\n  var attributes = geometry.attributes;\n  if (index !== null) {\n    var indices = index.array;\n    var positions = attributes.position.array;\n    var widths = attributes.width.array;\n    for (var i = 0, l = indices.length - 1; i < l; i += step) {\n      var a = indices[i];\n      var b = indices[i + 1];\n      vStart.fromArray(positions, a * 3);\n      vEnd.fromArray(positions, b * 3);\n      var width = widths[Math.floor(i / 3)] != void 0 ? widths[Math.floor(i / 3)] : 1;\n      var precision = raycaster.params.Line.threshold + this.material.lineWidth * width / 2;\n      var precisionSq = precision * precision;\n      var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n      if (distSq > precisionSq) continue;\n      interRay.applyMatrix4(this.matrixWorld);\n      var distance = raycaster.ray.origin.distanceTo(interRay);\n      if (distance < raycaster.near || distance > raycaster.far) continue;\n      intersects.push({\n        distance: distance,\n        point: interSegment.clone().applyMatrix4(this.matrixWorld),\n        index: i,\n        face: null,\n        faceIndex: void 0,\n        object: this\n      });\n      i = l;\n    }\n  }\n}\nexport { MeshLineGeometry, MeshLineMaterial, raycast };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}