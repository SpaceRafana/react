{"ast":null,"code":"import { EventDispatcher } from 'three';\nimport { NodeUpdateType } from './constants.js';\nimport { getNodeChildren, getCacheKey } from './NodeUtils.js';\nimport { MathUtils } from 'three';\nconst NodeClasses = new Map();\nlet _nodeId = 0;\nclass Node extends EventDispatcher {\n  constructor(nodeType = null) {\n    super();\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.NONE;\n    this.updateBeforeType = NodeUpdateType.NONE;\n    this.uuid = MathUtils.generateUUID();\n    this.isNode = true;\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n  get type() {\n    return this.constructor.type;\n  }\n  getSelf() {\n    // Returns non-node object.\n\n    return this.self || this;\n  }\n  updateReference() {\n    return this;\n  }\n  isGlobal( /*builder*/\n  ) {\n    return false;\n  }\n  *getChildren() {\n    const self = this;\n    for (const {\n      property,\n      index,\n      childNode\n    } of getNodeChildren(this)) {\n      yield {\n        childNode,\n        replaceNode(node) {\n          if (index === undefined) self[property] = node;else self[property][index] = node;\n        }\n      };\n    }\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n  traverse(callback, replaceNode = null) {\n    callback(this, replaceNode);\n    for (const {\n      childNode,\n      replaceNode\n    } of this.getChildren()) {\n      childNode.traverse(callback, replaceNode);\n    }\n  }\n  getCacheKey() {\n    return getCacheKey(this);\n  }\n  getHash( /*builder*/\n  ) {\n    return this.uuid;\n  }\n  getUpdateType() {\n    return this.updateType;\n  }\n  getUpdateBeforeType() {\n    return this.updateBeforeType;\n  }\n  getNodeType(builder) {\n    const nodeProperties = builder.getNodeProperties(this);\n    if (nodeProperties.outputNode) {\n      return nodeProperties.outputNode.getNodeType(builder);\n    }\n    return this.nodeType;\n  }\n  getShared(builder) {\n    const hash = this.getHash(builder);\n    const nodeFromHash = builder.getNodeFromHash(hash);\n    return nodeFromHash || this;\n  }\n  setup(builder) {\n    const nodeProperties = builder.getNodeProperties(this);\n    for (const {\n      childNode\n    } of this.getChildren()) {\n      nodeProperties['_node' + childNode.id] = childNode;\n    }\n\n    // return a outputNode if exists\n    return null;\n  }\n  construct(builder) {\n    // @deprecated, r157\n\n    console.warn('THREE.Node: construct() is deprecated. Use setup() instead.');\n    return this.setup(builder);\n  }\n  analyze(builder) {\n    const nodeData = builder.getDataFromNode(this);\n    nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n    if (nodeData.dependenciesCount === 1) {\n      // node flow children\n\n      const nodeProperties = builder.getNodeProperties(this);\n      for (const childNode of Object.values(nodeProperties)) {\n        if (childNode && childNode.isNode === true) {\n          childNode.build(builder);\n        }\n      }\n    }\n  }\n  generate(builder, output) {\n    const {\n      outputNode\n    } = builder.getNodeProperties(this);\n    if (outputNode && outputNode.isNode === true) {\n      return outputNode.build(builder, output);\n    }\n  }\n  updateBefore( /*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  update( /*frame*/\n  ) {\n    console.warn('Abstract function.');\n  }\n  build(builder, output = null) {\n    const refNode = this.getShared(builder);\n    if (this !== refNode) {\n      return refNode.build(builder, output);\n    }\n    builder.addNode(this);\n    builder.addChain(this);\n\n    /* Build stages expected results:\n    \t- \"setup\"\t\t-> Node\n    \t- \"analyze\"\t\t-> null\n    \t- \"generate\"\t-> String\n    */\n    let result = null;\n    const buildStage = builder.getBuildStage();\n    if (buildStage === 'setup') {\n      const properties = builder.getNodeProperties(this);\n      if (properties.initialized !== true || builder.context.tempRead === false) {\n        const stackNodesBeforeSetup = builder.stack.nodes.length;\n        properties.initialized = true;\n        properties.outputNode = this.setup(builder);\n        if (properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup) {\n          properties.outputNode = builder.stack;\n        }\n        for (const childNode of Object.values(properties)) {\n          if (childNode && childNode.isNode === true) {\n            childNode.build(builder);\n          }\n        }\n      }\n    } else if (buildStage === 'analyze') {\n      this.analyze(builder);\n    } else if (buildStage === 'generate') {\n      const isGenerateOnce = this.generate.length === 1;\n      if (isGenerateOnce) {\n        const type = this.getNodeType(builder);\n        const nodeData = builder.getDataFromNode(this);\n        result = nodeData.snippet;\n        if (result === undefined /*|| builder.context.tempRead === false*/) {\n          result = this.generate(builder) || '';\n          nodeData.snippet = result;\n        }\n        result = builder.format(result, type, output);\n      } else {\n        result = this.generate(builder, output) || '';\n      }\n    }\n    builder.removeChain(this);\n    return result;\n  }\n  getSerializeChildren() {\n    return getNodeChildren(this);\n  }\n  serialize(json) {\n    const nodeChildren = this.getSerializeChildren();\n    const inputNodes = {};\n    for (const {\n      property,\n      index,\n      childNode\n    } of nodeChildren) {\n      if (index !== undefined) {\n        if (inputNodes[property] === undefined) {\n          inputNodes[property] = Number.isInteger(index) ? [] : {};\n        }\n        inputNodes[property][index] = childNode.toJSON(json.meta).uuid;\n      } else {\n        inputNodes[property] = childNode.toJSON(json.meta).uuid;\n      }\n    }\n    if (Object.keys(inputNodes).length > 0) {\n      json.inputNodes = inputNodes;\n    }\n  }\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n      for (const property in json.inputNodes) {\n        if (Array.isArray(json.inputNodes[property])) {\n          const inputArray = [];\n          for (const uuid of json.inputNodes[property]) {\n            inputArray.push(nodes[uuid]);\n          }\n          this[property] = inputArray;\n        } else if (typeof json.inputNodes[property] === 'object') {\n          const inputObject = {};\n          for (const subProperty in json.inputNodes[property]) {\n            const uuid = json.inputNodes[property][subProperty];\n            inputObject[subProperty] = nodes[uuid];\n          }\n          this[property] = inputObject;\n        } else {\n          const uuid = json.inputNodes[property];\n          this[property] = nodes[uuid];\n        }\n      }\n    }\n  }\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n\n    // serialize\n\n    let data = meta.nodes[uuid];\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.6,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      if (isRoot !== true) meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n}\nexport default Node;\nexport function addNodeClass(type, nodeClass) {\n  if (typeof nodeClass !== 'function' || !type) throw new Error(`Node class ${type} is not a class`);\n  if (NodeClasses.has(type)) throw new Error(`Redefinition of node class ${type}`);\n  NodeClasses.set(type, nodeClass);\n  nodeClass.type = type;\n}\nexport function createNodeFromType(type) {\n  const Class = NodeClasses.get(type);\n  if (Class !== undefined) {\n    return new Class();\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}