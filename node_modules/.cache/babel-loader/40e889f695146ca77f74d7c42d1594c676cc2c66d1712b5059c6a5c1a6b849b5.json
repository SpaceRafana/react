{"ast":null,"code":"import _regeneratorRuntime from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { forwardRef, useRef, useState, useCallback, useMemo, useImperativeHandle, useEffect, Suspense, useContext, createContext } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { easing } from 'maath';\nimport { suspend, clear } from 'suspend-react';\nimport { useVideoTexture } from './useVideoTexture.js';\nimport { Facemesh } from './Facemesh.js';\nimport { useFaceLandmarker } from './FaceLandmarker.js';\n\n// useVideoTexture 1st arg `src` type\n\nfunction mean(v1, v2) {\n  return v1.clone().add(v2).multiplyScalar(0.5);\n}\nfunction localToLocal(objSrc, v, objDst) {\n  // see: https://discourse.threejs.org/t/object3d-localtolocal/51564\n  var v_world = objSrc.localToWorld(v);\n  return objDst.worldToLocal(v_world);\n}\n\n//\n//\n//\nvar FaceControlsContext = /* @__PURE__ */createContext({});\nvar FaceControls = /* @__PURE__ */forwardRef(function (_ref, fref) {\n  var camera = _ref.camera,\n    _ref$autostart = _ref.autostart,\n    autostart = _ref$autostart === void 0 ? true : _ref$autostart,\n    _ref$webcam = _ref.webcam,\n    webcam = _ref$webcam === void 0 ? true : _ref$webcam,\n    webcamVideoTextureSrc = _ref.webcamVideoTextureSrc,\n    _ref$manualUpdate = _ref.manualUpdate,\n    manualUpdate = _ref$manualUpdate === void 0 ? false : _ref$manualUpdate,\n    _ref$manualDetect = _ref.manualDetect,\n    manualDetect = _ref$manualDetect === void 0 ? false : _ref$manualDetect,\n    onVideoFrame = _ref.onVideoFrame,\n    _ref$smoothTime = _ref.smoothTime,\n    smoothTime = _ref$smoothTime === void 0 ? 0.25 : _ref$smoothTime,\n    _ref$offset = _ref.offset,\n    offset = _ref$offset === void 0 ? true : _ref$offset,\n    _ref$offsetScalar = _ref.offsetScalar,\n    offsetScalar = _ref$offsetScalar === void 0 ? 80 : _ref$offsetScalar,\n    _ref$eyes = _ref.eyes,\n    eyes = _ref$eyes === void 0 ? false : _ref$eyes,\n    _ref$eyesAsOrigin = _ref.eyesAsOrigin,\n    eyesAsOrigin = _ref$eyesAsOrigin === void 0 ? true : _ref$eyesAsOrigin,\n    _ref$depth = _ref.depth,\n    depth = _ref$depth === void 0 ? 0.15 : _ref$depth,\n    _ref$debug = _ref.debug,\n    debug = _ref$debug === void 0 ? false : _ref$debug,\n    facemesh = _ref.facemesh,\n    makeDefault = _ref.makeDefault;\n  var _faces$facialTransfor, _faces$faceBlendshape;\n  var scene = useThree(function (state) {\n    return state.scene;\n  });\n  var defaultCamera = useThree(function (state) {\n    return state.camera;\n  });\n  var set = useThree(function (state) {\n    return state.set;\n  });\n  var get = useThree(function (state) {\n    return state.get;\n  });\n  var explCamera = camera || defaultCamera;\n  var webcamApiRef = useRef(null);\n  var facemeshApiRef = useRef(null);\n\n  //\n  // computeTarget()\n  //\n  // Compute `target` position and rotation for the camera (according to <Facemesh>)\n  //\n  //  1. ðŸ‘€ either following the 2 eyes\n  //  2. ðŸ‘¤ or just the head mesh\n  //\n\n  var _useState = useState(function () {\n      return new THREE.Object3D();\n    }),\n    _useState2 = _slicedToArray(_useState, 1),\n    target = _useState2[0];\n  var _useState3 = useState(function () {\n      return new THREE.Vector3();\n    }),\n    _useState4 = _slicedToArray(_useState3, 1),\n    irisRightDirPos = _useState4[0];\n  var _useState5 = useState(function () {\n      return new THREE.Vector3();\n    }),\n    _useState6 = _slicedToArray(_useState5, 1),\n    irisLeftDirPos = _useState6[0];\n  var _useState7 = useState(function () {\n      return new THREE.Vector3();\n    }),\n    _useState8 = _slicedToArray(_useState7, 1),\n    irisRightLookAt = _useState8[0];\n  var _useState9 = useState(function () {\n      return new THREE.Vector3();\n    }),\n    _useState10 = _slicedToArray(_useState9, 1),\n    irisLeftLookAt = _useState10[0];\n  var computeTarget = useCallback(function () {\n    // same parent as the camera\n    target.parent = explCamera.parent;\n    var facemeshApi = facemeshApiRef.current;\n    if (facemeshApi) {\n      var outerRef = facemeshApi.outerRef,\n        eyeRightRef = facemeshApi.eyeRightRef,\n        eyeLeftRef = facemeshApi.eyeLeftRef;\n      if (eyeRightRef.current && eyeLeftRef.current) {\n        // 1. ðŸ‘€\n\n        var irisRightDirRef = eyeRightRef.current.irisDirRef;\n        var irisLeftDirRef = eyeLeftRef.current.irisDirRef;\n        if (irisRightDirRef.current && irisLeftDirRef.current && outerRef.current) {\n          //\n          // position: mean of irisRightDirPos,irisLeftDirPos\n          //\n          irisRightDirPos.copy(localToLocal(irisRightDirRef.current, new THREE.Vector3(0, 0, 0), outerRef.current));\n          irisLeftDirPos.copy(localToLocal(irisLeftDirRef.current, new THREE.Vector3(0, 0, 0), outerRef.current));\n          target.position.copy(localToLocal(outerRef.current, mean(irisRightDirPos, irisLeftDirPos), explCamera.parent || scene));\n\n          //\n          // lookAt: mean of irisRightLookAt,irisLeftLookAt\n          //\n          irisRightLookAt.copy(localToLocal(irisRightDirRef.current, new THREE.Vector3(0, 0, 1), outerRef.current));\n          irisLeftLookAt.copy(localToLocal(irisLeftDirRef.current, new THREE.Vector3(0, 0, 1), outerRef.current));\n          target.lookAt(outerRef.current.localToWorld(mean(irisRightLookAt, irisLeftLookAt)));\n        }\n      } else {\n        // 2. ðŸ‘¤\n\n        if (outerRef.current) {\n          target.position.copy(localToLocal(outerRef.current, new THREE.Vector3(0, 0, 0), explCamera.parent || scene));\n          target.lookAt(outerRef.current.localToWorld(new THREE.Vector3(0, 0, 1)));\n        }\n      }\n    }\n    return target;\n  }, [explCamera, irisLeftDirPos, irisLeftLookAt, irisRightDirPos, irisRightLookAt, scene, target]);\n\n  //\n  // update()\n  //\n  // Updating the camera `current` position and rotation, following `target`\n  //\n\n  var _useState11 = useState(function () {\n      return new THREE.Object3D();\n    }),\n    _useState12 = _slicedToArray(_useState11, 1),\n    current = _useState12[0];\n  var update = useCallback(function (delta, target) {\n    if (explCamera) {\n      var _target;\n      (_target = target) !== null && _target !== void 0 ? _target : target = computeTarget();\n      if (smoothTime > 0) {\n        // damping current\n        var eps = 1e-9;\n        easing.damp3(current.position, target.position, smoothTime, delta, undefined, undefined, eps);\n        easing.dampE(current.rotation, target.rotation, smoothTime, delta, undefined, undefined, eps);\n      } else {\n        // instant\n        current.position.copy(target.position);\n        current.rotation.copy(target.rotation);\n      }\n      explCamera.position.copy(current.position);\n      explCamera.rotation.copy(current.rotation);\n    }\n  }, [explCamera, computeTarget, smoothTime, current.position, current.rotation]);\n\n  //\n  // detect()\n  //\n\n  var _useState13 = useState(),\n    _useState14 = _slicedToArray(_useState13, 2),\n    faces = _useState14[0],\n    setFaces = _useState14[1];\n  var faceLandmarker = useFaceLandmarker();\n  var detect = useCallback(function (video, time) {\n    var faces = faceLandmarker == null ? void 0 : faceLandmarker.detectForVideo(video, time);\n    setFaces(faces);\n  }, [faceLandmarker]);\n  useFrame(function (_, delta) {\n    if (!manualUpdate) {\n      update(delta);\n    }\n  });\n\n  // Ref API\n  var api = useMemo(function () {\n    return Object.assign(Object.create(THREE.EventDispatcher.prototype), {\n      detect: detect,\n      computeTarget: computeTarget,\n      update: update,\n      facemeshApiRef: facemeshApiRef,\n      webcamApiRef: webcamApiRef,\n      // shorthands\n      play: function play() {\n        var _webcamApiRef$current;\n        (_webcamApiRef$current = webcamApiRef.current) == null || (_webcamApiRef$current = _webcamApiRef$current.videoTextureApiRef.current) == null || _webcamApiRef$current.texture.source.data.play();\n      },\n      pause: function pause() {\n        var _webcamApiRef$current2;\n        (_webcamApiRef$current2 = webcamApiRef.current) == null || (_webcamApiRef$current2 = _webcamApiRef$current2.videoTextureApiRef.current) == null || _webcamApiRef$current2.texture.source.data.pause();\n      }\n    });\n  }, [detect, computeTarget, update]);\n  useImperativeHandle(fref, function () {\n    return api;\n  }, [api]);\n\n  //\n  // events callbacks\n  //\n\n  useEffect(function () {\n    var onVideoFrameCb = function onVideoFrameCb(e) {\n      if (!manualDetect) detect(e.texture.source.data, e.time);\n      if (onVideoFrame) onVideoFrame(e);\n    };\n    api.addEventListener('videoFrame', onVideoFrameCb);\n    return function () {\n      api.removeEventListener('videoFrame', onVideoFrameCb);\n    };\n  }, [api, detect, faceLandmarker, manualDetect, onVideoFrame]);\n\n  // `controls` global state\n  useEffect(function () {\n    if (makeDefault) {\n      var old = get().controls;\n      set({\n        controls: api\n      });\n      return function () {\n        return set({\n          controls: old\n        });\n      };\n    }\n  }, [makeDefault, api, get, set]);\n  var points = faces == null ? void 0 : faces.faceLandmarks[0];\n  var facialTransformationMatrix = faces == null || (_faces$facialTransfor = faces.facialTransformationMatrixes) == null ? void 0 : _faces$facialTransfor[0];\n  var faceBlendshapes = faces == null || (_faces$faceBlendshape = faces.faceBlendshapes) == null ? void 0 : _faces$faceBlendshape[0];\n  return /*#__PURE__*/React.createElement(FaceControlsContext.Provider, {\n    value: api\n  }, webcam && /*#__PURE__*/React.createElement(Suspense, {\n    fallback: null\n  }, /*#__PURE__*/React.createElement(Webcam, {\n    ref: webcamApiRef,\n    autostart: autostart,\n    videoTextureSrc: webcamVideoTextureSrc\n  })), /*#__PURE__*/React.createElement(Facemesh, _extends({\n    ref: facemeshApiRef\n  }, facemesh, {\n    points: points,\n    depth: depth,\n    facialTransformationMatrix: facialTransformationMatrix,\n    faceBlendshapes: faceBlendshapes,\n    eyes: eyes,\n    eyesAsOrigin: eyesAsOrigin,\n    offset: offset,\n    offsetScalar: offsetScalar,\n    debug: debug,\n    \"rotation-z\": Math.PI,\n    visible: debug\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    side: THREE.DoubleSide\n  })));\n});\nvar useFaceControls = function useFaceControls() {\n  return useContext(FaceControlsContext);\n};\n\n//\n// Webcam\n//\nvar Webcam = /* @__PURE__ */forwardRef(function (_ref2, fref) {\n  var videoTextureSrc = _ref2.videoTextureSrc,\n    _ref2$autostart = _ref2.autostart,\n    autostart = _ref2$autostart === void 0 ? true : _ref2$autostart;\n  var videoTextureApiRef = useRef(null);\n  var faceControls = useFaceControls();\n  var stream = suspend( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (videoTextureSrc) {\n            _context.next = 6;\n            break;\n          }\n          _context.next = 3;\n          return navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: {\n              facingMode: 'user'\n            }\n          });\n        case 3:\n          _context.t0 = _context.sent;\n          _context.next = 7;\n          break;\n        case 6:\n          _context.t0 = Promise.resolve(null);\n        case 7:\n          return _context.abrupt(\"return\", _context.t0);\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  })), [videoTextureSrc]);\n  useEffect(function () {\n    faceControls.dispatchEvent({\n      type: 'stream',\n      stream: stream\n    });\n    return function () {\n      stream == null || stream.getTracks().forEach(function (track) {\n        return track.stop();\n      });\n      clear([videoTextureSrc]);\n    };\n  }, [stream, faceControls, videoTextureSrc]);\n\n  // ref-api\n  var api = useMemo(function () {\n    return {\n      videoTextureApiRef: videoTextureApiRef\n    };\n  }, []);\n  useImperativeHandle(fref, function () {\n    return api;\n  }, [api]);\n  return /*#__PURE__*/React.createElement(Suspense, {\n    fallback: null\n  }, /*#__PURE__*/React.createElement(VideoTexture, {\n    ref: videoTextureApiRef,\n    src: videoTextureSrc || stream,\n    start: autostart\n  }));\n});\n\n//\n// VideoTexture\n//\nvar VideoTexture = /* @__PURE__ */forwardRef(function (_ref4, fref) {\n  var src = _ref4.src,\n    start = _ref4.start;\n  var texture = useVideoTexture(src, {\n    start: start\n  });\n  var video = texture.source.data;\n  var faceControls = useFaceControls();\n  var onVideoFrame = useCallback(function (time) {\n    faceControls.dispatchEvent({\n      type: 'videoFrame',\n      texture: texture,\n      time: time\n    });\n  }, [texture, faceControls]);\n  useVideoFrame(video, onVideoFrame);\n\n  // ref-api\n  var api = useMemo(function () {\n    return {\n      texture: texture\n    };\n  }, [texture]);\n  useImperativeHandle(fref, function () {\n    return api;\n  }, [api]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null);\n});\nvar useVideoFrame = function useVideoFrame(video, f) {\n  // https://web.dev/requestvideoframecallback-rvfc/\n  // https://www.remotion.dev/docs/video-manipulation\n  useEffect(function () {\n    if (!video || !video.requestVideoFrameCallback) return;\n    var handle;\n    function callback() {\n      f.apply(void 0, arguments);\n      handle = video.requestVideoFrameCallback(callback);\n    }\n    video.requestVideoFrameCallback(callback);\n    return function () {\n      return video.cancelVideoFrameCallback(handle);\n    };\n  }, [video, f]);\n};\nexport { FaceControls, useFaceControls };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}