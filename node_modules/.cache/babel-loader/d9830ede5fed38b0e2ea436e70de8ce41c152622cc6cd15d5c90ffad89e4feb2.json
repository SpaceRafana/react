{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Line3, Plane, Triangle } from \"three\";\nvar Visible = 0;\nvar Deleted = 1;\nvar _v1 = new Vector3();\nvar _line3 = new Line3();\nvar _plane = new Plane();\nvar _closestPoint = new Vector3();\nvar _triangle = new Triangle();\nvar ConvexHull = /*#__PURE__*/function () {\n  function ConvexHull() {\n    _classCallCheck(this, ConvexHull);\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n  _createClass(ConvexHull, [{\n    key: \"setFromPoints\",\n    value: function setFromPoints(points) {\n      if (points.length >= 4) {\n        this.makeEmpty();\n        for (var i = 0, l = points.length; i < l; i++) {\n          this.vertices.push(new VertexNode(points[i]));\n        }\n        this.compute();\n      }\n      return this;\n    }\n  }, {\n    key: \"setFromObject\",\n    value: function setFromObject(object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var geometry = node.geometry;\n        if (geometry !== void 0) {\n          var attribute = geometry.attributes.position;\n          if (attribute !== void 0) {\n            for (var i = 0, l = attribute.count; i < l; i++) {\n              var point = new Vector3();\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n              points.push(point);\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var faces = this.faces;\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i];\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"intersectRay\",\n    value: function intersectRay(ray, target) {\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i];\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction);\n        if (vN > 0 && vD >= 0) return null;\n        var t = vD !== 0 ? -vN / vD : 0;\n        if (t <= 0) continue;\n        if (vD > 0) {\n          tFar = Math.min(t, tFar);\n        } else {\n          tNear = Math.max(t, tNear);\n        }\n        if (tNear > tFar) {\n          return null;\n        }\n      }\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n      return target;\n    }\n  }, {\n    key: \"intersectsRay\",\n    value: function intersectsRay(ray) {\n      return this.intersectRay(ray, _v1) !== null;\n    }\n  }, {\n    key: \"makeEmpty\",\n    value: function makeEmpty() {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    }\n    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n  }, {\n    key: \"addVertexToFace\",\n    value: function addVertexToFace(vertex, face) {\n      vertex.face = face;\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n      face.outside = vertex;\n      return this;\n    }\n    // Removes a vertex from the 'assigned' list of vertices and from the given face\n  }, {\n    key: \"removeVertexFromFace\",\n    value: function removeVertexFromFace(vertex, face) {\n      if (vertex === face.outside) {\n        if (vertex.next !== null && vertex.next.face === face) {\n          face.outside = vertex.next;\n        } else {\n          face.outside = null;\n        }\n      }\n      this.assigned.remove(vertex);\n      return this;\n    }\n    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n  }, {\n    key: \"removeAllVerticesFromFace\",\n    value: function removeAllVerticesFromFace(face) {\n      if (face.outside !== null) {\n        var start = face.outside;\n        var end = face.outside;\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n        this.assigned.removeSubList(start, end);\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    }\n    // Removes all the visible vertices that 'face' is able to see\n  }, {\n    key: \"deleteFaceVertices\",\n    value: function deleteFaceVertices(face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n      if (faceVertices !== void 0) {\n        if (absorbingFace === void 0) {\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          var vertex = faceVertices;\n          do {\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point);\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            }\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n      return this;\n    }\n    // Reassigns as many vertices as possible from the unassigned list to the new faces\n  }, {\n    key: \"resolveUnassignedPoints\",\n    value: function resolveUnassignedPoints(newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n        do {\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n          for (var i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n              if (maxDistance > 1e3 * this.tolerance) break;\n            }\n          }\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n      return this;\n    }\n    // Computes the extremes of a simplex which will be the initial hull\n  }, {\n    key: \"computeExtremes\",\n    value: function computeExtremes() {\n      var min = new Vector3();\n      var max = new Vector3();\n      var minVertices = [];\n      var maxVertices = [];\n      for (var i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point);\n      for (var _i = 0, l = this.vertices.length; _i < l; _i++) {\n        var vertex = this.vertices[_i];\n        var point = vertex.point;\n        for (var j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        }\n        for (var _j = 0; _j < 3; _j++) {\n          if (point.getComponent(_j) > max.getComponent(_j)) {\n            max.setComponent(_j, point.getComponent(_j));\n            maxVertices[_j] = vertex;\n          }\n        }\n      }\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    }\n    // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n  }, {\n    key: \"computeInitialHull\",\n    value: function computeInitialHull() {\n      var vertices = this.vertices;\n      var extremes = this.computeExtremes();\n      var min = extremes.min;\n      var max = extremes.max;\n      var maxDistance = 0;\n      var index = 0;\n      for (var i = 0; i < 3; i++) {\n        var distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          index = i;\n        }\n      }\n      var v0 = min[index];\n      var v1 = max[index];\n      var v2;\n      var v3;\n      maxDistance = 0;\n      _line3.set(v0.point, v1.point);\n      for (var _i2 = 0, l = this.vertices.length; _i2 < l; _i2++) {\n        var vertex = vertices[_i2];\n        if (vertex !== v0 && vertex !== v1) {\n          _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n          var _distance = _closestPoint.distanceToSquared(vertex.point);\n          if (_distance > maxDistance) {\n            maxDistance = _distance;\n            v2 = vertex;\n          }\n        }\n      }\n      maxDistance = -1;\n      _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n      for (var _i3 = 0, _l = this.vertices.length; _i3 < _l; _i3++) {\n        var _vertex = vertices[_i3];\n        if (_vertex !== v0 && _vertex !== v1 && _vertex !== v2) {\n          var _distance2 = Math.abs(_plane.distanceToPoint(_vertex.point));\n          if (_distance2 > maxDistance) {\n            maxDistance = _distance2;\n            v3 = _vertex;\n          }\n        }\n      }\n      var faces = [];\n      if (_plane.distanceToPoint(v3.point) < 0) {\n        faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n        for (var _i4 = 0; _i4 < 3; _i4++) {\n          var j = (_i4 + 1) % 3;\n          faces[_i4 + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n          faces[_i4 + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n        }\n      } else {\n        faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n        for (var _i5 = 0; _i5 < 3; _i5++) {\n          var _j2 = (_i5 + 1) % 3;\n          faces[_i5 + 1].getEdge(2).setTwin(faces[0].getEdge((3 - _i5) % 3));\n          faces[_i5 + 1].getEdge(0).setTwin(faces[_j2 + 1].getEdge(1));\n        }\n      }\n      for (var _i6 = 0; _i6 < 4; _i6++) {\n        this.faces.push(faces[_i6]);\n      }\n      for (var _i7 = 0, _l2 = vertices.length; _i7 < _l2; _i7++) {\n        var _vertex2 = vertices[_i7];\n        if (_vertex2 !== v0 && _vertex2 !== v1 && _vertex2 !== v2 && _vertex2 !== v3) {\n          maxDistance = this.tolerance;\n          var maxFace = null;\n          for (var _j3 = 0; _j3 < 4; _j3++) {\n            var _distance3 = this.faces[_j3].distanceToPoint(_vertex2.point);\n            if (_distance3 > maxDistance) {\n              maxDistance = _distance3;\n              maxFace = this.faces[_j3];\n            }\n          }\n          if (maxFace !== null) {\n            this.addVertexToFace(_vertex2, maxFace);\n          }\n        }\n      }\n      return this;\n    }\n    // Removes inactive faces\n  }, {\n    key: \"reindexFaces\",\n    value: function reindexFaces() {\n      var activeFaces = [];\n      for (var i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n      this.faces = activeFaces;\n      return this;\n    }\n    // Finds the next vertex to create faces with the current hull\n  }, {\n    key: \"nextVertexToAdd\",\n    value: function nextVertexToAdd() {\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n          maxDistance = 0;\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside;\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n        return eyeVertex;\n      }\n    }\n    // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n  }, {\n    key: \"computeHorizon\",\n    value: function computeHorizon(eyePoint, crossEdge, face, horizon) {\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        edge = crossEdge.next;\n      }\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            horizon.push(edge);\n          }\n        }\n        edge = edge.next;\n      } while (edge !== crossEdge);\n      return this;\n    }\n    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n  }, {\n    key: \"addAdjoiningFace\",\n    value: function addAdjoiningFace(eyeVertex, horizonEdge) {\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face);\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0);\n    }\n    //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n  }, {\n    key: \"addNewFaces\",\n    value: function addNewFaces(eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n      for (var i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i];\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      }\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    }\n    // Adds a vertex to the hull\n  }, {\n    key: \"addVertexToHull\",\n    value: function addVertexToHull(eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear();\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon);\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var vertex;\n      this.computeInitialHull();\n      while ((vertex = this.nextVertexToAdd()) !== void 0) {\n        this.addVertexToHull(vertex);\n      }\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }]);\n  return ConvexHull;\n}();\nvar Face = /*#__PURE__*/function () {\n  function Face() {\n    _classCallCheck(this, Face);\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n  _createClass(Face, [{\n    key: \"getEdge\",\n    value: function getEdge(i) {\n      var edge = this.edge;\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n      return edge;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var a = this.edge.tail();\n      var b = this.edge.head();\n      var c = this.edge.next.head();\n      _triangle.set(a.point, b.point, c.point);\n      _triangle.getNormal(this.normal);\n      _triangle.getMidpoint(this.midpoint);\n      this.area = _triangle.getArea();\n      this.constant = this.normal.dot(this.midpoint);\n      return this;\n    }\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face);\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0;\n      face.edge = e0;\n      return face.compute();\n    }\n  }]);\n  return Face;\n}();\nvar HalfEdge = /*#__PURE__*/function () {\n  function HalfEdge(vertex, face) {\n    _classCallCheck(this, HalfEdge);\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  _createClass(HalfEdge, [{\n    key: \"head\",\n    value: function head() {\n      return this.vertex;\n    }\n  }, {\n    key: \"tail\",\n    value: function tail() {\n      return this.prev ? this.prev.vertex : null;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var head = this.head();\n      var tail = this.tail();\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n      return -1;\n    }\n  }, {\n    key: \"lengthSquared\",\n    value: function lengthSquared() {\n      var head = this.head();\n      var tail = this.tail();\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n      return -1;\n    }\n  }, {\n    key: \"setTwin\",\n    value: function setTwin(edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }]);\n  return HalfEdge;\n}();\nvar VertexNode = /*#__PURE__*/_createClass(function VertexNode(point) {\n  _classCallCheck(this, VertexNode);\n  this.point = point;\n  this.prev = null;\n  this.next = null;\n  this.face = null;\n});\nvar VertexList = /*#__PURE__*/function () {\n  function VertexList() {\n    _classCallCheck(this, VertexList);\n    this.head = null;\n    this.tail = null;\n  }\n  _createClass(VertexList, [{\n    key: \"first\",\n    value: function first() {\n      return this.head;\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.tail;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      return this;\n    }\n    // Inserts a vertex before the target vertex\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n      target.prev = vertex;\n      return this;\n    }\n    // Inserts a vertex after the target vertex\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n      target.next = vertex;\n      return this;\n    }\n    // Appends a vertex to the end of the linked list\n  }, {\n    key: \"append\",\n    value: function append(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n      vertex.prev = this.tail;\n      vertex.next = null;\n      this.tail = vertex;\n      return this;\n    }\n    // Appends a chain of vertices where 'vertex' is the head.\n  }, {\n    key: \"appendChain\",\n    value: function appendChain(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n      vertex.prev = this.tail;\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n      this.tail = vertex;\n      return this;\n    }\n    // Removes a vertex from the linked list\n  }, {\n    key: \"remove\",\n    value: function remove(vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n      return this;\n    }\n    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n  }, {\n    key: \"removeSubList\",\n    value: function removeSubList(a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n      return this;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.head === null;\n    }\n  }]);\n  return VertexList;\n}();\nexport { ConvexHull, Face, HalfEdge, VertexList, VertexNode };\n//# sourceMappingURL=ConvexHull.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}