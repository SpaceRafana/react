{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Matrix4, Mesh, BufferGeometry, MathUtils, DataTexture, RGBAFormat, FloatType, BufferAttribute } from \"three\";\nconst _identityMatrix = new Matrix4();\nconst _zeroMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\nconst batchingParsVertex = /* glsl */\n`\n#ifdef BATCHING\n\tattribute float id;\n\tuniform highp sampler2D batchingTexture;\n\tuniform int batchingTextureSize;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( batchingTextureSize ) );\n\t\tfloat y = floor( j / float( batchingTextureSize ) );\n\t\tfloat dx = 1.0 / float( batchingTextureSize );\n\t\tfloat dy = 1.0 / float( batchingTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( batchingTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( batchingTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( batchingTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( batchingTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif\n`;\nconst batchingbaseVertex = /* glsl */\n`\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( id );\n#endif\n`;\nconst batchingnormalVertex = /* glsl */\n`\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`;\nconst batchingVertex = /* glsl */\n`\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`;\nclass BatchedMesh extends Mesh {\n  constructor(maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {\n    super(new BufferGeometry(), material);\n    __publicField(this, \"_vertexStarts\");\n    __publicField(this, \"_vertexCounts\");\n    __publicField(this, \"_indexStarts\");\n    __publicField(this, \"_indexCounts\");\n    __publicField(this, \"_visibles\");\n    __publicField(this, \"_alives\");\n    __publicField(this, \"_maxGeometryCount\");\n    __publicField(this, \"_maxVertexCount\");\n    __publicField(this, \"_maxIndexCount\");\n    __publicField(this, \"_geometryInitialized\");\n    __publicField(this, \"_geometryCount\");\n    __publicField(this, \"_vertexCount\");\n    __publicField(this, \"_indexCount\");\n    __publicField(this, \"_matrices\");\n    __publicField(this, \"_matricesArray\");\n    __publicField(this, \"_matricesTexture\");\n    __publicField(this, \"_matricesTextureSize\");\n    __publicField(this, \"_customUniforms\");\n    this._vertexStarts = [];\n    this._vertexCounts = [];\n    this._indexStarts = [];\n    this._indexCounts = [];\n    this._visibles = [];\n    this._alives = [];\n    this._maxGeometryCount = maxGeometryCount;\n    this._maxVertexCount = maxVertexCount;\n    this._maxIndexCount = maxIndexCount;\n    this._geometryInitialized = false;\n    this._geometryCount = 0;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n    this._matrices = [];\n    this._matricesArray = null;\n    this._matricesTexture = null;\n    this._matricesTextureSize = null;\n    this.frustumCulled = false;\n    this._customUniforms = {\n      batchingTexture: {\n        value: null\n      },\n      batchingTextureSize: {\n        value: 0\n      }\n    };\n    this._initMatricesTexture();\n    this._initShader();\n  }\n  _initMatricesTexture() {\n    let size = Math.sqrt(this._maxGeometryCount * 4);\n    size = MathUtils.ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const matricesArray = new Float32Array(size * size * 4);\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);\n    this._matricesArray = matricesArray;\n    this._matricesTexture = matricesTexture;\n    this._matricesTextureSize = size;\n    this._customUniforms.batchingTexture.value = this._matricesTexture;\n    this._customUniforms.batchingTextureSize.value = this._matricesTextureSize;\n  }\n  _initShader() {\n    const currentOnBeforeCompile = this.material.onBeforeCompile;\n    const customUniforms = this._customUniforms;\n    this.material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      parameters.vertexShader = parameters.vertexShader.replace(\"#include <skinning_pars_vertex>\", \"#include <skinning_pars_vertex>\\n\" + batchingParsVertex).replace(\"#include <skinnormal_vertex>\", \"#include <skinnormal_vertex>\\n\" + batchingbaseVertex + batchingnormalVertex).replace(\"#include <skinning_vertex>\", \"#include <skinning_vertex>\\n\" + batchingVertex);\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName];\n      }\n      currentOnBeforeCompile.call(this, parameters, renderer);\n    };\n    this.material.defines = this.material.defines || {};\n    this.material.defines.BATCHING = false;\n  }\n  getGeometryCount() {\n    return this._geometryCount;\n  }\n  getVertexCount() {\n    return this._vertexCount;\n  }\n  getIndexCount() {\n    return this._indexCount;\n  }\n  applyGeometry(geometry) {\n    var _a;\n    if (this._geometryCount >= this._maxGeometryCount) ;\n    if (this._geometryInitialized === false) {\n      for (const attributeName in geometry.attributes) {\n        const srcAttribute = geometry.getAttribute(attributeName);\n        const {\n          array,\n          itemSize,\n          normalized\n        } = srcAttribute;\n        const dstArray = new array.constructor(this._maxVertexCount * itemSize);\n        const dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);\n        dstAttribute.setUsage(srcAttribute.usage);\n        this.geometry.setAttribute(attributeName, dstAttribute);\n      }\n      if (geometry.getIndex() !== null) {\n        const indexArray = this._maxVertexCount > 65536 ? new Uint32Array(this._maxIndexCount) : new Uint16Array(this._maxIndexCount);\n        this.geometry.setIndex(new BufferAttribute(indexArray, 1));\n      }\n      const idArray = this._maxGeometryCount > 65536 ? new Uint32Array(this._maxVertexCount) : new Uint16Array(this._maxVertexCount);\n      this.geometry.setAttribute(\"id\", new BufferAttribute(idArray, 1));\n      this._geometryInitialized = true;\n    }\n    const hasIndex = this.geometry.getIndex() !== null;\n    const dstIndex = this.geometry.getIndex();\n    const srcIndex = geometry.getIndex();\n    const srcPositionAttribute = geometry.getAttribute(\"position\");\n    this._vertexStarts.push(this._vertexCount);\n    this._vertexCounts.push(srcPositionAttribute.count);\n    if (hasIndex) {\n      this._indexStarts.push(this._indexCount);\n      this._indexCounts.push(srcIndex.count);\n    }\n    this._visibles.push(true);\n    this._alives.push(true);\n    for (const attributeName in geometry.attributes) {\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = this.geometry.getAttribute(attributeName);\n      dstAttribute.array.set(srcAttribute.array, this._vertexCount * dstAttribute.itemSize);\n      dstAttribute.needsUpdate = true;\n    }\n    if (hasIndex) {\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(this._indexCount + i, this._vertexCount + srcIndex.getX(i));\n      }\n      this._indexCount += srcIndex.count;\n      dstIndex.needsUpdate = true;\n    }\n    const geometryId = this._geometryCount;\n    this._geometryCount++;\n    const idAttribute = this.geometry.getAttribute(\"id\");\n    for (let i = 0; i < srcPositionAttribute.count; i++) {\n      idAttribute.setX(this._vertexCount + i, geometryId);\n    }\n    idAttribute.needsUpdate = true;\n    this._vertexCount += srcPositionAttribute.count;\n    this._matrices.push(new Matrix4());\n    _identityMatrix.toArray((_a = this._matricesArray) != null ? _a : void 0, geometryId * 16);\n    this._matricesTexture.needsUpdate = true;\n    return geometryId;\n  }\n  deleteGeometry(geometryId) {\n    if (geometryId >= this._alives.length || this._alives[geometryId] === false) {\n      return this;\n    }\n    this._alives[geometryId] = false;\n    _zeroMatrix.toArray(this._matricesArray, geometryId * 16);\n    this._matricesTexture.needsUpdate = true;\n    return this;\n  }\n  optimize() {\n    return this;\n  }\n  setMatrixAt(geometryId, matrix) {\n    if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {\n      return this;\n    }\n    this._matrices[geometryId].copy(matrix);\n    if (this._visibles[geometryId] === true) {\n      matrix.toArray(this._matricesArray, geometryId * 16);\n      this._matricesTexture.needsUpdate = true;\n    }\n    return this;\n  }\n  getMatrixAt(geometryId, matrix) {\n    if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {\n      return matrix;\n    }\n    return matrix.copy(this._matrices[geometryId]);\n  }\n  setVisibleAt(geometryId, visible) {\n    if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {\n      return this;\n    }\n    if (this._visibles[geometryId] === visible) {\n      return this;\n    }\n    if (visible === true) {\n      this._matrices[geometryId].toArray(this._matricesArray, geometryId * 16);\n    } else {\n      _zeroMatrix.toArray(this._matricesArray, geometryId * 16);\n    }\n    this._matricesTexture.needsUpdate = true;\n    this._visibles[geometryId] = visible;\n    return this;\n  }\n  getVisibleAt(geometryId) {\n    if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {\n      return false;\n    }\n    return this._visibles[geometryId];\n  }\n  copy(source) {\n    super.copy(source);\n    return this;\n  }\n  toJSON(meta) {\n    return super.toJSON(meta);\n  }\n  dispose() {\n    var _a;\n    this.geometry.dispose();\n    (_a = this._matricesTexture) == null ? void 0 : _a.dispose();\n    this._matricesTexture = null;\n    return this;\n  }\n  // @ts-ignore\n  onBeforeRender() {\n    if (this.material.defines) {\n      this.material.defines.BATCHING = true;\n    }\n  }\n  // @ts-ignore\n  onAfterRender() {\n    if (this.material.defines) {\n      this.material.defines.BATCHING = false;\n    }\n  }\n}\nexport { BatchedMesh };\n//# sourceMappingURL=BatchedMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}