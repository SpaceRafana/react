{"ast":null,"code":"import _regeneratorRuntime from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { strToU8, zipSync } from \"fflate\";\nimport { Mesh, MeshPhysicalMaterial } from \"three\";\nvar USDZExporter = /*#__PURE__*/function () {\n  function USDZExporter() {\n    _classCallCheck(this, USDZExporter);\n    __publicField(this, \"PRECISION\", 7);\n    __publicField(this, \"materials\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"files\");\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n  _createClass(USDZExporter, [{\n    key: \"parse\",\n    value: function () {\n      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(scene) {\n        var _this = this;\n        var modelFileName, output, _loop, id, offset, filename, file, headerSize, offsetMod64, padLength, padding;\n        return _regeneratorRuntime().wrap(function _callee$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              modelFileName = \"model.usda\";\n              this.files[modelFileName] = null;\n              output = this.buildHeader();\n              scene.traverseVisible(function (object) {\n                if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n                  var geometry = object.geometry;\n                  var material = object.material;\n                  var geometryFileName = \"geometries/Geometry_\" + geometry.id + \".usd\";\n                  if (!(geometryFileName in _this.files)) {\n                    var meshObject = _this.buildMeshObject(geometry);\n                    _this.files[geometryFileName] = _this.buildUSDFileAsString(meshObject);\n                  }\n                  if (!(material.uuid in _this.materials)) {\n                    _this.materials[material.uuid] = material;\n                  }\n                  output += _this.buildXform(object, geometry, material);\n                }\n              });\n              output += this.buildMaterials(this.materials);\n              this.files[modelFileName] = strToU8(output);\n              output = null;\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                var texture, color, isRGBA, canvas, blob;\n                return _regeneratorRuntime().wrap(function _loop$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      texture = _this.textures[id];\n                      color = id.split(\"_\")[1];\n                      isRGBA = texture.format === 1023;\n                      canvas = _this.imageToCanvas(texture.image, color);\n                      _context.next = 6;\n                      return new Promise(function (resolve) {\n                        return canvas == null ? void 0 : canvas.toBlob(resolve, isRGBA ? \"image/png\" : \"image/jpeg\", 1);\n                      });\n                    case 6:\n                      blob = _context.sent;\n                      if (!blob) {\n                        _context.next = 13;\n                        break;\n                      }\n                      _context.t0 = Uint8Array;\n                      _context.next = 11;\n                      return blob.arrayBuffer();\n                    case 11:\n                      _context.t1 = _context.sent;\n                      _this.files[\"textures/Texture_\".concat(id, \".\").concat(isRGBA ? \"png\" : \"jpg\")] = new _context.t0(_context.t1);\n                    case 13:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _loop);\n              });\n              _context2.t0 = _regeneratorRuntime().keys(this.textures);\n            case 9:\n              if ((_context2.t1 = _context2.t0()).done) {\n                _context2.next = 14;\n                break;\n              }\n              id = _context2.t1.value;\n              return _context2.delegateYield(_loop(), \"t2\", 12);\n            case 12:\n              _context2.next = 9;\n              break;\n            case 14:\n              offset = 0;\n              for (filename in this.files) {\n                file = this.files[filename];\n                headerSize = 34 + filename.length;\n                offset += headerSize;\n                offsetMod64 = offset & 63;\n                if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n                  padLength = 64 - offsetMod64;\n                  padding = new Uint8Array(padLength);\n                  this.files[filename] = [file, {\n                    extra: {\n                      12345: padding\n                    }\n                  }];\n                }\n                if (file && typeof file.length === \"number\") {\n                  offset = file.length;\n                }\n              }\n              return _context2.abrupt(\"return\", zipSync(this.files, {\n                level: 0\n              }));\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee, this);\n      }));\n      function parse(_x) {\n        return _parse.apply(this, arguments);\n      }\n      return parse;\n    }()\n  }, {\n    key: \"imageToCanvas\",\n    value: function imageToCanvas(image, color) {\n      if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== \"undefined\" && image instanceof OffscreenCanvas || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n        var scale = 1024 / Math.max(image.width, image.height);\n        var canvas = document.createElement(\"canvas\");\n        canvas.width = image.width * Math.min(1, scale);\n        canvas.height = image.height * Math.min(1, scale);\n        var context = canvas.getContext(\"2d\");\n        context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n        if (color !== void 0) {\n          var hex = parseInt(color, 16);\n          var r = (hex >> 16 & 255) / 255;\n          var g = (hex >> 8 & 255) / 255;\n          var b = (hex & 255) / 255;\n          var imagedata = context == null ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n          if (imagedata) {\n            var data = imagedata == null ? void 0 : imagedata.data;\n            for (var i = 0; i < data.length; i += 4) {\n              data[i + 0] = data[i + 0] * r;\n              data[i + 1] = data[i + 1] * g;\n              data[i + 2] = data[i + 2] * b;\n            }\n            context == null ? void 0 : context.putImageData(imagedata, 0, 0);\n          }\n        }\n        return canvas;\n      }\n    }\n  }, {\n    key: \"buildHeader\",\n    value: function buildHeader() {\n      return \"#usda 1.0\\n(\\n    customLayerData = {\\n        string creator = \\\"Three.js USDZExporter\\\"\\n    }\\n    metersPerUnit = 1\\n    upAxis = \\\"Y\\\"\\n)\\n\";\n    }\n  }, {\n    key: \"buildUSDFileAsString\",\n    value: function buildUSDFileAsString(dataToInsert) {\n      var output = this.buildHeader();\n      output += dataToInsert;\n      return strToU8(output);\n    }\n    // Xform\n  }, {\n    key: \"buildXform\",\n    value: function buildXform(object, geometry, material) {\n      var name = \"Object_\" + object.id;\n      var transform = this.buildMatrix(object.matrixWorld);\n      if (object.matrixWorld.determinant() < 0) {\n        console.warn(\"THREE.USDZExporter: USDZ does not support negative scales\", object);\n      }\n      return \"def Xform \\\"\".concat(name, \"\\\" (\\n    prepend references = @./geometries/Geometry_\").concat(geometry.id, \".usd@</Geometry>\\n)\\n{\\n    matrix4d xformOp:transform = \").concat(transform, \"\\n    uniform token[] xformOpOrder = [\\\"xformOp:transform\\\"]\\n    rel material:binding = </Materials/Material_\").concat(material.id, \">\\n}\\n\");\n    }\n  }, {\n    key: \"buildMatrix\",\n    value: function buildMatrix(matrix) {\n      var array = matrix.elements;\n      return \"( \".concat(this.buildMatrixRow(array, 0), \", \").concat(this.buildMatrixRow(array, 4), \", \").concat(this.buildMatrixRow(array, 8), \", \").concat(this.buildMatrixRow(array, 12), \" )\");\n    }\n  }, {\n    key: \"buildMatrixRow\",\n    value: function buildMatrixRow(array, offset) {\n      return \"(\".concat(array[offset + 0], \", \").concat(array[offset + 1], \", \").concat(array[offset + 2], \", \").concat(array[offset + 3], \")\");\n    }\n    // Mesh\n  }, {\n    key: \"buildMeshObject\",\n    value: function buildMeshObject(geometry) {\n      var mesh = this.buildMesh(geometry);\n      return \"\\ndef \\\"Geometry\\\"\\n{\\n  \".concat(mesh, \"\\n}\\n\");\n    }\n  }, {\n    key: \"buildMesh\",\n    value: function buildMesh(geometry) {\n      var name = \"Geometry\";\n      var attributes = geometry.attributes;\n      var count = attributes.position.count;\n      return \"\\n    def Mesh \\\"\".concat(name, \"\\\"\\n    {\\n        int[] faceVertexCounts = [\").concat(this.buildMeshVertexCount(geometry), \"]\\n        int[] faceVertexIndices = [\").concat(this.buildMeshVertexIndices(geometry), \"]\\n        normal3f[] normals = [\").concat(this.buildVector3Array(attributes.normal, count), \"] (\\n            interpolation = \\\"vertex\\\"\\n        )\\n        point3f[] points = [\").concat(this.buildVector3Array(attributes.position, count), \"]\\n        float2[] primvars:st = [\").concat(this.buildVector2Array(attributes.uv, count), \"] (\\n            interpolation = \\\"vertex\\\"\\n        )\\n        uniform token subdivisionScheme = \\\"none\\\"\\n    }\\n\");\n    }\n  }, {\n    key: \"buildMeshVertexCount\",\n    value: function buildMeshVertexCount(geometry) {\n      var count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n      return Array(count / 3).fill(3).join(\", \");\n    }\n  }, {\n    key: \"buildMeshVertexIndices\",\n    value: function buildMeshVertexIndices(geometry) {\n      if (geometry.index !== null) {\n        return geometry.index.array.join(\", \");\n      }\n      var array = [];\n      var length = geometry.attributes.position.count;\n      for (var i = 0; i < length; i++) {\n        array.push(i);\n      }\n      return array.join(\", \");\n    }\n  }, {\n    key: \"buildVector3Array\",\n    value: function buildVector3Array(attribute, count) {\n      if (attribute === void 0) {\n        console.warn(\"USDZExporter: Normals missing.\");\n        return Array(count).fill(\"(0, 0, 0)\").join(\", \");\n      }\n      var array = [];\n      var data = attribute.array;\n      for (var i = 0; i < data.length; i += 3) {\n        array.push(\"(\".concat(data[i + 0].toPrecision(this.PRECISION), \", \").concat(data[i + 1].toPrecision(this.PRECISION), \", \").concat(data[i + 2].toPrecision(this.PRECISION), \")\"));\n      }\n      return array.join(\", \");\n    }\n  }, {\n    key: \"buildVector2Array\",\n    value: function buildVector2Array(attribute, count) {\n      if (attribute === void 0) {\n        console.warn(\"USDZExporter: UVs missing.\");\n        return Array(count).fill(\"(0, 0)\").join(\", \");\n      }\n      var array = [];\n      var data = attribute.array;\n      for (var i = 0; i < data.length; i += 2) {\n        array.push(\"(\".concat(data[i + 0].toPrecision(this.PRECISION), \", \").concat(1 - data[i + 1].toPrecision(this.PRECISION), \")\"));\n      }\n      return array.join(\", \");\n    }\n    // Materials\n  }, {\n    key: \"buildMaterials\",\n    value: function buildMaterials(materials) {\n      var array = [];\n      for (var uuid in materials) {\n        var material = materials[uuid];\n        array.push(this.buildMaterial(material));\n      }\n      return \"def \\\"Materials\\\"\\n{\\n\".concat(array.join(\"\"), \"\\n}\\n\");\n    }\n  }, {\n    key: \"buildMaterial\",\n    value: function buildMaterial(material) {\n      var pad = \"            \";\n      var inputs = [];\n      var samplers = [];\n      if (material.map !== null) {\n        inputs.push(\"\".concat(pad, \"color3f inputs:diffuseColor.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.map.id, \"_diffuse.outputs:rgb>\"));\n        samplers.push(this.buildTexture(material, material.map, \"diffuse\", material.color));\n      } else {\n        inputs.push(\"\".concat(pad, \"color3f inputs:diffuseColor = \").concat(this.buildColor(material.color)));\n      }\n      if (material.emissiveMap !== null) {\n        inputs.push(\"\".concat(pad, \"color3f inputs:emissiveColor.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.emissiveMap.id, \"_emissive.outputs:rgb>\"));\n        samplers.push(this.buildTexture(material, material.emissiveMap, \"emissive\"));\n      } else if (material.emissive.getHex() > 0) {\n        inputs.push(\"\".concat(pad, \"color3f inputs:emissiveColor = \").concat(this.buildColor(material.emissive)));\n      }\n      if (material.normalMap !== null) {\n        inputs.push(\"\".concat(pad, \"normal3f inputs:normal.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.normalMap.id, \"_normal.outputs:rgb>\"));\n        samplers.push(this.buildTexture(material, material.normalMap, \"normal\"));\n      }\n      if (material.aoMap !== null) {\n        inputs.push(\"\".concat(pad, \"float inputs:occlusion.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.aoMap.id, \"_occlusion.outputs:r>\"));\n        samplers.push(this.buildTexture(material, material.aoMap, \"occlusion\"));\n      }\n      if (material.roughnessMap !== null && material.roughness === 1) {\n        inputs.push(\"\".concat(pad, \"float inputs:roughness.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.roughnessMap.id, \"_roughness.outputs:g>\"));\n        samplers.push(this.buildTexture(material, material.roughnessMap, \"roughness\"));\n      } else {\n        inputs.push(\"\".concat(pad, \"float inputs:roughness = \").concat(material.roughness));\n      }\n      if (material.metalnessMap !== null && material.metalness === 1) {\n        inputs.push(\"\".concat(pad, \"float inputs:metallic.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.metalnessMap.id, \"_metallic.outputs:b>\"));\n        samplers.push(this.buildTexture(material, material.metalnessMap, \"metallic\"));\n      } else {\n        inputs.push(\"\".concat(pad, \"float inputs:metallic = \").concat(material.metalness));\n      }\n      inputs.push(\"\".concat(pad, \"float inputs:opacity = \").concat(material.opacity));\n      if (material instanceof MeshPhysicalMaterial) {\n        inputs.push(\"\".concat(pad, \"float inputs:clearcoat = \").concat(material.clearcoat));\n        inputs.push(\"\".concat(pad, \"float inputs:clearcoatRoughness = \").concat(material.clearcoatRoughness));\n        inputs.push(\"\".concat(pad, \"float inputs:ior = \").concat(material.ior));\n      }\n      return \"\\n    def Material \\\"Material_\".concat(material.id, \"\\\"\\n    {\\n        def Shader \\\"PreviewSurface\\\"\\n        {\\n            uniform token info:id = \\\"UsdPreviewSurface\\\"\\n\").concat(inputs.join(\"\\n\"), \"\\n            int inputs:useSpecularWorkflow = 0\\n            token outputs:surface\\n        }\\n        token outputs:surface.connect = </Materials/Material_\").concat(material.id, \"/PreviewSurface.outputs:surface>\\n        token inputs:frame:stPrimvarName = \\\"st\\\"\\n        def Shader \\\"uvReader_st\\\"\\n        {\\n            uniform token info:id = \\\"UsdPrimvarReader_float2\\\"\\n            token inputs:varname.connect = </Materials/Material_\").concat(material.id, \".inputs:frame:stPrimvarName>\\n            float2 inputs:fallback = (0.0, 0.0)\\n            float2 outputs:result\\n        }\\n\").concat(samplers.join(\"\\n\"), \"\\n    }\\n\");\n    }\n  }, {\n    key: \"buildTexture\",\n    value: function buildTexture(material, texture, mapType, color) {\n      var id = texture.id + (color ? \"_\" + color.getHexString() : \"\");\n      var isRGBA = texture.format === 1023;\n      this.textures[id] = texture;\n      return \"\\n      def Shader \\\"Transform2d_\".concat(mapType, \"\\\" (\\n          sdrMetadata = {\\n              string role = \\\"math\\\"\\n          }\\n      )\\n      {\\n          uniform token info:id = \\\"UsdTransform2d\\\"\\n          float2 inputs:in.connect = </Materials/Material_\").concat(material.id, \"/uvReader_st.outputs:result>\\n          float2 inputs:scale = \").concat(this.buildVector2(texture.repeat), \"\\n          float2 inputs:translation = \").concat(this.buildVector2(texture.offset), \"\\n          float2 outputs:result\\n      }\\n      def Shader \\\"Texture_\").concat(texture.id, \"_\").concat(mapType, \"\\\"\\n      {\\n          uniform token info:id = \\\"UsdUVTexture\\\"\\n          asset inputs:file = @textures/Texture_\").concat(id, \".\").concat(isRGBA ? \"png\" : \"jpg\", \"@\\n          float2 inputs:st.connect = </Materials/Material_\").concat(material.id, \"/Transform2d_\").concat(mapType, \".outputs:result>\\n          token inputs:wrapS = \\\"repeat\\\"\\n          token inputs:wrapT = \\\"repeat\\\"\\n          float outputs:r\\n          float outputs:g\\n          float outputs:b\\n          float3 outputs:rgb\\n      }\");\n    }\n  }, {\n    key: \"buildColor\",\n    value: function buildColor(color) {\n      return \"(\".concat(color.r, \", \").concat(color.g, \", \").concat(color.b, \")\");\n    }\n  }, {\n    key: \"buildVector2\",\n    value: function buildVector2(vector) {\n      return \"(\".concat(vector.x, \", \").concat(vector.y, \")\");\n    }\n  }]);\n  return USDZExporter;\n}();\nexport { USDZExporter };\n//# sourceMappingURL=USDZExporter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}