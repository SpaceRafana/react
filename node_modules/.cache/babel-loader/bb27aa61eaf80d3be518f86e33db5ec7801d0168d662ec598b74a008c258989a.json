{"ast":null,"code":"import _createForOfIteratorHelper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Matrix4, EventDispatcher, Vector2, Vector3, Quaternion, Group, EllipseCurve, BufferGeometry, PerspectiveCamera, MathUtils, OrthographicCamera, Box3, Sphere, GridHelper, LineBasicMaterial, Line, Raycaster } from \"three\";\nvar STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol()\n};\nvar INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol()\n};\nvar _center = {\n  x: 0,\n  y: 0\n};\nvar _transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4()\n};\nvar _changeEvent = {\n  type: \"change\"\n};\nvar _startEvent = {\n  type: \"start\"\n};\nvar _endEvent = {\n  type: \"end\"\n};\nvar ArcballControls = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(ArcballControls, _EventDispatcher);\n  var _super = _createSuper(ArcballControls);\n  function ArcballControls(camera) {\n    var _this;\n    var domElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var scene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, ArcballControls);\n    _this = _super.call(this);\n    __publicField(_assertThisInitialized(_this), \"camera\");\n    __publicField(_assertThisInitialized(_this), \"domElement\");\n    __publicField(_assertThisInitialized(_this), \"scene\");\n    __publicField(_assertThisInitialized(_this), \"mouseActions\");\n    __publicField(_assertThisInitialized(_this), \"_mouseOp\");\n    __publicField(_assertThisInitialized(_this), \"_v2_1\");\n    __publicField(_assertThisInitialized(_this), \"_v3_1\");\n    __publicField(_assertThisInitialized(_this), \"_v3_2\");\n    __publicField(_assertThisInitialized(_this), \"_m4_1\");\n    __publicField(_assertThisInitialized(_this), \"_m4_2\");\n    __publicField(_assertThisInitialized(_this), \"_quat\");\n    __publicField(_assertThisInitialized(_this), \"_translationMatrix\");\n    __publicField(_assertThisInitialized(_this), \"_rotationMatrix\");\n    __publicField(_assertThisInitialized(_this), \"_scaleMatrix\");\n    __publicField(_assertThisInitialized(_this), \"_rotationAxis\");\n    __publicField(_assertThisInitialized(_this), \"_cameraMatrixState\");\n    __publicField(_assertThisInitialized(_this), \"_cameraProjectionState\");\n    __publicField(_assertThisInitialized(_this), \"_fovState\");\n    __publicField(_assertThisInitialized(_this), \"_upState\");\n    __publicField(_assertThisInitialized(_this), \"_zoomState\");\n    __publicField(_assertThisInitialized(_this), \"_nearPos\");\n    __publicField(_assertThisInitialized(_this), \"_farPos\");\n    __publicField(_assertThisInitialized(_this), \"_gizmoMatrixState\");\n    __publicField(_assertThisInitialized(_this), \"_up0\");\n    __publicField(_assertThisInitialized(_this), \"_zoom0\");\n    __publicField(_assertThisInitialized(_this), \"_fov0\");\n    __publicField(_assertThisInitialized(_this), \"_initialNear\");\n    __publicField(_assertThisInitialized(_this), \"_nearPos0\");\n    __publicField(_assertThisInitialized(_this), \"_initialFar\");\n    __publicField(_assertThisInitialized(_this), \"_farPos0\");\n    __publicField(_assertThisInitialized(_this), \"_cameraMatrixState0\");\n    __publicField(_assertThisInitialized(_this), \"_gizmoMatrixState0\");\n    __publicField(_assertThisInitialized(_this), \"_button\");\n    __publicField(_assertThisInitialized(_this), \"_touchStart\");\n    __publicField(_assertThisInitialized(_this), \"_touchCurrent\");\n    __publicField(_assertThisInitialized(_this), \"_input\");\n    __publicField(_assertThisInitialized(_this), \"_switchSensibility\");\n    __publicField(_assertThisInitialized(_this), \"_startFingerDistance\");\n    __publicField(_assertThisInitialized(_this), \"_currentFingerDistance\");\n    __publicField(_assertThisInitialized(_this), \"_startFingerRotation\");\n    __publicField(_assertThisInitialized(_this), \"_currentFingerRotation\");\n    __publicField(_assertThisInitialized(_this), \"_devPxRatio\");\n    __publicField(_assertThisInitialized(_this), \"_downValid\");\n    __publicField(_assertThisInitialized(_this), \"_nclicks\");\n    __publicField(_assertThisInitialized(_this), \"_downEvents\");\n    __publicField(_assertThisInitialized(_this), \"_clickStart\");\n    __publicField(_assertThisInitialized(_this), \"_maxDownTime\");\n    __publicField(_assertThisInitialized(_this), \"_maxInterval\");\n    __publicField(_assertThisInitialized(_this), \"_posThreshold\");\n    __publicField(_assertThisInitialized(_this), \"_movementThreshold\");\n    __publicField(_assertThisInitialized(_this), \"_currentCursorPosition\");\n    __publicField(_assertThisInitialized(_this), \"_startCursorPosition\");\n    __publicField(_assertThisInitialized(_this), \"_grid\");\n    __publicField(_assertThisInitialized(_this), \"_gridPosition\");\n    __publicField(_assertThisInitialized(_this), \"_gizmos\");\n    __publicField(_assertThisInitialized(_this), \"_curvePts\");\n    __publicField(_assertThisInitialized(_this), \"_timeStart\");\n    __publicField(_assertThisInitialized(_this), \"_animationId\");\n    __publicField(_assertThisInitialized(_this), \"focusAnimationTime\");\n    __publicField(_assertThisInitialized(_this), \"_timePrev\");\n    __publicField(_assertThisInitialized(_this), \"_timeCurrent\");\n    __publicField(_assertThisInitialized(_this), \"_anglePrev\");\n    __publicField(_assertThisInitialized(_this), \"_angleCurrent\");\n    __publicField(_assertThisInitialized(_this), \"_cursorPosPrev\");\n    __publicField(_assertThisInitialized(_this), \"_cursorPosCurr\");\n    __publicField(_assertThisInitialized(_this), \"_wPrev\");\n    __publicField(_assertThisInitialized(_this), \"_wCurr\");\n    __publicField(_assertThisInitialized(_this), \"adjustNearFar\");\n    __publicField(_assertThisInitialized(_this), \"scaleFactor\");\n    __publicField(_assertThisInitialized(_this), \"dampingFactor\");\n    __publicField(_assertThisInitialized(_this), \"wMax\");\n    __publicField(_assertThisInitialized(_this), \"enableAnimations\");\n    __publicField(_assertThisInitialized(_this), \"enableGrid\");\n    __publicField(_assertThisInitialized(_this), \"cursorZoom\");\n    __publicField(_assertThisInitialized(_this), \"minFov\");\n    __publicField(_assertThisInitialized(_this), \"maxFov\");\n    __publicField(_assertThisInitialized(_this), \"enabled\");\n    __publicField(_assertThisInitialized(_this), \"enablePan\");\n    __publicField(_assertThisInitialized(_this), \"enableRotate\");\n    __publicField(_assertThisInitialized(_this), \"enableZoom\");\n    __publicField(_assertThisInitialized(_this), \"minDistance\");\n    __publicField(_assertThisInitialized(_this), \"maxDistance\");\n    __publicField(_assertThisInitialized(_this), \"minZoom\");\n    __publicField(_assertThisInitialized(_this), \"maxZoom\");\n    __publicField(_assertThisInitialized(_this), \"target\");\n    __publicField(_assertThisInitialized(_this), \"_currentTarget\");\n    __publicField(_assertThisInitialized(_this), \"_tbRadius\");\n    __publicField(_assertThisInitialized(_this), \"_state\");\n    //listeners\n    __publicField(_assertThisInitialized(_this), \"onWindowResize\", function () {\n      var scale = (_this._gizmos.scale.x + _this._gizmos.scale.y + _this._gizmos.scale.z) / 3;\n      if (_this.camera) {\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n      }\n      var newRadius = _this._tbRadius / scale;\n      var curve = new EllipseCurve(0, 0, newRadius, newRadius);\n      var points = curve.getPoints(_this._curvePts);\n      var curveGeometry = new BufferGeometry().setFromPoints(points);\n      for (var gizmo in _this._gizmos.children) {\n        var child = _this._gizmos.children[gizmo];\n        child.geometry = curveGeometry;\n      }\n      _this.dispatchEvent(_changeEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onContextMenu\", function (event) {\n      if (!_this.enabled) {\n        return;\n      }\n      for (var i = 0; i < _this.mouseActions.length; i++) {\n        if (_this.mouseActions[i].mouse == 2) {\n          event.preventDefault();\n          break;\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPointerCancel\", function () {\n      _this._touchStart.splice(0, _this._touchStart.length);\n      _this._touchCurrent.splice(0, _this._touchCurrent.length);\n      _this._input = INPUT.NONE;\n    });\n    __publicField(_assertThisInitialized(_this), \"onPointerDown\", function (event) {\n      if (event.button == 0 && event.isPrimary) {\n        _this._downValid = true;\n        _this._downEvents.push(event);\n      } else {\n        _this._downValid = false;\n      }\n      if (event.pointerType == \"touch\" && _this._input != INPUT.CURSOR) {\n        _this._touchStart.push(event);\n        _this._touchCurrent.push(event);\n        switch (_this._input) {\n          case INPUT.NONE:\n            _this._input = INPUT.ONE_FINGER;\n            _this.onSinglePanStart(event, \"ROTATE\");\n            window.addEventListener(\"pointermove\", _this.onPointerMove);\n            window.addEventListener(\"pointerup\", _this.onPointerUp);\n            break;\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            _this._input = INPUT.TWO_FINGER;\n            _this.onRotateStart();\n            _this.onPinchStart();\n            _this.onDoublePanStart();\n            break;\n          case INPUT.TWO_FINGER:\n            _this._input = INPUT.MULT_FINGER;\n            _this.onTriplePanStart();\n            break;\n        }\n      } else if (event.pointerType != \"touch\" && _this._input == INPUT.NONE) {\n        var modifier = null;\n        if (event.ctrlKey || event.metaKey) {\n          modifier = \"CTRL\";\n        } else if (event.shiftKey) {\n          modifier = \"SHIFT\";\n        }\n        _this._mouseOp = _this.getOpFromAction(event.button, modifier);\n        if (_this._mouseOp) {\n          window.addEventListener(\"pointermove\", _this.onPointerMove);\n          window.addEventListener(\"pointerup\", _this.onPointerUp);\n          _this._input = INPUT.CURSOR;\n          _this._button = event.button;\n          _this.onSinglePanStart(event, _this._mouseOp);\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPointerMove\", function (event) {\n      if (event.pointerType == \"touch\" && _this._input != INPUT.CURSOR) {\n        switch (_this._input) {\n          case INPUT.ONE_FINGER:\n            _this.updateTouchEvent(event);\n            _this.onSinglePanMove(event, STATE.ROTATE);\n            break;\n          case INPUT.ONE_FINGER_SWITCHED:\n            var movement = _this.calculatePointersDistance(_this._touchCurrent[0], event) * _this._devPxRatio;\n            if (movement >= _this._switchSensibility) {\n              _this._input = INPUT.ONE_FINGER;\n              _this.updateTouchEvent(event);\n              _this.onSinglePanStart(event, \"ROTATE\");\n              break;\n            }\n            break;\n          case INPUT.TWO_FINGER:\n            _this.updateTouchEvent(event);\n            _this.onRotateMove();\n            _this.onPinchMove();\n            _this.onDoublePanMove();\n            break;\n          case INPUT.MULT_FINGER:\n            _this.updateTouchEvent(event);\n            _this.onTriplePanMove();\n            break;\n        }\n      } else if (event.pointerType != \"touch\" && _this._input == INPUT.CURSOR) {\n        var modifier = null;\n        if (event.ctrlKey || event.metaKey) {\n          modifier = \"CTRL\";\n        } else if (event.shiftKey) {\n          modifier = \"SHIFT\";\n        }\n        var mouseOpState = _this.getOpStateFromAction(_this._button, modifier);\n        if (mouseOpState) {\n          _this.onSinglePanMove(event, mouseOpState);\n        }\n      }\n      if (_this._downValid) {\n        var _movement = _this.calculatePointersDistance(_this._downEvents[_this._downEvents.length - 1], event) * _this._devPxRatio;\n        if (_movement > _this._movementThreshold) {\n          _this._downValid = false;\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPointerUp\", function (event) {\n      if (event.pointerType == \"touch\" && _this._input != INPUT.CURSOR) {\n        var nTouch = _this._touchCurrent.length;\n        for (var i = 0; i < nTouch; i++) {\n          if (_this._touchCurrent[i].pointerId == event.pointerId) {\n            _this._touchCurrent.splice(i, 1);\n            _this._touchStart.splice(i, 1);\n            break;\n          }\n        }\n        switch (_this._input) {\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            window.removeEventListener(\"pointermove\", _this.onPointerMove);\n            window.removeEventListener(\"pointerup\", _this.onPointerUp);\n            _this._input = INPUT.NONE;\n            _this.onSinglePanEnd();\n            break;\n          case INPUT.TWO_FINGER:\n            _this.onDoublePanEnd();\n            _this.onPinchEnd();\n            _this.onRotateEnd();\n            _this._input = INPUT.ONE_FINGER_SWITCHED;\n            break;\n          case INPUT.MULT_FINGER:\n            if (_this._touchCurrent.length == 0) {\n              window.removeEventListener(\"pointermove\", _this.onPointerMove);\n              window.removeEventListener(\"pointerup\", _this.onPointerUp);\n              _this._input = INPUT.NONE;\n              _this.onTriplePanEnd();\n            }\n            break;\n        }\n      } else if (event.pointerType != \"touch\" && _this._input == INPUT.CURSOR) {\n        window.removeEventListener(\"pointermove\", _this.onPointerMove);\n        window.removeEventListener(\"pointerup\", _this.onPointerUp);\n        _this._input = INPUT.NONE;\n        _this.onSinglePanEnd();\n        _this._button = -1;\n      }\n      if (event.isPrimary) {\n        if (_this._downValid) {\n          var downTime = event.timeStamp - _this._downEvents[_this._downEvents.length - 1].timeStamp;\n          if (downTime <= _this._maxDownTime) {\n            if (_this._nclicks == 0) {\n              _this._nclicks = 1;\n              _this._clickStart = performance.now();\n            } else {\n              var clickInterval = event.timeStamp - _this._clickStart;\n              var movement = _this.calculatePointersDistance(_this._downEvents[1], _this._downEvents[0]) * _this._devPxRatio;\n              if (clickInterval <= _this._maxInterval && movement <= _this._posThreshold) {\n                _this._nclicks = 0;\n                _this._downEvents.splice(0, _this._downEvents.length);\n                _this.onDoubleTap(event);\n              } else {\n                _this._nclicks = 1;\n                _this._downEvents.shift();\n                _this._clickStart = performance.now();\n              }\n            }\n          } else {\n            _this._downValid = false;\n            _this._nclicks = 0;\n            _this._downEvents.splice(0, _this._downEvents.length);\n          }\n        } else {\n          _this._nclicks = 0;\n          _this._downEvents.splice(0, _this._downEvents.length);\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onWheel\", function (event) {\n      var _a, _b;\n      if (_this.enabled && _this.enableZoom && _this.domElement) {\n        var modifier = null;\n        if (event.ctrlKey || event.metaKey) {\n          modifier = \"CTRL\";\n        } else if (event.shiftKey) {\n          modifier = \"SHIFT\";\n        }\n        var mouseOp = _this.getOpFromAction(\"WHEEL\", modifier);\n        if (mouseOp) {\n          event.preventDefault();\n          _this.dispatchEvent(_startEvent);\n          var notchDeltaY = 125;\n          var sgn = event.deltaY / notchDeltaY;\n          var size = 1;\n          if (sgn > 0) {\n            size = 1 / _this.scaleFactor;\n          } else if (sgn < 0) {\n            size = _this.scaleFactor;\n          }\n          switch (mouseOp) {\n            case \"ZOOM\":\n              _this.updateTbState(STATE.SCALE, true);\n              if (sgn > 0) {\n                size = 1 / Math.pow(_this.scaleFactor, sgn);\n              } else if (sgn < 0) {\n                size = Math.pow(_this.scaleFactor, -sgn);\n              }\n              if (_this.cursorZoom && _this.enablePan) {\n                var scalePoint;\n                if (_this.camera instanceof OrthographicCamera) {\n                  scalePoint = (_a = _this.unprojectOnTbPlane(_this.camera, event.clientX, event.clientY, _this.domElement)) == null ? void 0 : _a.applyQuaternion(_this.camera.quaternion).multiplyScalar(1 / _this.camera.zoom).add(_this._gizmos.position);\n                }\n                if (_this.camera instanceof PerspectiveCamera) {\n                  scalePoint = (_b = _this.unprojectOnTbPlane(_this.camera, event.clientX, event.clientY, _this.domElement)) == null ? void 0 : _b.applyQuaternion(_this.camera.quaternion).add(_this._gizmos.position);\n                }\n                if (scalePoint !== void 0) _this.applyTransformMatrix(_this.applyScale(size, scalePoint));\n              } else {\n                _this.applyTransformMatrix(_this.applyScale(size, _this._gizmos.position));\n              }\n              if (_this._grid) {\n                _this.disposeGrid();\n                _this.drawGrid();\n              }\n              _this.updateTbState(STATE.IDLE, false);\n              _this.dispatchEvent(_changeEvent);\n              _this.dispatchEvent(_endEvent);\n              break;\n            case \"FOV\":\n              if (_this.camera instanceof PerspectiveCamera) {\n                _this.updateTbState(STATE.FOV, true);\n                if (event.deltaX != 0) {\n                  sgn = event.deltaX / notchDeltaY;\n                  size = 1;\n                  if (sgn > 0) {\n                    size = 1 / Math.pow(_this.scaleFactor, sgn);\n                  } else if (sgn < 0) {\n                    size = Math.pow(_this.scaleFactor, -sgn);\n                  }\n                }\n                _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState);\n                var x = _this._v3_1.distanceTo(_this._gizmos.position);\n                var xNew = x / size;\n                xNew = MathUtils.clamp(xNew, _this.minDistance, _this.maxDistance);\n                var y = x * Math.tan(MathUtils.DEG2RAD * _this.camera.fov * 0.5);\n                var newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n                if (newFov > _this.maxFov) {\n                  newFov = _this.maxFov;\n                } else if (newFov < _this.minFov) {\n                  newFov = _this.minFov;\n                }\n                var newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n                _this.setFov(newFov);\n                _this.applyTransformMatrix(_this.applyScale(size, _this._gizmos.position, false));\n              }\n              if (_this._grid) {\n                _this.disposeGrid();\n                _this.drawGrid();\n              }\n              _this.updateTbState(STATE.IDLE, false);\n              _this.dispatchEvent(_changeEvent);\n              _this.dispatchEvent(_endEvent);\n              break;\n          }\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onSinglePanStart\", function (event, operation) {\n      if (_this.enabled && _this.domElement) {\n        _this.dispatchEvent(_startEvent);\n        _this.setCenter(event.clientX, event.clientY);\n        switch (operation) {\n          case \"PAN\":\n            if (!_this.enablePan) return;\n            if (_this._animationId != -1) {\n              cancelAnimationFrame(_this._animationId);\n              _this._animationId = -1;\n              _this._timeStart = -1;\n              _this.activateGizmos(false);\n              _this.dispatchEvent(_changeEvent);\n            }\n            if (_this.camera) {\n              _this.updateTbState(STATE.PAN, true);\n              var rayDir = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement);\n              if (rayDir !== void 0) {\n                _this._startCursorPosition.copy(rayDir);\n              }\n              if (_this.enableGrid) {\n                _this.drawGrid();\n                _this.dispatchEvent(_changeEvent);\n              }\n            }\n            break;\n          case \"ROTATE\":\n            if (!_this.enableRotate) return;\n            if (_this._animationId != -1) {\n              cancelAnimationFrame(_this._animationId);\n              _this._animationId = -1;\n              _this._timeStart = -1;\n            }\n            if (_this.camera) {\n              _this.updateTbState(STATE.ROTATE, true);\n              var _rayDir = _this.unprojectOnTbSurface(_this.camera, _center.x, _center.y, _this.domElement, _this._tbRadius);\n              if (_rayDir !== void 0) {\n                _this._startCursorPosition.copy(_rayDir);\n              }\n              _this.activateGizmos(true);\n              if (_this.enableAnimations) {\n                _this._timePrev = _this._timeCurrent = performance.now();\n                _this._angleCurrent = _this._anglePrev = 0;\n                _this._cursorPosPrev.copy(_this._startCursorPosition);\n                _this._cursorPosCurr.copy(_this._cursorPosPrev);\n                _this._wCurr = 0;\n                _this._wPrev = _this._wCurr;\n              }\n            }\n            _this.dispatchEvent(_changeEvent);\n            break;\n          case \"FOV\":\n            if (!_this.enableZoom) return;\n            if (_this.camera instanceof PerspectiveCamera) {\n              if (_this._animationId != -1) {\n                cancelAnimationFrame(_this._animationId);\n                _this._animationId = -1;\n                _this._timeStart = -1;\n                _this.activateGizmos(false);\n                _this.dispatchEvent(_changeEvent);\n              }\n              _this.updateTbState(STATE.FOV, true);\n              _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n              _this._currentCursorPosition.copy(_this._startCursorPosition);\n            }\n            break;\n          case \"ZOOM\":\n            if (!_this.enableZoom) return;\n            if (_this._animationId != -1) {\n              cancelAnimationFrame(_this._animationId);\n              _this._animationId = -1;\n              _this._timeStart = -1;\n              _this.activateGizmos(false);\n              _this.dispatchEvent(_changeEvent);\n            }\n            _this.updateTbState(STATE.SCALE, true);\n            _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n            _this._currentCursorPosition.copy(_this._startCursorPosition);\n            break;\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onSinglePanMove\", function (event, opState) {\n      if (_this.enabled && _this.domElement) {\n        var restart = opState != _this._state;\n        _this.setCenter(event.clientX, event.clientY);\n        switch (opState) {\n          case STATE.PAN:\n            if (_this.enablePan && _this.camera) {\n              if (restart) {\n                _this.dispatchEvent(_endEvent);\n                _this.dispatchEvent(_startEvent);\n                _this.updateTbState(opState, true);\n                var rayDir = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement);\n                if (rayDir !== void 0) {\n                  _this._startCursorPosition.copy(rayDir);\n                }\n                if (_this.enableGrid) {\n                  _this.drawGrid();\n                }\n                _this.activateGizmos(false);\n              } else {\n                var _rayDir2 = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement);\n                if (_rayDir2 !== void 0) {\n                  _this._currentCursorPosition.copy(_rayDir2);\n                }\n                _this.applyTransformMatrix(_this.pan(_this._startCursorPosition, _this._currentCursorPosition));\n              }\n            }\n            break;\n          case STATE.ROTATE:\n            if (_this.enableRotate && _this.camera) {\n              if (restart) {\n                _this.dispatchEvent(_endEvent);\n                _this.dispatchEvent(_startEvent);\n                _this.updateTbState(opState, true);\n                var _rayDir3 = _this.unprojectOnTbSurface(_this.camera, _center.x, _center.y, _this.domElement, _this._tbRadius);\n                if (_rayDir3 !== void 0) {\n                  _this._startCursorPosition.copy(_rayDir3);\n                }\n                if (_this.enableGrid) {\n                  _this.disposeGrid();\n                }\n                _this.activateGizmos(true);\n              } else {\n                var _rayDir4 = _this.unprojectOnTbSurface(_this.camera, _center.x, _center.y, _this.domElement, _this._tbRadius);\n                if (_rayDir4 !== void 0) {\n                  _this._currentCursorPosition.copy(_rayDir4);\n                }\n                var distance = _this._startCursorPosition.distanceTo(_this._currentCursorPosition);\n                var angle = _this._startCursorPosition.angleTo(_this._currentCursorPosition);\n                var amount = Math.max(distance / _this._tbRadius, angle);\n                _this.applyTransformMatrix(_this.rotate(_this.calculateRotationAxis(_this._startCursorPosition, _this._currentCursorPosition), amount));\n                if (_this.enableAnimations) {\n                  _this._timePrev = _this._timeCurrent;\n                  _this._timeCurrent = performance.now();\n                  _this._anglePrev = _this._angleCurrent;\n                  _this._angleCurrent = amount;\n                  _this._cursorPosPrev.copy(_this._cursorPosCurr);\n                  _this._cursorPosCurr.copy(_this._currentCursorPosition);\n                  _this._wPrev = _this._wCurr;\n                  _this._wCurr = _this.calculateAngularSpeed(_this._anglePrev, _this._angleCurrent, _this._timePrev, _this._timeCurrent);\n                }\n              }\n            }\n            break;\n          case STATE.SCALE:\n            if (_this.enableZoom) {\n              if (restart) {\n                _this.dispatchEvent(_endEvent);\n                _this.dispatchEvent(_startEvent);\n                _this.updateTbState(opState, true);\n                _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n                _this._currentCursorPosition.copy(_this._startCursorPosition);\n                if (_this.enableGrid) {\n                  _this.disposeGrid();\n                }\n                _this.activateGizmos(false);\n              } else {\n                var screenNotches = 8;\n                _this._currentCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n                var movement = _this._currentCursorPosition.y - _this._startCursorPosition.y;\n                var size = 1;\n                if (movement < 0) {\n                  size = 1 / Math.pow(_this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(_this.scaleFactor, movement * screenNotches);\n                }\n                _this.applyTransformMatrix(_this.applyScale(size, _this._gizmos.position));\n              }\n            }\n            break;\n          case STATE.FOV:\n            if (_this.enableZoom && _this.camera instanceof PerspectiveCamera) {\n              if (restart) {\n                _this.dispatchEvent(_endEvent);\n                _this.dispatchEvent(_startEvent);\n                _this.updateTbState(opState, true);\n                _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n                _this._currentCursorPosition.copy(_this._startCursorPosition);\n                if (_this.enableGrid) {\n                  _this.disposeGrid();\n                }\n                _this.activateGizmos(false);\n              } else {\n                var _screenNotches = 8;\n                _this._currentCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n                var _movement2 = _this._currentCursorPosition.y - _this._startCursorPosition.y;\n                var _size = 1;\n                if (_movement2 < 0) {\n                  _size = 1 / Math.pow(_this.scaleFactor, -_movement2 * _screenNotches);\n                } else if (_movement2 > 0) {\n                  _size = Math.pow(_this.scaleFactor, _movement2 * _screenNotches);\n                }\n                _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState);\n                var x = _this._v3_1.distanceTo(_this._gizmos.position);\n                var xNew = x / _size;\n                xNew = MathUtils.clamp(xNew, _this.minDistance, _this.maxDistance);\n                var y = x * Math.tan(MathUtils.DEG2RAD * _this._fovState * 0.5);\n                var newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n                newFov = MathUtils.clamp(newFov, _this.minFov, _this.maxFov);\n                var newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                _size = x / newDistance;\n                _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState);\n                _this.setFov(newFov);\n                _this.applyTransformMatrix(_this.applyScale(_size, _this._v3_2, false));\n                var direction = _this._gizmos.position.clone().sub(_this.camera.position).normalize().multiplyScalar(newDistance / x);\n                _this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n              }\n            }\n            break;\n        }\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onSinglePanEnd\", function () {\n      if (_this._state == STATE.ROTATE) {\n        if (!_this.enableRotate) {\n          return;\n        }\n        if (_this.enableAnimations) {\n          var deltaTime = performance.now() - _this._timeCurrent;\n          if (deltaTime < 120) {\n            var w = Math.abs((_this._wPrev + _this._wCurr) / 2);\n            var self = _assertThisInitialized(_this);\n            _this._animationId = window.requestAnimationFrame(function (t) {\n              self.updateTbState(STATE.ANIMATION_ROTATE, true);\n              var rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\n              self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\n            });\n          } else {\n            _this.updateTbState(STATE.IDLE, false);\n            _this.activateGizmos(false);\n            _this.dispatchEvent(_changeEvent);\n          }\n        } else {\n          _this.updateTbState(STATE.IDLE, false);\n          _this.activateGizmos(false);\n          _this.dispatchEvent(_changeEvent);\n        }\n      } else if (_this._state == STATE.PAN || _this._state == STATE.IDLE) {\n        _this.updateTbState(STATE.IDLE, false);\n        if (_this.enableGrid) {\n          _this.disposeGrid();\n        }\n        _this.activateGizmos(false);\n        _this.dispatchEvent(_changeEvent);\n      }\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onDoubleTap\", function (event) {\n      if (_this.enabled && _this.enablePan && _this.scene && _this.camera && _this.domElement) {\n        _this.dispatchEvent(_startEvent);\n        _this.setCenter(event.clientX, event.clientY);\n        var hitP = _this.unprojectOnObj(_this.getCursorNDC(_center.x, _center.y, _this.domElement), _this.camera);\n        if (hitP && _this.enableAnimations) {\n          var self = _assertThisInitialized(_this);\n          if (_this._animationId != -1) {\n            window.cancelAnimationFrame(_this._animationId);\n          }\n          _this._timeStart = -1;\n          _this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_FOCUS, true);\n            self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\n          });\n        } else if (hitP && !_this.enableAnimations) {\n          _this.updateTbState(STATE.FOCUS, true);\n          _this.focus(hitP, _this.scaleFactor);\n          _this.updateTbState(STATE.IDLE, false);\n          _this.dispatchEvent(_changeEvent);\n        }\n      }\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onDoublePanStart\", function () {\n      if (_this.enabled && _this.enablePan && _this.camera && _this.domElement) {\n        _this.dispatchEvent(_startEvent);\n        _this.updateTbState(STATE.PAN, true);\n        _this.setCenter((_this._touchCurrent[0].clientX + _this._touchCurrent[1].clientX) / 2, (_this._touchCurrent[0].clientY + _this._touchCurrent[1].clientY) / 2);\n        var rayDir = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement, true);\n        if (rayDir !== void 0) {\n          _this._startCursorPosition.copy(rayDir);\n        }\n        _this._currentCursorPosition.copy(_this._startCursorPosition);\n        _this.activateGizmos(false);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onDoublePanMove\", function () {\n      if (_this.enabled && _this.enablePan && _this.camera && _this.domElement) {\n        _this.setCenter((_this._touchCurrent[0].clientX + _this._touchCurrent[1].clientX) / 2, (_this._touchCurrent[0].clientY + _this._touchCurrent[1].clientY) / 2);\n        if (_this._state != STATE.PAN) {\n          _this.updateTbState(STATE.PAN, true);\n          _this._startCursorPosition.copy(_this._currentCursorPosition);\n        }\n        var rayDir = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement, true);\n        if (rayDir !== void 0) _this._currentCursorPosition.copy(rayDir);\n        _this.applyTransformMatrix(_this.pan(_this._startCursorPosition, _this._currentCursorPosition, true));\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onDoublePanEnd\", function () {\n      _this.updateTbState(STATE.IDLE, false);\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onRotateStart\", function () {\n      var _a;\n      if (_this.enabled && _this.enableRotate) {\n        _this.dispatchEvent(_startEvent);\n        _this.updateTbState(STATE.ZROTATE, true);\n        _this._startFingerRotation = _this.getAngle(_this._touchCurrent[1], _this._touchCurrent[0]) + _this.getAngle(_this._touchStart[1], _this._touchStart[0]);\n        _this._currentFingerRotation = _this._startFingerRotation;\n        (_a = _this.camera) == null ? void 0 : _a.getWorldDirection(_this._rotationAxis);\n        if (!_this.enablePan && !_this.enableZoom) {\n          _this.activateGizmos(true);\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onRotateMove\", function () {\n      var _a;\n      if (_this.enabled && _this.enableRotate && _this.camera && _this.domElement) {\n        _this.setCenter((_this._touchCurrent[0].clientX + _this._touchCurrent[1].clientX) / 2, (_this._touchCurrent[0].clientY + _this._touchCurrent[1].clientY) / 2);\n        var rotationPoint;\n        if (_this._state != STATE.ZROTATE) {\n          _this.updateTbState(STATE.ZROTATE, true);\n          _this._startFingerRotation = _this._currentFingerRotation;\n        }\n        _this._currentFingerRotation = _this.getAngle(_this._touchCurrent[1], _this._touchCurrent[0]) + _this.getAngle(_this._touchStart[1], _this._touchStart[0]);\n        if (!_this.enablePan) {\n          rotationPoint = new Vector3().setFromMatrixPosition(_this._gizmoMatrixState);\n        } else if (_this.camera) {\n          _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState);\n          rotationPoint = (_a = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement)) == null ? void 0 : _a.applyQuaternion(_this.camera.quaternion).multiplyScalar(1 / _this.camera.zoom).add(_this._v3_2);\n        }\n        var amount = MathUtils.DEG2RAD * (_this._startFingerRotation - _this._currentFingerRotation);\n        if (rotationPoint !== void 0) {\n          _this.applyTransformMatrix(_this.zRotate(rotationPoint, amount));\n        }\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onRotateEnd\", function () {\n      _this.updateTbState(STATE.IDLE, false);\n      _this.activateGizmos(false);\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onPinchStart\", function () {\n      if (_this.enabled && _this.enableZoom) {\n        _this.dispatchEvent(_startEvent);\n        _this.updateTbState(STATE.SCALE, true);\n        _this._startFingerDistance = _this.calculatePointersDistance(_this._touchCurrent[0], _this._touchCurrent[1]);\n        _this._currentFingerDistance = _this._startFingerDistance;\n        _this.activateGizmos(false);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPinchMove\", function () {\n      var _a, _b;\n      if (_this.enabled && _this.enableZoom && _this.domElement) {\n        _this.setCenter((_this._touchCurrent[0].clientX + _this._touchCurrent[1].clientX) / 2, (_this._touchCurrent[0].clientY + _this._touchCurrent[1].clientY) / 2);\n        var minDistance = 12;\n        if (_this._state != STATE.SCALE) {\n          _this._startFingerDistance = _this._currentFingerDistance;\n          _this.updateTbState(STATE.SCALE, true);\n        }\n        _this._currentFingerDistance = Math.max(_this.calculatePointersDistance(_this._touchCurrent[0], _this._touchCurrent[1]), minDistance * _this._devPxRatio);\n        var amount = _this._currentFingerDistance / _this._startFingerDistance;\n        var scalePoint;\n        if (!_this.enablePan) {\n          scalePoint = _this._gizmos.position;\n        } else {\n          if (_this.camera instanceof OrthographicCamera) {\n            scalePoint = (_a = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement)) == null ? void 0 : _a.applyQuaternion(_this.camera.quaternion).multiplyScalar(1 / _this.camera.zoom).add(_this._gizmos.position);\n          } else if (_this.camera instanceof PerspectiveCamera) {\n            scalePoint = (_b = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement)) == null ? void 0 : _b.applyQuaternion(_this.camera.quaternion).add(_this._gizmos.position);\n          }\n        }\n        if (scalePoint !== void 0) {\n          _this.applyTransformMatrix(_this.applyScale(amount, scalePoint));\n        }\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPinchEnd\", function () {\n      _this.updateTbState(STATE.IDLE, false);\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onTriplePanStart\", function () {\n      if (_this.enabled && _this.enableZoom && _this.domElement) {\n        _this.dispatchEvent(_startEvent);\n        _this.updateTbState(STATE.SCALE, true);\n        var clientX = 0;\n        var clientY = 0;\n        var nFingers = _this._touchCurrent.length;\n        for (var i = 0; i < nFingers; i++) {\n          clientX += _this._touchCurrent[i].clientX;\n          clientY += _this._touchCurrent[i].clientY;\n        }\n        _this.setCenter(clientX / nFingers, clientY / nFingers);\n        _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n        _this._currentCursorPosition.copy(_this._startCursorPosition);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onTriplePanMove\", function () {\n      if (_this.enabled && _this.enableZoom && _this.camera && _this.domElement) {\n        var clientX = 0;\n        var clientY = 0;\n        var nFingers = _this._touchCurrent.length;\n        for (var i = 0; i < nFingers; i++) {\n          clientX += _this._touchCurrent[i].clientX;\n          clientY += _this._touchCurrent[i].clientY;\n        }\n        _this.setCenter(clientX / nFingers, clientY / nFingers);\n        var screenNotches = 8;\n        _this._currentCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n        var movement = _this._currentCursorPosition.y - _this._startCursorPosition.y;\n        var size = 1;\n        if (movement < 0) {\n          size = 1 / Math.pow(_this.scaleFactor, -movement * screenNotches);\n        } else if (movement > 0) {\n          size = Math.pow(_this.scaleFactor, movement * screenNotches);\n        }\n        _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState);\n        var x = _this._v3_1.distanceTo(_this._gizmos.position);\n        var xNew = x / size;\n        xNew = MathUtils.clamp(xNew, _this.minDistance, _this.maxDistance);\n        var y = x * Math.tan(MathUtils.DEG2RAD * _this._fovState * 0.5);\n        var newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n        newFov = MathUtils.clamp(newFov, _this.minFov, _this.maxFov);\n        var newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n        size = x / newDistance;\n        _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState);\n        _this.setFov(newFov);\n        _this.applyTransformMatrix(_this.applyScale(size, _this._v3_2, false));\n        var direction = _this._gizmos.position.clone().sub(_this.camera.position).normalize().multiplyScalar(newDistance / x);\n        _this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onTriplePanEnd\", function () {\n      _this.updateTbState(STATE.IDLE, false);\n      _this.dispatchEvent(_endEvent);\n    });\n    /**\n     * Set _center's x/y coordinates\n     * @param {Number} clientX\n     * @param {Number} clientY\n     */\n    __publicField(_assertThisInitialized(_this), \"setCenter\", function (clientX, clientY) {\n      _center.x = clientX;\n      _center.y = clientY;\n    });\n    /**\n     * Set default mouse actions\n     */\n    __publicField(_assertThisInitialized(_this), \"initializeMouseActions\", function () {\n      _this.setMouseAction(\"PAN\", 0, \"CTRL\");\n      _this.setMouseAction(\"PAN\", 2);\n      _this.setMouseAction(\"ROTATE\", 0);\n      _this.setMouseAction(\"ZOOM\", \"WHEEL\");\n      _this.setMouseAction(\"ZOOM\", 1);\n      _this.setMouseAction(\"FOV\", \"WHEEL\", \"SHIFT\");\n      _this.setMouseAction(\"FOV\", 1, \"SHIFT\");\n    });\n    /**\n     * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n     * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n     * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n     * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n     * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n     */\n    __publicField(_assertThisInitialized(_this), \"setMouseAction\", function (operation, mouse) {\n      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var operationInput = [\"PAN\", \"ROTATE\", \"ZOOM\", \"FOV\"];\n      var mouseInput = [0, 1, 2, \"WHEEL\"];\n      var keyInput = [\"CTRL\", \"SHIFT\", null];\n      var state;\n      if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n        return false;\n      }\n      if (mouse == \"WHEEL\") {\n        if (operation != \"ZOOM\" && operation != \"FOV\") {\n          return false;\n        }\n      }\n      switch (operation) {\n        case \"PAN\":\n          state = STATE.PAN;\n          break;\n        case \"ROTATE\":\n          state = STATE.ROTATE;\n          break;\n        case \"ZOOM\":\n          state = STATE.SCALE;\n          break;\n        case \"FOV\":\n          state = STATE.FOV;\n          break;\n      }\n      var action = {\n        operation: operation,\n        mouse: mouse,\n        key: key,\n        state: state\n      };\n      for (var i = 0; i < _this.mouseActions.length; i++) {\n        if (_this.mouseActions[i].mouse == action.mouse && _this.mouseActions[i].key == action.key) {\n          _this.mouseActions.splice(i, 1, action);\n          return true;\n        }\n      }\n      _this.mouseActions.push(action);\n      return true;\n    });\n    /**\n     * Return the operation associated to a mouse/keyboard combination\n     * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n     * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n     * @returns The operation if it has been found, null otherwise\n     */\n    __publicField(_assertThisInitialized(_this), \"getOpFromAction\", function (mouse, key) {\n      var action;\n      for (var i = 0; i < _this.mouseActions.length; i++) {\n        action = _this.mouseActions[i];\n        if (action.mouse == mouse && action.key == key) {\n          return action.operation;\n        }\n      }\n      if (key) {\n        for (var _i = 0; _i < _this.mouseActions.length; _i++) {\n          action = _this.mouseActions[_i];\n          if (action.mouse == mouse && action.key == null) {\n            return action.operation;\n          }\n        }\n      }\n      return null;\n    });\n    /**\n     * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n     * @param {Number} mouse Mouse button\n     * @param {String} key Keyboard modifier\n     * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n     */\n    __publicField(_assertThisInitialized(_this), \"getOpStateFromAction\", function (mouse, key) {\n      var action;\n      for (var i = 0; i < _this.mouseActions.length; i++) {\n        action = _this.mouseActions[i];\n        if (action.mouse == mouse && action.key == key) {\n          return action.state;\n        }\n      }\n      if (key) {\n        for (var _i2 = 0; _i2 < _this.mouseActions.length; _i2++) {\n          action = _this.mouseActions[_i2];\n          if (action.mouse == mouse && action.key == null) {\n            return action.state;\n          }\n        }\n      }\n      return null;\n    });\n    /**\n     * Calculate the angle between two pointers\n     * @param {PointerEvent} p1\n     * @param {PointerEvent} p2\n     * @returns {Number} The angle between two pointers in degrees\n     */\n    __publicField(_assertThisInitialized(_this), \"getAngle\", function (p1, p2) {\n      return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\n    });\n    /**\n     * Update a PointerEvent inside current pointerevents array\n     * @param {PointerEvent} event\n     */\n    __publicField(_assertThisInitialized(_this), \"updateTouchEvent\", function (event) {\n      for (var i = 0; i < _this._touchCurrent.length; i++) {\n        if (_this._touchCurrent[i].pointerId == event.pointerId) {\n          _this._touchCurrent.splice(i, 1, event);\n          break;\n        }\n      }\n    });\n    /**\n     * Calculate the angular speed\n     * @param {Number} p0 Position at t0\n     * @param {Number} p1 Position at t1\n     * @param {Number} t0 Initial time in milliseconds\n     * @param {Number} t1 Ending time in milliseconds\n     */\n    __publicField(_assertThisInitialized(_this), \"calculateAngularSpeed\", function (p0, p1, t0, t1) {\n      var s = p1 - p0;\n      var t = (t1 - t0) / 1e3;\n      if (t == 0) {\n        return 0;\n      }\n      return s / t;\n    });\n    /**\n     * Calculate the distance between two pointers\n     * @param {PointerEvent} p0 The first pointer\n     * @param {PointerEvent} p1 The second pointer\n     * @returns {number} The distance between the two pointers\n     */\n    __publicField(_assertThisInitialized(_this), \"calculatePointersDistance\", function (p0, p1) {\n      return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\n    });\n    /**\n     * Calculate the rotation axis as the vector perpendicular between two vectors\n     * @param {Vector3} vec1 The first vector\n     * @param {Vector3} vec2 The second vector\n     * @returns {Vector3} The normalized rotation axis\n     */\n    __publicField(_assertThisInitialized(_this), \"calculateRotationAxis\", function (vec1, vec2) {\n      _this._rotationMatrix.extractRotation(_this._cameraMatrixState);\n      _this._quat.setFromRotationMatrix(_this._rotationMatrix);\n      _this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(_this._quat);\n      return _this._rotationAxis.normalize().clone();\n    });\n    /**\n     * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n     * @param {Camera} camera\n     * @returns {Number} The trackball radius\n     */\n    __publicField(_assertThisInitialized(_this), \"calculateTbRadius\", function (camera) {\n      var factor = 0.67;\n      var distance = camera.position.distanceTo(_this._gizmos.position);\n      if (camera instanceof PerspectiveCamera) {\n        var halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5;\n        var halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV));\n        return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor;\n      } else if (camera instanceof OrthographicCamera) {\n        return Math.min(camera.top, camera.right) * factor;\n      }\n    });\n    /**\n     * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n     * @param {Vector3} point The point of interest\n     * @param {Number} size Scale factor\n     * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n     */\n    __publicField(_assertThisInitialized(_this), \"focus\", function (point, size) {\n      var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      if (_this.camera) {\n        var focusPoint = point.clone();\n        focusPoint.sub(_this._gizmos.position).multiplyScalar(amount);\n        _this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z);\n        var gizmoStateTemp = _this._gizmoMatrixState.clone();\n        _this._gizmoMatrixState.premultiply(_this._translationMatrix);\n        _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n        var cameraStateTemp = _this._cameraMatrixState.clone();\n        _this._cameraMatrixState.premultiply(_this._translationMatrix);\n        _this._cameraMatrixState.decompose(_this.camera.position, _this.camera.quaternion, _this.camera.scale);\n        if (_this.enableZoom) {\n          _this.applyTransformMatrix(_this.applyScale(size, _this._gizmos.position));\n        }\n        _this._gizmoMatrixState.copy(gizmoStateTemp);\n        _this._cameraMatrixState.copy(cameraStateTemp);\n      }\n    });\n    /**\n     * Draw a grid and add it to the scene\n     */\n    __publicField(_assertThisInitialized(_this), \"drawGrid\", function () {\n      if (_this.scene) {\n        var color = 8947848;\n        var multiplier = 3;\n        var size, divisions, maxLength, tick;\n        if (_this.camera instanceof OrthographicCamera) {\n          var width = _this.camera.right - _this.camera.left;\n          var height = _this.camera.bottom - _this.camera.top;\n          maxLength = Math.max(width, height);\n          tick = maxLength / 20;\n          size = maxLength / _this.camera.zoom * multiplier;\n          divisions = size / tick * _this.camera.zoom;\n        } else if (_this.camera instanceof PerspectiveCamera) {\n          var distance = _this.camera.position.distanceTo(_this._gizmos.position);\n          var halfFovV = MathUtils.DEG2RAD * _this.camera.fov * 0.5;\n          var halfFovH = Math.atan(_this.camera.aspect * Math.tan(halfFovV));\n          maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\n          tick = maxLength / 20;\n          size = maxLength * multiplier;\n          divisions = size / tick;\n        }\n        if (_this._grid == null && _this.camera) {\n          _this._grid = new GridHelper(size, divisions, color, color);\n          _this._grid.position.copy(_this._gizmos.position);\n          _this._gridPosition.copy(_this._grid.position);\n          _this._grid.quaternion.copy(_this.camera.quaternion);\n          _this._grid.rotateX(Math.PI * 0.5);\n          _this.scene.add(_this._grid);\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"connect\", function (domElement) {\n      if (domElement === document) {\n        console.error('THREE.ArcballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n      }\n      _this.domElement = domElement;\n      _this.domElement.style.touchAction = \"none\";\n      _this.domElement.addEventListener(\"contextmenu\", _this.onContextMenu);\n      _this.domElement.addEventListener(\"pointerdown\", _this.onPointerDown);\n      _this.domElement.addEventListener(\"pointercancel\", _this.onPointerCancel);\n      _this.domElement.addEventListener(\"wheel\", _this.onWheel);\n    });\n    /**\n     * Remove all listeners, stop animations and clean scene\n     */\n    __publicField(_assertThisInitialized(_this), \"dispose\", function () {\n      var _a, _b, _c, _d, _e;\n      if (_this._animationId != -1) {\n        window.cancelAnimationFrame(_this._animationId);\n      }\n      (_a = _this.domElement) == null ? void 0 : _a.removeEventListener(\"pointerdown\", _this.onPointerDown);\n      (_b = _this.domElement) == null ? void 0 : _b.removeEventListener(\"pointercancel\", _this.onPointerCancel);\n      (_c = _this.domElement) == null ? void 0 : _c.removeEventListener(\"wheel\", _this.onWheel);\n      (_d = _this.domElement) == null ? void 0 : _d.removeEventListener(\"contextmenu\", _this.onContextMenu);\n      window.removeEventListener(\"pointermove\", _this.onPointerMove);\n      window.removeEventListener(\"pointerup\", _this.onPointerUp);\n      window.removeEventListener(\"resize\", _this.onWindowResize);\n      (_e = _this.scene) == null ? void 0 : _e.remove(_this._gizmos);\n      _this.disposeGrid();\n    });\n    /**\n     * remove the grid from the scene\n     */\n    __publicField(_assertThisInitialized(_this), \"disposeGrid\", function () {\n      if (_this._grid && _this.scene) {\n        _this.scene.remove(_this._grid);\n        _this._grid = null;\n      }\n    });\n    /**\n     * Compute the easing out cubic function for ease out effect in animation\n     * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n     * @returns {Number} Result of easing out cubic at time t\n     */\n    __publicField(_assertThisInitialized(_this), \"easeOutCubic\", function (t) {\n      return 1 - Math.pow(1 - t, 3);\n    });\n    /**\n     * Make rotation gizmos more or less visible\n     * @param {Boolean} isActive If true, make gizmos more visible\n     */\n    __publicField(_assertThisInitialized(_this), \"activateGizmos\", function (isActive) {\n      var _iterator = _createForOfIteratorHelper(_this._gizmos.children),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var gizmo = _step.value;\n          gizmo.material.setValues({\n            opacity: isActive ? 1 : 0.6\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n    /**\n     * Calculate the cursor position in NDC\n     * @param {number} x Cursor horizontal coordinate within the canvas\n     * @param {number} y Cursor vertical coordinate within the canvas\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @returns {Vector2} Cursor normalized position inside the canvas\n     */\n    __publicField(_assertThisInitialized(_this), \"getCursorNDC\", function (cursorX, cursorY, canvas) {\n      var canvasRect = canvas.getBoundingClientRect();\n      _this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\n      _this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\n      return _this._v2_1.clone();\n    });\n    /**\n     * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n     * @param {Number} x Cursor horizontal coordinate within the canvas\n     * @param {Number} y Cursor vertical coordinate within the canvas\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @returns {Vector2} Cursor position inside the canvas\n     */\n    __publicField(_assertThisInitialized(_this), \"getCursorPosition\", function (cursorX, cursorY, canvas) {\n      _this._v2_1.copy(_this.getCursorNDC(cursorX, cursorY, canvas));\n      if (_this.camera instanceof OrthographicCamera) {\n        _this._v2_1.x *= (_this.camera.right - _this.camera.left) * 0.5;\n        _this._v2_1.y *= (_this.camera.top - _this.camera.bottom) * 0.5;\n      }\n      return _this._v2_1.clone();\n    });\n    /**\n     * Set the camera to be controlled\n     * @param {Camera} camera The virtual camera to be controlled\n     */\n    __publicField(_assertThisInitialized(_this), \"setCamera\", function (camera) {\n      if (camera) {\n        camera.lookAt(_this.target);\n        camera.updateMatrix();\n        if (camera instanceof PerspectiveCamera) {\n          _this._fov0 = camera.fov;\n          _this._fovState = camera.fov;\n        }\n        _this._cameraMatrixState0.copy(camera.matrix);\n        _this._cameraMatrixState.copy(_this._cameraMatrixState0);\n        _this._cameraProjectionState.copy(camera.projectionMatrix);\n        _this._zoom0 = camera.zoom;\n        _this._zoomState = _this._zoom0;\n        _this._initialNear = camera.near;\n        _this._nearPos0 = camera.position.distanceTo(_this.target) - camera.near;\n        _this._nearPos = _this._initialNear;\n        _this._initialFar = camera.far;\n        _this._farPos0 = camera.position.distanceTo(_this.target) - camera.far;\n        _this._farPos = _this._initialFar;\n        _this._up0.copy(camera.up);\n        _this._upState.copy(camera.up);\n        _this.camera = camera;\n        _this.camera.updateProjectionMatrix();\n        var tbRadius = _this.calculateTbRadius(camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        _this.makeGizmos(_this.target, _this._tbRadius);\n      }\n    });\n    /**\n     * Creates the rotation gizmos matching trackball center and radius\n     * @param {Vector3} tbCenter The trackball center\n     * @param {number} tbRadius The trackball radius\n     */\n    __publicField(_assertThisInitialized(_this), \"makeGizmos\", function (tbCenter, tbRadius) {\n      var curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\n      var points = curve.getPoints(_this._curvePts);\n      var curveGeometry = new BufferGeometry().setFromPoints(points);\n      var curveMaterialX = new LineBasicMaterial({\n        color: 16744576,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      var curveMaterialY = new LineBasicMaterial({\n        color: 8454016,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      var curveMaterialZ = new LineBasicMaterial({\n        color: 8421631,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      var gizmoX = new Line(curveGeometry, curveMaterialX);\n      var gizmoY = new Line(curveGeometry, curveMaterialY);\n      var gizmoZ = new Line(curveGeometry, curveMaterialZ);\n      var rotation = Math.PI * 0.5;\n      gizmoX.rotation.x = rotation;\n      gizmoY.rotation.y = rotation;\n      _this._gizmoMatrixState0.identity().setPosition(tbCenter);\n      _this._gizmoMatrixState.copy(_this._gizmoMatrixState0);\n      if (_this.camera && _this.camera.zoom != 1) {\n        var size = 1 / _this.camera.zoom;\n        _this._scaleMatrix.makeScale(size, size, size);\n        _this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\n        _this._gizmoMatrixState.premultiply(_this._translationMatrix).premultiply(_this._scaleMatrix);\n        _this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\n        _this._gizmoMatrixState.premultiply(_this._translationMatrix);\n      }\n      _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n      _this._gizmos.clear();\n      _this._gizmos.add(gizmoX);\n      _this._gizmos.add(gizmoY);\n      _this._gizmos.add(gizmoZ);\n    });\n    /**\n     * Perform animation for focus operation\n     * @param {Number} time Instant in which this function is called as performance.now()\n     * @param {Vector3} point Point of interest for focus operation\n     * @param {Matrix4} cameraMatrix Camera matrix\n     * @param {Matrix4} gizmoMatrix Gizmos matrix\n     */\n    __publicField(_assertThisInitialized(_this), \"onFocusAnim\", function (time, point, cameraMatrix, gizmoMatrix) {\n      if (_this._timeStart == -1) {\n        _this._timeStart = time;\n      }\n      if (_this._state == STATE.ANIMATION_FOCUS) {\n        var deltaTime = time - _this._timeStart;\n        var animTime = deltaTime / _this.focusAnimationTime;\n        _this._gizmoMatrixState.copy(gizmoMatrix);\n        if (animTime >= 1) {\n          _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n          _this.focus(point, _this.scaleFactor);\n          _this._timeStart = -1;\n          _this.updateTbState(STATE.IDLE, false);\n          _this.activateGizmos(false);\n          _this.dispatchEvent(_changeEvent);\n        } else {\n          var amount = _this.easeOutCubic(animTime);\n          var size = 1 - amount + _this.scaleFactor * amount;\n          _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n          _this.focus(point, size, amount);\n          _this.dispatchEvent(_changeEvent);\n          var self = _assertThisInitialized(_this);\n          _this._animationId = window.requestAnimationFrame(function (t) {\n            self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\n          });\n        }\n      } else {\n        _this._animationId = -1;\n        _this._timeStart = -1;\n      }\n    });\n    /**\n     * Perform animation for rotation operation\n     * @param {Number} time Instant in which this function is called as performance.now()\n     * @param {Vector3} rotationAxis Rotation axis\n     * @param {number} w0 Initial angular velocity\n     */\n    __publicField(_assertThisInitialized(_this), \"onRotationAnim\", function (time, rotationAxis, w0) {\n      if (_this._timeStart == -1) {\n        _this._anglePrev = 0;\n        _this._angleCurrent = 0;\n        _this._timeStart = time;\n      }\n      if (_this._state == STATE.ANIMATION_ROTATE) {\n        var deltaTime = (time - _this._timeStart) / 1e3;\n        var w = w0 + -_this.dampingFactor * deltaTime;\n        if (w > 0) {\n          _this._angleCurrent = 0.5 * -_this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\n          _this.applyTransformMatrix(_this.rotate(rotationAxis, _this._angleCurrent));\n          _this.dispatchEvent(_changeEvent);\n          var self = _assertThisInitialized(_this);\n          _this._animationId = window.requestAnimationFrame(function (t) {\n            self.onRotationAnim(t, rotationAxis, w0);\n          });\n        } else {\n          _this._animationId = -1;\n          _this._timeStart = -1;\n          _this.updateTbState(STATE.IDLE, false);\n          _this.activateGizmos(false);\n          _this.dispatchEvent(_changeEvent);\n        }\n      } else {\n        _this._animationId = -1;\n        _this._timeStart = -1;\n        if (_this._state != STATE.ROTATE) {\n          _this.activateGizmos(false);\n          _this.dispatchEvent(_changeEvent);\n        }\n      }\n    });\n    /**\n     * Perform pan operation moving camera between two points\n     * @param {Vector3} p0 Initial point\n     * @param {Vector3} p1 Ending point\n     * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n     */\n    __publicField(_assertThisInitialized(_this), \"pan\", function (p0, p1) {\n      var adjust = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (_this.camera) {\n        var movement = p0.clone().sub(p1);\n        if (_this.camera instanceof OrthographicCamera) {\n          movement.multiplyScalar(1 / _this.camera.zoom);\n        }\n        if (_this.camera instanceof PerspectiveCamera && adjust) {\n          _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState0);\n          _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState0);\n          var distanceFactor = _this._v3_1.distanceTo(_this._v3_2) / _this.camera.position.distanceTo(_this._gizmos.position);\n          movement.multiplyScalar(1 / distanceFactor);\n        }\n        _this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(_this.camera.quaternion);\n        _this._m4_1.makeTranslation(_this._v3_1.x, _this._v3_1.y, _this._v3_1.z);\n        _this.setTransformationMatrices(_this._m4_1, _this._m4_1);\n      }\n      return _transformation;\n    });\n    /**\n     * Reset trackball\n     */\n    __publicField(_assertThisInitialized(_this), \"reset\", function () {\n      if (_this.camera) {\n        _this.camera.zoom = _this._zoom0;\n        if (_this.camera instanceof PerspectiveCamera) {\n          _this.camera.fov = _this._fov0;\n        }\n        _this.camera.near = _this._nearPos;\n        _this.camera.far = _this._farPos;\n        _this._cameraMatrixState.copy(_this._cameraMatrixState0);\n        _this._cameraMatrixState.decompose(_this.camera.position, _this.camera.quaternion, _this.camera.scale);\n        _this.camera.up.copy(_this._up0);\n        _this.camera.updateMatrix();\n        _this.camera.updateProjectionMatrix();\n        _this._gizmoMatrixState.copy(_this._gizmoMatrixState0);\n        _this._gizmoMatrixState0.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n        _this._gizmos.updateMatrix();\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        _this.makeGizmos(_this._gizmos.position, _this._tbRadius);\n        _this.camera.lookAt(_this._gizmos.position);\n        _this.updateTbState(STATE.IDLE, false);\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    /**\n     * Rotate the camera around an axis passing by trackball's center\n     * @param {Vector3} axis Rotation axis\n     * @param {number} angle Angle in radians\n     * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n     */\n    __publicField(_assertThisInitialized(_this), \"rotate\", function (axis, angle) {\n      var point = _this._gizmos.position;\n      _this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n      _this._rotationMatrix.makeRotationAxis(axis, -angle);\n      _this._m4_1.makeTranslation(point.x, point.y, point.z);\n      _this._m4_1.multiply(_this._rotationMatrix);\n      _this._m4_1.multiply(_this._translationMatrix);\n      _this.setTransformationMatrices(_this._m4_1);\n      return _transformation;\n    });\n    __publicField(_assertThisInitialized(_this), \"copyState\", function () {\n      if (_this.camera) {\n        var state = JSON.stringify(_this.camera instanceof OrthographicCamera ? {\n          arcballState: {\n            cameraFar: _this.camera.far,\n            cameraMatrix: _this.camera.matrix,\n            cameraNear: _this.camera.near,\n            cameraUp: _this.camera.up,\n            cameraZoom: _this.camera.zoom,\n            gizmoMatrix: _this._gizmos.matrix\n          }\n        } : {\n          arcballState: {\n            cameraFar: _this.camera.far,\n            cameraFov: _this.camera.fov,\n            cameraMatrix: _this.camera.matrix,\n            cameraNear: _this.camera.near,\n            cameraUp: _this.camera.up,\n            cameraZoom: _this.camera.zoom,\n            gizmoMatrix: _this._gizmos.matrix\n          }\n        });\n        navigator.clipboard.writeText(state);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"pasteState\", function () {\n      var self = _assertThisInitialized(_this);\n      navigator.clipboard.readText().then(function resolved(value) {\n        self.setStateFromJSON(value);\n      });\n    });\n    /**\n     * Save the current state of the control. This can later be recovered with .reset\n     */\n    __publicField(_assertThisInitialized(_this), \"saveState\", function () {\n      if (!_this.camera) return;\n      _this._cameraMatrixState0.copy(_this.camera.matrix);\n      _this._gizmoMatrixState0.copy(_this._gizmos.matrix);\n      _this._nearPos = _this.camera.near;\n      _this._farPos = _this.camera.far;\n      _this._zoom0 = _this.camera.zoom;\n      _this._up0.copy(_this.camera.up);\n      if (_this.camera instanceof PerspectiveCamera) {\n        _this._fov0 = _this.camera.fov;\n      }\n    });\n    /**\n     * Perform uniform scale operation around a given point\n     * @param {Number} size Scale factor\n     * @param {Vector3} point Point around which scale\n     * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n     * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n     */\n    __publicField(_assertThisInitialized(_this), \"applyScale\", function (size, point) {\n      var scaleGizmos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (!_this.camera) return;\n      var scalePoint = point.clone();\n      var sizeInverse = 1 / size;\n      if (_this.camera instanceof OrthographicCamera) {\n        _this.camera.zoom = _this._zoomState;\n        _this.camera.zoom *= size;\n        if (_this.camera.zoom > _this.maxZoom) {\n          _this.camera.zoom = _this.maxZoom;\n          sizeInverse = _this._zoomState / _this.maxZoom;\n        } else if (_this.camera.zoom < _this.minZoom) {\n          _this.camera.zoom = _this.minZoom;\n          sizeInverse = _this._zoomState / _this.minZoom;\n        }\n        _this.camera.updateProjectionMatrix();\n        _this._v3_1.setFromMatrixPosition(_this._gizmoMatrixState);\n        _this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n        _this._translationMatrix.makeTranslation(-_this._v3_1.x, -_this._v3_1.y, -_this._v3_1.z);\n        _this._m4_2.makeTranslation(_this._v3_1.x, _this._v3_1.y, _this._v3_1.z).multiply(_this._scaleMatrix);\n        _this._m4_2.multiply(_this._translationMatrix);\n        scalePoint.sub(_this._v3_1);\n        var amount = scalePoint.clone().multiplyScalar(sizeInverse);\n        scalePoint.sub(amount);\n        _this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z);\n        _this._m4_2.premultiply(_this._m4_1);\n        _this.setTransformationMatrices(_this._m4_1, _this._m4_2);\n        return _transformation;\n      }\n      if (_this.camera instanceof PerspectiveCamera) {\n        _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState);\n        _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState);\n        var distance = _this._v3_1.distanceTo(scalePoint);\n        var _amount = distance - distance * sizeInverse;\n        var newDistance = distance - _amount;\n        if (newDistance < _this.minDistance) {\n          sizeInverse = _this.minDistance / distance;\n          _amount = distance - distance * sizeInverse;\n        } else if (newDistance > _this.maxDistance) {\n          sizeInverse = _this.maxDistance / distance;\n          _amount = distance - distance * sizeInverse;\n        }\n        var direction = scalePoint.clone().sub(_this._v3_1).normalize().multiplyScalar(_amount);\n        _this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n        if (scaleGizmos) {\n          var pos = _this._v3_2;\n          distance = pos.distanceTo(scalePoint);\n          _amount = distance - distance * sizeInverse;\n          direction = scalePoint.clone().sub(_this._v3_2).normalize().multiplyScalar(_amount);\n          _this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\n          _this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n          _this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(_this._translationMatrix);\n          _this._m4_2.multiply(_this._scaleMatrix);\n          _this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\n          _this._m4_2.multiply(_this._translationMatrix);\n          _this.setTransformationMatrices(_this._m4_1, _this._m4_2);\n        } else {\n          _this.setTransformationMatrices(_this._m4_1);\n        }\n        return _transformation;\n      }\n    });\n    /**\n     * Set camera fov\n     * @param {Number} value fov to be setted\n     */\n    __publicField(_assertThisInitialized(_this), \"setFov\", function (value) {\n      if (_this.camera instanceof PerspectiveCamera) {\n        _this.camera.fov = MathUtils.clamp(value, _this.minFov, _this.maxFov);\n        _this.camera.updateProjectionMatrix();\n      }\n    });\n    /**\n     * Set the trackball's center point\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Number} z Z coordinate\n     */\n    __publicField(_assertThisInitialized(_this), \"setTarget\", function (x, y, z) {\n      if (_this.camera) {\n        _this.target.set(x, y, z);\n        _this._gizmos.position.set(x, y, z);\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        _this.makeGizmos(_this.target, _this._tbRadius);\n        _this.camera.lookAt(_this.target);\n      }\n    });\n    /**\n     * Rotate camera around its direction axis passing by a given point by a given angle\n     * @param {Vector3} point The point where the rotation axis is passing trough\n     * @param {Number} angle Angle in radians\n     * @returns The computed transormation matix\n     */\n    __publicField(_assertThisInitialized(_this), \"zRotate\", function (point, angle) {\n      _this._rotationMatrix.makeRotationAxis(_this._rotationAxis, angle);\n      _this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n      _this._m4_1.makeTranslation(point.x, point.y, point.z);\n      _this._m4_1.multiply(_this._rotationMatrix);\n      _this._m4_1.multiply(_this._translationMatrix);\n      _this._v3_1.setFromMatrixPosition(_this._gizmoMatrixState).sub(point);\n      _this._v3_2.copy(_this._v3_1).applyAxisAngle(_this._rotationAxis, angle);\n      _this._v3_2.sub(_this._v3_1);\n      _this._m4_2.makeTranslation(_this._v3_2.x, _this._v3_2.y, _this._v3_2.z);\n      _this.setTransformationMatrices(_this._m4_1, _this._m4_2);\n      return _transformation;\n    });\n    /**\n     * Unproject the cursor on the 3D object surface\n     * @param {Vector2} cursor Cursor coordinates in NDC\n     * @param {Camera} camera Virtual camera\n     * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n     */\n    __publicField(_assertThisInitialized(_this), \"unprojectOnObj\", function (cursor, camera) {\n      if (!_this.scene) return null;\n      var raycaster = new Raycaster();\n      raycaster.near = camera.near;\n      raycaster.far = camera.far;\n      raycaster.setFromCamera(cursor, camera);\n      var intersect = raycaster.intersectObjects(_this.scene.children, true);\n      for (var i = 0; i < intersect.length; i++) {\n        if (intersect[i].object.uuid != _this._gizmos.uuid && intersect[i].face) {\n          return intersect[i].point.clone();\n        }\n      }\n      return null;\n    });\n    /**\n     * Unproject the cursor on the trackball surface\n     * @param {Camera} camera The virtual camera\n     * @param {Number} cursorX Cursor horizontal coordinate on screen\n     * @param {Number} cursorY Cursor vertical coordinate on screen\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @param {number} tbRadius The trackball radius\n     * @returns {Vector3} The unprojected point on the trackball surface\n     */\n    __publicField(_assertThisInitialized(_this), \"unprojectOnTbSurface\", function (camera, cursorX, cursorY, canvas, tbRadius) {\n      if (camera instanceof OrthographicCamera) {\n        _this._v2_1.copy(_this.getCursorPosition(cursorX, cursorY, canvas));\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, 0);\n        var x2 = Math.pow(_this._v2_1.x, 2);\n        var y2 = Math.pow(_this._v2_1.y, 2);\n        var r2 = Math.pow(_this._tbRadius, 2);\n        if (x2 + y2 <= r2 * 0.5) {\n          _this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\n        } else {\n          _this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\n        }\n        return _this._v3_1;\n      }\n      if (camera instanceof PerspectiveCamera) {\n        _this._v2_1.copy(_this.getCursorNDC(cursorX, cursorY, canvas));\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, -1);\n        _this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n        var rayDir = _this._v3_1.clone().normalize();\n        var cameraGizmoDistance = camera.position.distanceTo(_this._gizmos.position);\n        var radius2 = Math.pow(tbRadius, 2);\n        var h = _this._v3_1.z;\n        var l = Math.sqrt(Math.pow(_this._v3_1.x, 2) + Math.pow(_this._v3_1.y, 2));\n        if (l == 0) {\n          rayDir.set(_this._v3_1.x, _this._v3_1.y, tbRadius);\n          return rayDir;\n        }\n        var m = h / l;\n        var q = cameraGizmoDistance;\n        var a = Math.pow(m, 2) + 1;\n        var b = 2 * m * q;\n        var c = Math.pow(q, 2) - radius2;\n        var delta = Math.pow(b, 2) - 4 * a * c;\n        if (delta >= 0) {\n          _this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n          _this._v2_1.setY(m * _this._v2_1.x + q);\n          var angle = MathUtils.RAD2DEG * _this._v2_1.angle();\n          if (angle >= 45) {\n            var rayLength2 = Math.sqrt(Math.pow(_this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - _this._v2_1.y, 2));\n            rayDir.multiplyScalar(rayLength2);\n            rayDir.z += cameraGizmoDistance;\n            return rayDir;\n          }\n        }\n        a = m;\n        b = q;\n        c = -radius2 * 0.5;\n        delta = Math.pow(b, 2) - 4 * a * c;\n        _this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n        _this._v2_1.setY(m * _this._v2_1.x + q);\n        var rayLength = Math.sqrt(Math.pow(_this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - _this._v2_1.y, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z += cameraGizmoDistance;\n        return rayDir;\n      }\n    });\n    /**\n     * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n     * @param {Camera} camera The virtual camera\n     * @param {Number} cursorX Cursor horizontal coordinate on screen\n     * @param {Number} cursorY Cursor vertical coordinate on screen\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n     * @returns {Vector3} The unprojected point on the trackball plane\n     */\n    __publicField(_assertThisInitialized(_this), \"unprojectOnTbPlane\", function (camera, cursorX, cursorY, canvas) {\n      var initialDistance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      if (camera instanceof OrthographicCamera) {\n        _this._v2_1.copy(_this.getCursorPosition(cursorX, cursorY, canvas));\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, 0);\n        return _this._v3_1.clone();\n      }\n      if (camera instanceof PerspectiveCamera) {\n        _this._v2_1.copy(_this.getCursorNDC(cursorX, cursorY, canvas));\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, -1);\n        _this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n        var rayDir = _this._v3_1.clone().normalize();\n        var h = _this._v3_1.z;\n        var l = Math.sqrt(Math.pow(_this._v3_1.x, 2) + Math.pow(_this._v3_1.y, 2));\n        var cameraGizmoDistance;\n        if (initialDistance) {\n          cameraGizmoDistance = _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState0).distanceTo(_this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState0));\n        } else {\n          cameraGizmoDistance = camera.position.distanceTo(_this._gizmos.position);\n        }\n        if (l == 0) {\n          rayDir.set(0, 0, 0);\n          return rayDir;\n        }\n        var m = h / l;\n        var q = cameraGizmoDistance;\n        var x = -q / m;\n        var rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z = 0;\n        return rayDir;\n      }\n    });\n    /**\n     * Update camera and gizmos state\n     */\n    __publicField(_assertThisInitialized(_this), \"updateMatrixState\", function () {\n      if (!_this.camera) return;\n      _this._cameraMatrixState.copy(_this.camera.matrix);\n      _this._gizmoMatrixState.copy(_this._gizmos.matrix);\n      if (_this.camera instanceof OrthographicCamera) {\n        _this._cameraProjectionState.copy(_this.camera.projectionMatrix);\n        _this.camera.updateProjectionMatrix();\n        _this._zoomState = _this.camera.zoom;\n      }\n      if (_this.camera instanceof PerspectiveCamera) {\n        _this._fovState = _this.camera.fov;\n      }\n    });\n    /**\n     * Update the trackball FSA\n     * @param {STATE} newState New state of the FSA\n     * @param {Boolean} updateMatrices If matriices state should be updated\n     */\n    __publicField(_assertThisInitialized(_this), \"updateTbState\", function (newState, updateMatrices) {\n      _this._state = newState;\n      if (updateMatrices) {\n        _this.updateMatrixState();\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"update\", function () {\n      var EPS = 1e-6;\n      if (!_this.target.equals(_this._currentTarget) && _this.camera) {\n        _this._gizmos.position.set(_this.target.x, _this.target.y, _this.target.z);\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        _this.makeGizmos(_this.target, _this._tbRadius);\n        _this._currentTarget.copy(_this.target);\n      }\n      if (!_this.camera) return;\n      if (_this.camera instanceof OrthographicCamera) {\n        if (_this.camera.zoom > _this.maxZoom || _this.camera.zoom < _this.minZoom) {\n          var newZoom = MathUtils.clamp(_this.camera.zoom, _this.minZoom, _this.maxZoom);\n          _this.applyTransformMatrix(_this.applyScale(newZoom / _this.camera.zoom, _this._gizmos.position, true));\n        }\n      }\n      if (_this.camera instanceof PerspectiveCamera) {\n        var distance = _this.camera.position.distanceTo(_this._gizmos.position);\n        if (distance > _this.maxDistance + EPS || distance < _this.minDistance - EPS) {\n          var newDistance = MathUtils.clamp(distance, _this.minDistance, _this.maxDistance);\n          _this.applyTransformMatrix(_this.applyScale(newDistance / distance, _this._gizmos.position));\n          _this.updateMatrixState();\n        }\n        if (_this.camera.fov < _this.minFov || _this.camera.fov > _this.maxFov) {\n          _this.camera.fov = MathUtils.clamp(_this.camera.fov, _this.minFov, _this.maxFov);\n          _this.camera.updateProjectionMatrix();\n        }\n        var oldRadius = _this._tbRadius;\n        var _tbRadius = _this.calculateTbRadius(_this.camera);\n        if (_tbRadius !== void 0) {\n          _this._tbRadius = _tbRadius;\n        }\n        if (oldRadius < _this._tbRadius - EPS || oldRadius > _this._tbRadius + EPS) {\n          var scale = (_this._gizmos.scale.x + _this._gizmos.scale.y + _this._gizmos.scale.z) / 3;\n          var newRadius = _this._tbRadius / scale;\n          var curve = new EllipseCurve(0, 0, newRadius, newRadius);\n          var points = curve.getPoints(_this._curvePts);\n          var curveGeometry = new BufferGeometry().setFromPoints(points);\n          for (var gizmo in _this._gizmos.children) {\n            var child = _this._gizmos.children[gizmo];\n            child.geometry = curveGeometry;\n          }\n        }\n      }\n      _this.camera.lookAt(_this._gizmos.position);\n    });\n    __publicField(_assertThisInitialized(_this), \"setStateFromJSON\", function (json) {\n      var state = JSON.parse(json);\n      if (state.arcballState && _this.camera) {\n        _this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\n        _this._cameraMatrixState.decompose(_this.camera.position, _this.camera.quaternion, _this.camera.scale);\n        _this.camera.up.copy(state.arcballState.cameraUp);\n        _this.camera.near = state.arcballState.cameraNear;\n        _this.camera.far = state.arcballState.cameraFar;\n        _this.camera.zoom = state.arcballState.cameraZoom;\n        if (_this.camera instanceof PerspectiveCamera) {\n          _this.camera.fov = state.arcballState.cameraFov;\n        }\n        _this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\n        _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n        _this.camera.updateMatrix();\n        _this.camera.updateProjectionMatrix();\n        _this._gizmos.updateMatrix();\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        var gizmoTmp = new Matrix4().copy(_this._gizmoMatrixState0);\n        _this.makeGizmos(_this._gizmos.position, _this._tbRadius);\n        _this._gizmoMatrixState0.copy(gizmoTmp);\n        _this.camera.lookAt(_this._gizmos.position);\n        _this.updateTbState(STATE.IDLE, false);\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    _this.camera = null;\n    _this.domElement = domElement;\n    _this.scene = scene;\n    _this.mouseActions = [];\n    _this._mouseOp = null;\n    _this._v2_1 = new Vector2();\n    _this._v3_1 = new Vector3();\n    _this._v3_2 = new Vector3();\n    _this._m4_1 = new Matrix4();\n    _this._m4_2 = new Matrix4();\n    _this._quat = new Quaternion();\n    _this._translationMatrix = new Matrix4();\n    _this._rotationMatrix = new Matrix4();\n    _this._scaleMatrix = new Matrix4();\n    _this._rotationAxis = new Vector3();\n    _this._cameraMatrixState = new Matrix4();\n    _this._cameraProjectionState = new Matrix4();\n    _this._fovState = 1;\n    _this._upState = new Vector3();\n    _this._zoomState = 1;\n    _this._nearPos = 0;\n    _this._farPos = 0;\n    _this._gizmoMatrixState = new Matrix4();\n    _this._up0 = new Vector3();\n    _this._zoom0 = 1;\n    _this._fov0 = 0;\n    _this._initialNear = 0;\n    _this._nearPos0 = 0;\n    _this._initialFar = 0;\n    _this._farPos0 = 0;\n    _this._cameraMatrixState0 = new Matrix4();\n    _this._gizmoMatrixState0 = new Matrix4();\n    _this._button = -1;\n    _this._touchStart = [];\n    _this._touchCurrent = [];\n    _this._input = INPUT.NONE;\n    _this._switchSensibility = 32;\n    _this._startFingerDistance = 0;\n    _this._currentFingerDistance = 0;\n    _this._startFingerRotation = 0;\n    _this._currentFingerRotation = 0;\n    _this._devPxRatio = 0;\n    _this._downValid = true;\n    _this._nclicks = 0;\n    _this._downEvents = [];\n    _this._clickStart = 0;\n    _this._maxDownTime = 250;\n    _this._maxInterval = 300;\n    _this._posThreshold = 24;\n    _this._movementThreshold = 24;\n    _this._currentCursorPosition = new Vector3();\n    _this._startCursorPosition = new Vector3();\n    _this._grid = null;\n    _this._gridPosition = new Vector3();\n    _this._gizmos = new Group();\n    _this._curvePts = 128;\n    _this._timeStart = -1;\n    _this._animationId = -1;\n    _this.focusAnimationTime = 500;\n    _this._timePrev = 0;\n    _this._timeCurrent = 0;\n    _this._anglePrev = 0;\n    _this._angleCurrent = 0;\n    _this._cursorPosPrev = new Vector3();\n    _this._cursorPosCurr = new Vector3();\n    _this._wPrev = 0;\n    _this._wCurr = 0;\n    _this.adjustNearFar = false;\n    _this.scaleFactor = 1.1;\n    _this.dampingFactor = 25;\n    _this.wMax = 20;\n    _this.enableAnimations = true;\n    _this.enableGrid = false;\n    _this.cursorZoom = false;\n    _this.minFov = 5;\n    _this.maxFov = 90;\n    _this.enabled = true;\n    _this.enablePan = true;\n    _this.enableRotate = true;\n    _this.enableZoom = true;\n    _this.minDistance = 0;\n    _this.maxDistance = Infinity;\n    _this.minZoom = 0;\n    _this.maxZoom = Infinity;\n    _this.target = new Vector3(0, 0, 0);\n    _this._currentTarget = new Vector3(0, 0, 0);\n    _this._tbRadius = 1;\n    _this._state = STATE.IDLE;\n    _this.setCamera(camera);\n    if (_this.scene) {\n      _this.scene.add(_this._gizmos);\n    }\n    _this._devPxRatio = window.devicePixelRatio;\n    _this.initializeMouseActions();\n    if (_this.domElement) _this.connect(_this.domElement);\n    window.addEventListener(\"resize\", _this.onWindowResize);\n    return _this;\n  }\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n  _createClass(ArcballControls, [{\n    key: \"applyTransformMatrix\",\n    value: function applyTransformMatrix(transformation) {\n      if ((transformation == null ? void 0 : transformation.camera) && this.camera) {\n        this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\n        this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n        this.camera.updateMatrix();\n        if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n          this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);\n        }\n      }\n      if (transformation == null ? void 0 : transformation.gizmos) {\n        this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\n        this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n        this._gizmos.updateMatrix();\n      }\n      if ((this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) && this.camera) {\n        var tbRadius = this.calculateTbRadius(this.camera);\n        if (tbRadius !== void 0) {\n          this._tbRadius = tbRadius;\n        }\n        if (this.adjustNearFar) {\n          var cameraDistance = this.camera.position.distanceTo(this._gizmos.position);\n          var bb = new Box3();\n          bb.setFromObject(this._gizmos);\n          var sphere = new Sphere();\n          bb.getBoundingSphere(sphere);\n          var adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\n          var regularNearPosition = cameraDistance - this._initialNear;\n          var minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\n          this.camera.near = cameraDistance - minNearPos;\n          var adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\n          var regularFarPosition = cameraDistance - this._initialFar;\n          var minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\n          this.camera.far = cameraDistance - minFarPos;\n          this.camera.updateProjectionMatrix();\n        } else {\n          var update = false;\n          if (this.camera.near != this._initialNear) {\n            this.camera.near = this._initialNear;\n            update = true;\n          }\n          if (this.camera.far != this._initialFar) {\n            this.camera.far = this._initialFar;\n            update = true;\n          }\n          if (update) {\n            this.camera.updateProjectionMatrix();\n          }\n        }\n      }\n    }\n    /**\n     * Set gizmos visibility\n     * @param {Boolean} value Value of gizmos visibility\n     */\n  }, {\n    key: \"setGizmosVisible\",\n    value: function setGizmosVisible(value) {\n      this._gizmos.visible = value;\n      this.dispatchEvent(_changeEvent);\n    }\n    /**\n     * Set values in transformation object\n     * @param {Matrix4} camera Transformation to be applied to the camera\n     * @param {Matrix4} gizmos Transformation to be applied to gizmos\n     */\n  }, {\n    key: \"setTransformationMatrices\",\n    value: function setTransformationMatrices() {\n      var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var gizmos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (camera) {\n        if (_transformation.camera) {\n          _transformation.camera.copy(camera);\n        } else {\n          _transformation.camera = camera.clone();\n        }\n      } else {\n        _transformation.camera = null;\n      }\n      if (gizmos) {\n        if (_transformation.gizmos) {\n          _transformation.gizmos.copy(gizmos);\n        } else {\n          _transformation.gizmos = gizmos.clone();\n        }\n      } else {\n        _transformation.gizmos = null;\n      }\n    }\n  }]);\n  return ArcballControls;\n}(EventDispatcher);\nexport { ArcballControls };\n//# sourceMappingURL=ArcballControls.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}