{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Matrix3, Box3, Matrix4, Ray, MathUtils } from \"three\";\nvar a = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: []\n  // half width\n};\n\nvar b = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: []\n  // half width\n};\n\nvar R = [[], [], []];\nvar AbsR = [[], [], []];\nvar t = [];\nvar xAxis = new Vector3();\nvar yAxis = new Vector3();\nvar zAxis = new Vector3();\nvar v1 = new Vector3();\nvar size = new Vector3();\nvar closestPoint = new Vector3();\nvar rotationMatrix = new Matrix3();\nvar aabb = new Box3();\nvar matrix = new Matrix4();\nvar inverse = new Matrix4();\nvar localRay = new Ray();\nvar OBB = /*#__PURE__*/function () {\n  function OBB() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var halfSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    var rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Matrix3();\n    _classCallCheck(this, OBB);\n    this.center = center;\n    this.halfSize = halfSize;\n    this.rotation = rotation;\n  }\n  _createClass(OBB, [{\n    key: \"set\",\n    value: function set(center, halfSize, rotation) {\n      this.center = center;\n      this.halfSize = halfSize;\n      this.rotation = rotation;\n      return this;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(obb2) {\n      this.center.copy(obb2.center);\n      this.halfSize.copy(obb2.halfSize);\n      this.rotation.copy(obb2.rotation);\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize(result) {\n      return result.copy(this.halfSize).multiplyScalar(2);\n    }\n    /**\n     * Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n     * by Christer Ericson (chapter 5.1.4)\n     */\n  }, {\n    key: \"clampPoint\",\n    value: function clampPoint(point, result) {\n      var halfSize = this.halfSize;\n      v1.subVectors(point, this.center);\n      this.rotation.extractBasis(xAxis, yAxis, zAxis);\n      result.copy(this.center);\n      var x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);\n      result.add(xAxis.multiplyScalar(x));\n      var y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);\n      result.add(yAxis.multiplyScalar(y));\n      var z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);\n      result.add(zAxis.multiplyScalar(z));\n      return result;\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      v1.subVectors(point, this.center);\n      this.rotation.extractBasis(xAxis, yAxis, zAxis);\n      return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;\n    }\n  }, {\n    key: \"intersectsBox3\",\n    value: function intersectsBox3(box3) {\n      return this.intersectsOBB(obb.fromBox3(box3));\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      this.clampPoint(sphere.center, closestPoint);\n      return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    /**\n     * Reference: OBB-OBB Intersection in Real-Time Collision Detection\n     * by Christer Ericson (chapter 4.4.1)\n     *\n     */\n  }, {\n    key: \"intersectsOBB\",\n    value: function intersectsOBB(obb2) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.EPSILON;\n      a.c = this.center;\n      a.e[0] = this.halfSize.x;\n      a.e[1] = this.halfSize.y;\n      a.e[2] = this.halfSize.z;\n      this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);\n      b.c = obb2.center;\n      b.e[0] = obb2.halfSize.x;\n      b.e[1] = obb2.halfSize.y;\n      b.e[2] = obb2.halfSize.z;\n      obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);\n      for (var i = 0; i < 3; i++) {\n        for (var j = 0; j < 3; j++) {\n          R[i][j] = a.u[i].dot(b.u[j]);\n        }\n      }\n      v1.subVectors(b.c, a.c);\n      t[0] = v1.dot(a.u[0]);\n      t[1] = v1.dot(a.u[1]);\n      t[2] = v1.dot(a.u[2]);\n      for (var _i = 0; _i < 3; _i++) {\n        for (var _j = 0; _j < 3; _j++) {\n          AbsR[_i][_j] = Math.abs(R[_i][_j]) + epsilon;\n        }\n      }\n      var ra, rb;\n      for (var _i2 = 0; _i2 < 3; _i2++) {\n        ra = a.e[_i2];\n        rb = b.e[0] * AbsR[_i2][0] + b.e[1] * AbsR[_i2][1] + b.e[2] * AbsR[_i2][2];\n        if (Math.abs(t[_i2]) > ra + rb) return false;\n      }\n      for (var _i3 = 0; _i3 < 3; _i3++) {\n        ra = a.e[0] * AbsR[0][_i3] + a.e[1] * AbsR[1][_i3] + a.e[2] * AbsR[2][_i3];\n        rb = b.e[_i3];\n        if (Math.abs(t[0] * R[0][_i3] + t[1] * R[1][_i3] + t[2] * R[2][_i3]) > ra + rb) return false;\n      }\n      ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];\n      rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];\n      if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false;\n      ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];\n      rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];\n      if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false;\n      ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];\n      rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];\n      if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false;\n      ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];\n      rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];\n      if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false;\n      ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];\n      rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];\n      if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false;\n      ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];\n      rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];\n      if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false;\n      ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];\n      rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];\n      if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false;\n      ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];\n      rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];\n      if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false;\n      ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];\n      rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];\n      if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false;\n      return true;\n    }\n    /**\n     * Reference: Testing Box Against Plane in Real-Time Collision Detection\n     * by Christer Ericson (chapter 5.2.3)\n     */\n  }, {\n    key: \"intersectsPlane\",\n    value: function intersectsPlane(plane) {\n      this.rotation.extractBasis(xAxis, yAxis, zAxis);\n      var r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));\n      var d = plane.normal.dot(this.center) - plane.constant;\n      return Math.abs(d) <= r;\n    }\n    /**\n     * Performs a ray/OBB intersection test and stores the intersection point\n     * to the given 3D vector. If no intersection is detected, *null* is returned.\n     */\n  }, {\n    key: \"intersectRay\",\n    value: function intersectRay(ray, result) {\n      this.getSize(size);\n      aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);\n      matrix.setFromMatrix3(this.rotation);\n      matrix.setPosition(this.center);\n      inverse.copy(matrix).invert();\n      localRay.copy(ray).applyMatrix4(inverse);\n      if (localRay.intersectBox(aabb, result)) {\n        return result.applyMatrix4(matrix);\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Performs a ray/OBB intersection test. Returns either true or false if\n     * there is a intersection or not.\n     */\n  }, {\n    key: \"intersectsRay\",\n    value: function intersectsRay(ray) {\n      return this.intersectRay(ray, v1) !== null;\n    }\n  }, {\n    key: \"fromBox3\",\n    value: function fromBox3(box3) {\n      box3.getCenter(this.center);\n      box3.getSize(this.halfSize).multiplyScalar(0.5);\n      this.rotation.identity();\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(obb2) {\n      return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);\n    }\n  }, {\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(matrix2) {\n      var e = matrix2.elements;\n      var sx = v1.set(e[0], e[1], e[2]).length();\n      var sy = v1.set(e[4], e[5], e[6]).length();\n      var sz = v1.set(e[8], e[9], e[10]).length();\n      var det = matrix2.determinant();\n      if (det < 0) sx = -sx;\n      rotationMatrix.setFromMatrix4(matrix2);\n      var invSX = 1 / sx;\n      var invSY = 1 / sy;\n      var invSZ = 1 / sz;\n      rotationMatrix.elements[0] *= invSX;\n      rotationMatrix.elements[1] *= invSX;\n      rotationMatrix.elements[2] *= invSX;\n      rotationMatrix.elements[3] *= invSY;\n      rotationMatrix.elements[4] *= invSY;\n      rotationMatrix.elements[5] *= invSY;\n      rotationMatrix.elements[6] *= invSZ;\n      rotationMatrix.elements[7] *= invSZ;\n      rotationMatrix.elements[8] *= invSZ;\n      this.rotation.multiply(rotationMatrix);\n      this.halfSize.x *= sx;\n      this.halfSize.y *= sy;\n      this.halfSize.z *= sz;\n      v1.setFromMatrixPosition(matrix2);\n      this.center.add(v1);\n      return this;\n    }\n  }]);\n  return OBB;\n}();\nvar obb = new OBB();\nexport { OBB };\n//# sourceMappingURL=OBB.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}