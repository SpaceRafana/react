{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, MathUtils } from \"three\";\nvar MorphBlendMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(MorphBlendMesh, _Mesh);\n  var _super = _createSuper(MorphBlendMesh);\n  function MorphBlendMesh(geometry, material) {\n    var _this;\n    _classCallCheck(this, MorphBlendMesh);\n    _this = _super.call(this, geometry, material);\n    _this.animationsMap = {};\n    _this.animationsList = [];\n    var numFrames = Object.keys(_this.morphTargetDictionary).length;\n    var name = \"__default\";\n    var startFrame = 0;\n    var endFrame = numFrames - 1;\n    var fps = numFrames / 1;\n    _this.createAnimation(name, startFrame, endFrame, fps);\n    _this.setAnimationWeight(name, 1);\n    return _this;\n  }\n  _createClass(MorphBlendMesh, [{\n    key: \"createAnimation\",\n    value: function createAnimation(name, start, end, fps) {\n      var animation = {\n        start: start,\n        end: end,\n        length: end - start + 1,\n        fps: fps,\n        duration: (end - start) / fps,\n        lastFrame: 0,\n        currentFrame: 0,\n        active: false,\n        time: 0,\n        direction: 1,\n        weight: 1,\n        directionBackwards: false,\n        mirroredLoop: false\n      };\n      this.animationsMap[name] = animation;\n      this.animationsList.push(animation);\n    }\n  }, {\n    key: \"autoCreateAnimations\",\n    value: function autoCreateAnimations(fps) {\n      var pattern = /([a-z]+)_?(\\d+)/i;\n      var firstAnimation;\n      var frameRanges = {};\n      var i = 0;\n      for (var key in this.morphTargetDictionary) {\n        var chunks = key.match(pattern);\n        if (chunks && chunks.length > 1) {\n          var name = chunks[1];\n          if (!frameRanges[name]) frameRanges[name] = {\n            start: Infinity,\n            end: -Infinity\n          };\n          var range = frameRanges[name];\n          if (i < range.start) range.start = i;\n          if (i > range.end) range.end = i;\n          if (!firstAnimation) firstAnimation = name;\n        }\n        i++;\n      }\n      for (var _name in frameRanges) {\n        var _range = frameRanges[_name];\n        this.createAnimation(_name, _range.start, _range.end, fps);\n      }\n      this.firstAnimation = firstAnimation;\n    }\n  }, {\n    key: \"setAnimationDirectionForward\",\n    value: function setAnimationDirectionForward(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.direction = 1;\n        animation.directionBackwards = false;\n      }\n    }\n  }, {\n    key: \"setAnimationDirectionBackward\",\n    value: function setAnimationDirectionBackward(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.direction = -1;\n        animation.directionBackwards = true;\n      }\n    }\n  }, {\n    key: \"setAnimationFPS\",\n    value: function setAnimationFPS(name, fps) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.fps = fps;\n        animation.duration = (animation.end - animation.start) / animation.fps;\n      }\n    }\n  }, {\n    key: \"setAnimationDuration\",\n    value: function setAnimationDuration(name, duration) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.duration = duration;\n        animation.fps = (animation.end - animation.start) / animation.duration;\n      }\n    }\n  }, {\n    key: \"setAnimationWeight\",\n    value: function setAnimationWeight(name, weight) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.weight = weight;\n      }\n    }\n  }, {\n    key: \"setAnimationTime\",\n    value: function setAnimationTime(name, time) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.time = time;\n      }\n    }\n  }, {\n    key: \"getAnimationTime\",\n    value: function getAnimationTime(name) {\n      var time = 0;\n      var animation = this.animationsMap[name];\n      if (animation) {\n        time = animation.time;\n      }\n      return time;\n    }\n  }, {\n    key: \"getAnimationDuration\",\n    value: function getAnimationDuration(name) {\n      var duration = -1;\n      var animation = this.animationsMap[name];\n      if (animation) {\n        duration = animation.duration;\n      }\n      return duration;\n    }\n  }, {\n    key: \"playAnimation\",\n    value: function playAnimation(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.time = 0;\n        animation.active = true;\n      } else {\n        console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n      }\n    }\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.active = false;\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(delta) {\n      for (var i = 0, il = this.animationsList.length; i < il; i++) {\n        var animation = this.animationsList[i];\n        if (!animation.active) continue;\n        var frameTime = animation.duration / animation.length;\n        animation.time += animation.direction * delta;\n        if (animation.mirroredLoop) {\n          if (animation.time > animation.duration || animation.time < 0) {\n            animation.direction *= -1;\n            if (animation.time > animation.duration) {\n              animation.time = animation.duration;\n              animation.directionBackwards = true;\n            }\n            if (animation.time < 0) {\n              animation.time = 0;\n              animation.directionBackwards = false;\n            }\n          }\n        } else {\n          animation.time = animation.time % animation.duration;\n          if (animation.time < 0) animation.time += animation.duration;\n        }\n        var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n        var weight = animation.weight;\n        if (keyframe !== animation.currentFrame) {\n          this.morphTargetInfluences[animation.lastFrame] = 0;\n          this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n          this.morphTargetInfluences[keyframe] = 0;\n          animation.lastFrame = animation.currentFrame;\n          animation.currentFrame = keyframe;\n        }\n        var mix = animation.time % frameTime / frameTime;\n        if (animation.directionBackwards) mix = 1 - mix;\n        if (animation.currentFrame !== animation.lastFrame) {\n          this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n          this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n        } else {\n          this.morphTargetInfluences[animation.currentFrame] = weight;\n        }\n      }\n    }\n  }]);\n  return MorphBlendMesh;\n}(Mesh);\nexport { MorphBlendMesh };\n//# sourceMappingURL=MorphBlendMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}