{"ast":null,"code":"import TextureNode from './TextureNode.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { reflectVector } from './ReflectVectorNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeElement, nodeProxy, vec3 } from '../shadernode/ShaderNode.js';\nclass CubeTextureNode extends TextureNode {\n  constructor(value, uvNode = null, levelNode = null) {\n    super(value, uvNode, levelNode);\n    this.isCubeTextureNode = true;\n  }\n  getInputType( /*builder*/\n  ) {\n    return 'cubeTexture';\n  }\n  getDefaultUV() {\n    return reflectVector;\n  }\n  setUpdateMatrix( /*updateMatrix*/) {} // Ignore .updateMatrix for CubeTextureNode\n\n  generate(builder, output) {\n    const {\n      uvNode,\n      levelNode\n    } = builder.getNodeProperties(this);\n    const texture = this.value;\n    if (!texture || texture.isCubeTexture !== true) {\n      throw new Error('CubeTextureNode: Need a three.js cube texture.');\n    }\n    const textureProperty = UniformNode.prototype.generate.call(this, builder, 'cubeTexture');\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeType = this.getNodeType(builder);\n      const nodeData = builder.getDataFromNode(this);\n      let propertyName = nodeData.propertyName;\n      if (propertyName === undefined) {\n        const cubeUV = vec3(uvNode.x.negate(), uvNode.yz);\n        const uvSnippet = cubeUV.build(builder, 'vec3');\n        const nodeVar = builder.getVarFromNode(this, 'vec4');\n        propertyName = builder.getPropertyName(nodeVar);\n        let snippet = null;\n        if (levelNode && levelNode.isNode === true) {\n          const levelSnippet = levelNode.build(builder, 'float');\n          snippet = builder.getTextureLevel(this, textureProperty, uvSnippet, levelSnippet);\n        } else {\n          snippet = builder.getTexture(this, textureProperty, uvSnippet);\n        }\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`);\n        if (builder.context.tempWrite !== false) {\n          nodeData.snippet = snippet;\n          nodeData.propertyName = propertyName;\n        }\n      }\n      let snippet = propertyName;\n      if (builder.needsColorSpaceToLinear(this.value)) {\n        snippet = colorSpaceToLinear(expression(snippet, nodeType), this.value.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      return builder.format(snippet, 'vec4', output);\n    }\n  }\n}\nexport default CubeTextureNode;\nexport const cubeTexture = nodeProxy(CubeTextureNode);\naddNodeElement('cubeTexture', cubeTexture);\naddNodeClass('CubeTextureNode', CubeTextureNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}