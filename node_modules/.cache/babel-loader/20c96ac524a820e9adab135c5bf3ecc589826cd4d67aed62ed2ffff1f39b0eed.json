{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Quaternion, Matrix4 } from \"three\";\nimport { CharsetEncoder } from \"../libs/mmdparser.js\";\nvar MMDExporter = /*#__PURE__*/function () {\n  function MMDExporter() {\n    _classCallCheck(this, MMDExporter);\n    // Unicode to Shift_JIS table\n    __publicField(this, \"u2sTable\");\n  }\n  /* TODO: implement\n  // mesh -> pmd\n  this.parsePmd = function ( object ) {\n  };\n  */\n  /* TODO: implement\n  // mesh -> pmx\n  this.parsePmx = function ( object ) {\n  };\n  */\n  /* TODO: implement\n  // animation + skeleton -> vmd\n  this.parseVmd = function ( object ) {\n  };\n  */\n  /*\n   * skeleton -> vpd\n   * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n   */\n  _createClass(MMDExporter, [{\n    key: \"parseVpd\",\n    value: function parseVpd(skin, outputShiftJis, useOriginalBones) {\n      if (skin.isSkinnedMesh !== true) {\n        console.warn(\"THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.\");\n        return null;\n      }\n      function toStringsFromNumber(num) {\n        if (Math.abs(num) < 1e-6) num = 0;\n        var a = num.toString();\n        if (a.indexOf(\".\") === -1) {\n          a += \".\";\n        }\n        a += \"000000\";\n        var index = a.indexOf(\".\");\n        var d = a.slice(0, index);\n        var p = a.slice(index + 1, index + 7);\n        return d + \".\" + p;\n      }\n      function toStringsFromArray(array2) {\n        var a = [];\n        for (var i = 0, il = array2.length; i < il; i++) {\n          a.push(toStringsFromNumber(array2[i]));\n        }\n        return a.join(\",\");\n      }\n      skin.updateMatrixWorld(true);\n      var bones = skin.skeleton.bones;\n      var bones2 = this.getBindBones(skin);\n      var position = new Vector3();\n      var quaternion = new Quaternion();\n      var quaternion2 = new Quaternion();\n      var matrix = new Matrix4();\n      var array = [];\n      array.push(\"Vocaloid Pose Data file\");\n      array.push(\"\");\n      array.push((skin.name !== \"\" ? skin.name.replace(/\\s/g, \"_\") : \"skin\") + \".osm;\");\n      array.push(bones.length + \";\");\n      array.push(\"\");\n      for (var i = 0, il = bones.length; i < il; i++) {\n        var bone = bones[i];\n        var bone2 = bones2[i];\n        if (useOriginalBones === true && bone.userData.ik !== void 0 && bone.userData.ik.originalMatrix !== void 0) {\n          matrix.fromArray(bone.userData.ik.originalMatrix);\n        } else {\n          matrix.copy(bone.matrix);\n        }\n        position.setFromMatrixPosition(matrix);\n        quaternion.setFromRotationMatrix(matrix);\n        var pArray = position.sub(bone2.position).toArray();\n        var qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray();\n        pArray[2] = -pArray[2];\n        qArray[0] = -qArray[0];\n        qArray[1] = -qArray[1];\n        array.push(\"Bone\" + i + \"{\" + bone.name);\n        array.push(\"  \" + toStringsFromArray(pArray) + \";\");\n        array.push(\"  \" + toStringsFromArray(qArray) + \";\");\n        array.push(\"}\");\n        array.push(\"\");\n      }\n      array.push(\"\");\n      var lines = array.join(\"\\n\");\n      return outputShiftJis === true ? this.unicodeToShiftjis(lines) : lines;\n    }\n  }, {\n    key: \"unicodeToShiftjis\",\n    value: function unicodeToShiftjis(str) {\n      if (this.u2sTable === void 0) {\n        var encoder = new CharsetEncoder();\n        var table = encoder.s2uTable;\n        this.u2sTable = {};\n        var keys = Object.keys(table);\n        for (var i = 0, il = keys.length; i < il; i++) {\n          var key = keys[i];\n          var value = table[key];\n          this.u2sTable[value] = parseInt(key);\n        }\n      }\n      var array = [];\n      for (var _i = 0, _il = str.length; _i < _il; _i++) {\n        var code = str.charCodeAt(_i);\n        var _value = this.u2sTable[code];\n        if (_value === void 0) {\n          throw \"cannot convert charcode 0x\" + code.toString(16);\n        } else if (_value > 255) {\n          array.push(_value >> 8 & 255);\n          array.push(_value & 255);\n        } else {\n          array.push(_value & 255);\n        }\n      }\n      return new Uint8Array(array);\n    }\n  }, {\n    key: \"getBindBones\",\n    value: function getBindBones(skin) {\n      var poseSkin = skin.clone();\n      poseSkin.pose();\n      return poseSkin.skeleton.bones;\n    }\n  }]);\n  return MMDExporter;\n}();\nexport { MMDExporter };\n//# sourceMappingURL=MMDExporter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}