{"ast":null,"code":"import { FLOAT32_EPSILON } from '../Constants.js';\nimport { makeEmptyBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds(triangleBounds, offset, count, target) {\n  var centroidTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var minx = Infinity;\n  var miny = Infinity;\n  var minz = Infinity;\n  var maxx = -Infinity;\n  var maxy = -Infinity;\n  var maxz = -Infinity;\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n  var includeCentroid = centroidTarget !== null;\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    var hx = triangleBounds[i + 1];\n    var lx = cx - hx;\n    var rx = cx + hx;\n    if (lx < minx) minx = lx;\n    if (rx > maxx) maxx = rx;\n    if (includeCentroid && cx < cminx) cminx = cx;\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    var hy = triangleBounds[i + 3];\n    var ly = cy - hy;\n    var ry = cy + hy;\n    if (ly < miny) miny = ly;\n    if (ry > maxy) maxy = ry;\n    if (includeCentroid && cy < cminy) cminy = cy;\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    var hz = triangleBounds[i + 5];\n    var lz = cz - hz;\n    var rz = cz + hz;\n    if (lz < minz) minz = lz;\n    if (rz > maxz) maxz = rz;\n    if (includeCentroid && cz < cminz) cminz = cz;\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\n  }\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n}\n\n// A stand alone function for retrieving the centroid bounds.\nexport function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    if (cx < cminx) cminx = cx;\n    if (cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    if (cy < cminy) cminy = cy;\n    if (cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    if (cz < cminz) cminz = cz;\n    if (cz > cmaxz) cmaxz = cz;\n  }\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds(geo, fullBounds) {\n  // clear the bounds to empty\n  makeEmptyBounds(fullBounds);\n  var posAttr = geo.attributes.position;\n  var index = geo.index ? geo.index.array : null;\n  var triCount = getTriCount(geo);\n  var triangleBounds = new Float32Array(triCount * 6);\n  var normalized = posAttr.normalized;\n\n  // used for non-normalized positions\n  var posArr = posAttr.array;\n\n  // support for an interleaved position buffer\n  var bufferOffset = posAttr.offset || 0;\n  var stride = 3;\n  if (posAttr.isInterleavedBufferAttribute) {\n    stride = posAttr.data.stride;\n  }\n\n  // used for normalized positions\n  var getters = ['getX', 'getY', 'getZ'];\n  for (var tri = 0; tri < triCount; tri++) {\n    var tri3 = tri * 3;\n    var tri6 = tri * 6;\n    var ai = tri3 + 0;\n    var bi = tri3 + 1;\n    var ci = tri3 + 2;\n    if (index) {\n      ai = index[ai];\n      bi = index[bi];\n      ci = index[ci];\n    }\n\n    // we add the stride and offset here since we access the array directly\n    // below for the sake of performance\n    if (!normalized) {\n      ai = ai * stride + bufferOffset;\n      bi = bi * stride + bufferOffset;\n      ci = ci * stride + bufferOffset;\n    }\n    for (var el = 0; el < 3; el++) {\n      var a = void 0,\n        b = void 0,\n        c = void 0;\n      if (normalized) {\n        a = posAttr[getters[el]](ai);\n        b = posAttr[getters[el]](bi);\n        c = posAttr[getters[el]](ci);\n      } else {\n        a = posArr[ai + el];\n        b = posArr[bi + el];\n        c = posArr[ci + el];\n      }\n      var min = a;\n      if (b < min) min = b;\n      if (c < min) min = c;\n      var max = a;\n      if (b > max) max = b;\n      if (c > max) max = c;\n\n      // Increase the bounds size by float32 epsilon to avoid precision errors when\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n      // worked with.\n      var halfExtents = (max - min) / 2;\n      var el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n      if (min < fullBounds[el]) fullBounds[el] = min;\n      if (max > fullBounds[el + 3]) fullBounds[el + 3] = max;\n    }\n  }\n  return triangleBounds;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}