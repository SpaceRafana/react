{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Color, UniformsUtils, ShaderMaterial, AdditiveBlending, WebGLRenderTarget, HalfFloatType } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nvar SSAARenderPass = /*#__PURE__*/function (_Pass) {\n  _inherits(SSAARenderPass, _Pass);\n  var _super = _createSuper(SSAARenderPass);\n  function SSAARenderPass(scene, camera, clearColor, clearAlpha) {\n    var _this;\n    _classCallCheck(this, SSAARenderPass);\n    _this = _super.call(this);\n    _this.scene = scene;\n    _this.camera = camera;\n    _this.sampleLevel = 4;\n    _this.unbiased = true;\n    _this.clearColor = clearColor !== void 0 ? clearColor : 0;\n    _this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;\n    _this._oldClearColor = new Color();\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.copyMaterial = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      premultipliedAlpha: true,\n      blending: AdditiveBlending\n    });\n    _this.fsQuad = new FullScreenQuad(_this.copyMaterial);\n    return _this;\n  }\n  _createClass(SSAARenderPass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.sampleRenderTarget) {\n        this.sampleRenderTarget.dispose();\n        this.sampleRenderTarget = null;\n      }\n      this.copyMaterial.dispose();\n      this.fsQuad.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer) {\n      if (!this.sampleRenderTarget) {\n        this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n          type: HalfFloatType\n        });\n        this.sampleRenderTarget.texture.name = \"SSAARenderPass.sample\";\n      }\n      var jitterOffsets = _JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n      var autoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      renderer.getClearColor(this._oldClearColor);\n      var oldClearAlpha = renderer.getClearAlpha();\n      var baseSampleWeight = 1 / jitterOffsets.length;\n      var roundingRange = 1 / 32;\n      this.copyUniforms[\"tDiffuse\"].value = this.sampleRenderTarget.texture;\n      var viewOffset = {\n        fullWidth: readBuffer.width,\n        fullHeight: readBuffer.height,\n        offsetX: 0,\n        offsetY: 0,\n        width: readBuffer.width,\n        height: readBuffer.height\n      };\n      var originalViewOffset = Object.assign({}, this.camera.view);\n      if (originalViewOffset.enabled) Object.assign(viewOffset, originalViewOffset);\n      for (var i = 0; i < jitterOffsets.length; i++) {\n        var jitterOffset = jitterOffsets[i];\n        if (this.camera.setViewOffset) {\n          this.camera.setViewOffset(viewOffset.fullWidth, viewOffset.fullHeight, viewOffset.offsetX + jitterOffset[0] * 0.0625, viewOffset.offsetY + jitterOffset[1] * 0.0625,\n          // 0.0625 = 1 / 16\n          viewOffset.width, viewOffset.height);\n        }\n        var sampleWeight = baseSampleWeight;\n        if (this.unbiased) {\n          var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n          sampleWeight += roundingRange * uniformCenteredDistribution;\n        }\n        this.copyUniforms[\"opacity\"].value = sampleWeight;\n        renderer.setClearColor(this.clearColor, this.clearAlpha);\n        renderer.setRenderTarget(this.sampleRenderTarget);\n        renderer.clear();\n        renderer.render(this.scene, this.camera);\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        if (i === 0) {\n          renderer.setClearColor(0, 0);\n          renderer.clear();\n        }\n        this.fsQuad.render(renderer);\n      }\n      if (this.camera.setViewOffset && originalViewOffset.enabled) {\n        this.camera.setViewOffset(originalViewOffset.fullWidth, originalViewOffset.fullHeight, originalViewOffset.offsetX, originalViewOffset.offsetY, originalViewOffset.width, originalViewOffset.height);\n      } else if (this.camera.clearViewOffset) {\n        this.camera.clearViewOffset();\n      }\n      renderer.autoClear = autoClear;\n      renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n    }\n  }]);\n  return SSAARenderPass;\n}(Pass);\nvar _JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\nexport { SSAARenderPass };\n//# sourceMappingURL=SSAARenderPass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}