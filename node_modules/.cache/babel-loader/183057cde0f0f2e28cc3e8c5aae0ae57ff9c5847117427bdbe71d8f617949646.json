{"ast":null,"code":"import _createForOfIteratorHelper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { BufferAttribute } from 'three';\nexport function getVertexCount(geo) {\n  return geo.index ? geo.index.count : geo.attributes.position.count;\n}\nexport function getTriCount(geo) {\n  return getVertexCount(geo) / 3;\n}\nexport function getIndexArray(vertexCount) {\n  var BufferConstructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ArrayBuffer;\n  if (vertexCount > 65535) {\n    return new Uint32Array(new BufferConstructor(4 * vertexCount));\n  } else {\n    return new Uint16Array(new BufferConstructor(2 * vertexCount));\n  }\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex(geo, options) {\n  if (!geo.index) {\n    var vertexCount = geo.attributes.position.count;\n    var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    var index = getIndexArray(vertexCount, BufferConstructor);\n    geo.setIndex(new BufferAttribute(index, 1));\n    for (var i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange(geo) {\n  var triCount = getTriCount(geo);\n  var drawRange = geo.drawRange;\n  var start = drawRange.start / 3;\n  var end = (drawRange.start + drawRange.count) / 3;\n  var offset = Math.max(0, start);\n  var count = Math.min(triCount, end) - offset;\n  return [{\n    offset: Math.floor(offset),\n    count: Math.floor(count)\n  }];\n}\nexport function getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return getFullGeometryRange(geo);\n  }\n  var ranges = [];\n  var rangeBoundaries = new Set();\n  var drawRange = geo.drawRange;\n  var drawRangeStart = drawRange.start / 3;\n  var drawRangeEnd = (drawRange.start + drawRange.count) / 3;\n  var _iterator = _createForOfIteratorHelper(geo.groups),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var group = _step.value;\n      var groupStart = group.start / 3;\n      var groupEnd = (group.start + group.count) / 3;\n      rangeBoundaries.add(Math.max(drawRangeStart, groupStart));\n      rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));\n    }\n\n    // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var sortedBoundaries = Array.from(rangeBoundaries.values()).sort(function (a, b) {\n    return a - b;\n  });\n  for (var i = 0; i < sortedBoundaries.length - 1; i++) {\n    var start = sortedBoundaries[i];\n    var end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: Math.floor(start),\n      count: Math.floor(end - start)\n    });\n  }\n  return ranges;\n}\nexport function hasGroupGaps(geometry) {\n  if (geometry.groups.length === 0) {\n    return false;\n  }\n  var vertexCount = getTriCount(geometry);\n  var groups = getRootIndexRanges(geometry).sort(function (a, b) {\n    return a.offset - b.offset;\n  });\n  var finalGroup = groups[groups.length - 1];\n  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);\n  var total = 0;\n  groups.forEach(function (_ref) {\n    var count = _ref.count;\n    return total += count;\n  });\n  return vertexCount !== total;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}