{"ast":null,"code":"import _regeneratorRuntime from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nfunction AmmoPhysics() {\n  return _AmmoPhysics.apply(this, arguments);\n}\nfunction _AmmoPhysics() {\n  _AmmoPhysics = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var AmmoLib, frameRate, collisionConfiguration, dispatcher, broadphase, solver, world, worldTransform, getShape, meshes, meshMap, addMesh, handleMesh, handleInstancedMesh, setMeshPosition, lastTime, step;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          step = function _step() {\n            var time = performance.now();\n            if (lastTime > 0) {\n              var delta = (time - lastTime) / 1e3;\n              world.stepSimulation(delta, 10);\n            }\n            lastTime = time;\n            for (var i = 0, l = meshes.length; i < l; i++) {\n              var mesh = meshes[i];\n              if (mesh.isInstancedMesh) {\n                var array = mesh.instanceMatrix.array;\n                var bodies = meshMap.get(mesh);\n                for (var j = 0; j < bodies.length; j++) {\n                  var body = bodies[j];\n                  var motionState = body.getMotionState();\n                  motionState.getWorldTransform(worldTransform);\n                  var position = worldTransform.getOrigin();\n                  var quaternion = worldTransform.getRotation();\n                  compose(position, quaternion, array, j * 16);\n                }\n                mesh.instanceMatrix.needsUpdate = true;\n              } else if (mesh.isMesh) {\n                var _body2 = meshMap.get(mesh);\n                var _motionState = _body2.getMotionState();\n                _motionState.getWorldTransform(worldTransform);\n                var _position = worldTransform.getOrigin();\n                var _quaternion = worldTransform.getRotation();\n                mesh.position.set(_position.x(), _position.y(), _position.z());\n                mesh.quaternion.set(_quaternion.x(), _quaternion.y(), _quaternion.z(), _quaternion.w());\n              }\n            }\n          };\n          setMeshPosition = function _setMeshPosition(mesh, position) {\n            var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            if (mesh.isInstancedMesh) {\n              var bodies = meshMap.get(mesh);\n              var body = bodies[index];\n              body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));\n              body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));\n              worldTransform.setIdentity();\n              worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n              body.setWorldTransform(worldTransform);\n            } else if (mesh.isMesh) {\n              var _body = meshMap.get(mesh);\n              _body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));\n              _body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));\n              worldTransform.setIdentity();\n              worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n              _body.setWorldTransform(worldTransform);\n            }\n          };\n          handleInstancedMesh = function _handleInstancedMesh(mesh, mass, shape) {\n            var array = mesh.instanceMatrix.array;\n            var bodies = [];\n            for (var i = 0; i < mesh.count; i++) {\n              var index = i * 16;\n              var transform = new AmmoLib.btTransform();\n              transform.setFromOpenGLMatrix(array.slice(index, index + 16));\n              var motionState = new AmmoLib.btDefaultMotionState(transform);\n              var localInertia = new AmmoLib.btVector3(0, 0, 0);\n              shape.calculateLocalInertia(mass, localInertia);\n              var rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n              var body = new AmmoLib.btRigidBody(rbInfo);\n              world.addRigidBody(body);\n              bodies.push(body);\n            }\n            if (mass > 0) {\n              mesh.instanceMatrix.setUsage(35048);\n              meshes.push(mesh);\n              meshMap.set(mesh, bodies);\n            }\n          };\n          handleMesh = function _handleMesh(mesh, mass, shape) {\n            var position = mesh.position;\n            var quaternion = mesh.quaternion;\n            var transform = new AmmoLib.btTransform();\n            transform.setIdentity();\n            transform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n            transform.setRotation(new AmmoLib.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));\n            var motionState = new AmmoLib.btDefaultMotionState(transform);\n            var localInertia = new AmmoLib.btVector3(0, 0, 0);\n            shape.calculateLocalInertia(mass, localInertia);\n            var rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n            var body = new AmmoLib.btRigidBody(rbInfo);\n            world.addRigidBody(body);\n            if (mass > 0) {\n              meshes.push(mesh);\n              meshMap.set(mesh, body);\n            }\n          };\n          addMesh = function _addMesh(mesh) {\n            var mass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var shape = getShape(mesh.geometry);\n            if (shape !== null) {\n              if (mesh.isInstancedMesh) {\n                handleInstancedMesh(mesh, mass, shape);\n              } else if (mesh.isMesh) {\n                handleMesh(mesh, mass, shape);\n              }\n            }\n          };\n          getShape = function _getShape(geometry) {\n            var parameters = geometry.parameters;\n            if (geometry.type === \"BoxGeometry\") {\n              var sx = parameters.width !== void 0 ? parameters.width / 2 : 0.5;\n              var sy = parameters.height !== void 0 ? parameters.height / 2 : 0.5;\n              var sz = parameters.depth !== void 0 ? parameters.depth / 2 : 0.5;\n              var shape = new AmmoLib.btBoxShape(new AmmoLib.btVector3(sx, sy, sz));\n              shape.setMargin(0.05);\n              return shape;\n            } else if (geometry.type === \"SphereGeometry\" || geometry.type === \"IcosahedronGeometry\") {\n              var radius = parameters.radius !== void 0 ? parameters.radius : 1;\n              var _shape = new AmmoLib.btSphereShape(radius);\n              _shape.setMargin(0.05);\n              return _shape;\n            }\n            return null;\n          };\n          if (!(\"Ammo\" in window === false)) {\n            _context.next = 9;\n            break;\n          }\n          console.error(\"AmmoPhysics: Couldn't find Ammo.js\");\n          return _context.abrupt(\"return\");\n        case 9:\n          _context.next = 11;\n          return Ammo();\n        case 11:\n          AmmoLib = _context.sent;\n          frameRate = 60;\n          collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration();\n          dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration);\n          broadphase = new AmmoLib.btDbvtBroadphase();\n          solver = new AmmoLib.btSequentialImpulseConstraintSolver();\n          world = new AmmoLib.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);\n          world.setGravity(new AmmoLib.btVector3(0, -9.8, 0));\n          worldTransform = new AmmoLib.btTransform();\n          meshes = [];\n          meshMap = /* @__PURE__ */new WeakMap();\n          lastTime = 0;\n          setInterval(step, 1e3 / frameRate);\n          return _context.abrupt(\"return\", {\n            addMesh: addMesh,\n            setMeshPosition: setMeshPosition\n            // addCompoundMesh\n          });\n        case 25:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _AmmoPhysics.apply(this, arguments);\n}\nfunction compose(position, quaternion, array, index) {\n  var x = quaternion.x(),\n    y = quaternion.y(),\n    z = quaternion.z(),\n    w = quaternion.w();\n  var x2 = x + x,\n    y2 = y + y,\n    z2 = z + z;\n  var xx = x * x2,\n    xy = x * y2,\n    xz = x * z2;\n  var yy = y * y2,\n    yz = y * z2,\n    zz = z * z2;\n  var wx = w * x2,\n    wy = w * y2,\n    wz = w * z2;\n  array[index + 0] = 1 - (yy + zz);\n  array[index + 1] = xy + wz;\n  array[index + 2] = xz - wy;\n  array[index + 3] = 0;\n  array[index + 4] = xy - wz;\n  array[index + 5] = 1 - (xx + zz);\n  array[index + 6] = yz + wx;\n  array[index + 7] = 0;\n  array[index + 8] = xz + wy;\n  array[index + 9] = yz - wx;\n  array[index + 10] = 1 - (xx + yy);\n  array[index + 11] = 0;\n  array[index + 12] = position.x();\n  array[index + 13] = position.y();\n  array[index + 14] = position.z();\n  array[index + 15] = 1;\n}\nexport { AmmoPhysics };\n//# sourceMappingURL=AmmoPhysics.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}