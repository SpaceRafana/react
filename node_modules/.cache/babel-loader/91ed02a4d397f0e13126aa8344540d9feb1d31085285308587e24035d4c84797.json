{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Matrix4, Mesh, BufferGeometry, MathUtils, DataTexture, RGBAFormat, FloatType, BufferAttribute } from \"three\";\nvar _identityMatrix = new Matrix4();\nvar _zeroMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\nvar batchingParsVertex = /* glsl */\"\\n#ifdef BATCHING\\n\\tattribute float id;\\n\\tuniform highp sampler2D batchingTexture;\\n\\tuniform int batchingTextureSize;\\n\\tmat4 getBatchingMatrix( const in float i ) {\\n\\t\\tfloat j = i * 4.0;\\n\\t\\tfloat x = mod( j, float( batchingTextureSize ) );\\n\\t\\tfloat y = floor( j / float( batchingTextureSize ) );\\n\\t\\tfloat dx = 1.0 / float( batchingTextureSize );\\n\\t\\tfloat dy = 1.0 / float( batchingTextureSize );\\n\\t\\ty = dy * ( y + 0.5 );\\n\\t\\tvec4 v1 = texture2D( batchingTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\tvec4 v2 = texture2D( batchingTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\tvec4 v3 = texture2D( batchingTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\tvec4 v4 = texture2D( batchingTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\treturn mat4( v1, v2, v3, v4 );\\n\\t}\\n#endif\\n\";\nvar batchingbaseVertex = /* glsl */\"\\n#ifdef BATCHING\\n\\tmat4 batchingMatrix = getBatchingMatrix( id );\\n#endif\\n\";\nvar batchingnormalVertex = /* glsl */\"\\n#ifdef BATCHING\\n\\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\\n\";\nvar batchingVertex = /* glsl */\"\\n#ifdef BATCHING\\n\\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\\n#endif\\n\";\nvar BatchedMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(BatchedMesh, _Mesh);\n  var _super = _createSuper(BatchedMesh);\n  function BatchedMesh(maxGeometryCount, maxVertexCount) {\n    var _this;\n    var maxIndexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : maxVertexCount * 2;\n    var material = arguments.length > 3 ? arguments[3] : undefined;\n    _classCallCheck(this, BatchedMesh);\n    _this = _super.call(this, new BufferGeometry(), material);\n    __publicField(_assertThisInitialized(_this), \"_vertexStarts\");\n    __publicField(_assertThisInitialized(_this), \"_vertexCounts\");\n    __publicField(_assertThisInitialized(_this), \"_indexStarts\");\n    __publicField(_assertThisInitialized(_this), \"_indexCounts\");\n    __publicField(_assertThisInitialized(_this), \"_visibles\");\n    __publicField(_assertThisInitialized(_this), \"_alives\");\n    __publicField(_assertThisInitialized(_this), \"_maxGeometryCount\");\n    __publicField(_assertThisInitialized(_this), \"_maxVertexCount\");\n    __publicField(_assertThisInitialized(_this), \"_maxIndexCount\");\n    __publicField(_assertThisInitialized(_this), \"_geometryInitialized\");\n    __publicField(_assertThisInitialized(_this), \"_geometryCount\");\n    __publicField(_assertThisInitialized(_this), \"_vertexCount\");\n    __publicField(_assertThisInitialized(_this), \"_indexCount\");\n    __publicField(_assertThisInitialized(_this), \"_matrices\");\n    __publicField(_assertThisInitialized(_this), \"_matricesArray\");\n    __publicField(_assertThisInitialized(_this), \"_matricesTexture\");\n    __publicField(_assertThisInitialized(_this), \"_matricesTextureSize\");\n    __publicField(_assertThisInitialized(_this), \"_customUniforms\");\n    _this._vertexStarts = [];\n    _this._vertexCounts = [];\n    _this._indexStarts = [];\n    _this._indexCounts = [];\n    _this._visibles = [];\n    _this._alives = [];\n    _this._maxGeometryCount = maxGeometryCount;\n    _this._maxVertexCount = maxVertexCount;\n    _this._maxIndexCount = maxIndexCount;\n    _this._geometryInitialized = false;\n    _this._geometryCount = 0;\n    _this._vertexCount = 0;\n    _this._indexCount = 0;\n    _this._matrices = [];\n    _this._matricesArray = null;\n    _this._matricesTexture = null;\n    _this._matricesTextureSize = null;\n    _this.frustumCulled = false;\n    _this._customUniforms = {\n      batchingTexture: {\n        value: null\n      },\n      batchingTextureSize: {\n        value: 0\n      }\n    };\n    _this._initMatricesTexture();\n    _this._initShader();\n    return _this;\n  }\n  _createClass(BatchedMesh, [{\n    key: \"_initMatricesTexture\",\n    value: function _initMatricesTexture() {\n      var size = Math.sqrt(this._maxGeometryCount * 4);\n      size = MathUtils.ceilPowerOfTwo(size);\n      size = Math.max(size, 4);\n      var matricesArray = new Float32Array(size * size * 4);\n      var matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);\n      this._matricesArray = matricesArray;\n      this._matricesTexture = matricesTexture;\n      this._matricesTextureSize = size;\n      this._customUniforms.batchingTexture.value = this._matricesTexture;\n      this._customUniforms.batchingTextureSize.value = this._matricesTextureSize;\n    }\n  }, {\n    key: \"_initShader\",\n    value: function _initShader() {\n      var currentOnBeforeCompile = this.material.onBeforeCompile;\n      var customUniforms = this._customUniforms;\n      this.material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n        parameters.vertexShader = parameters.vertexShader.replace(\"#include <skinning_pars_vertex>\", \"#include <skinning_pars_vertex>\\n\" + batchingParsVertex).replace(\"#include <skinnormal_vertex>\", \"#include <skinnormal_vertex>\\n\" + batchingbaseVertex + batchingnormalVertex).replace(\"#include <skinning_vertex>\", \"#include <skinning_vertex>\\n\" + batchingVertex);\n        for (var uniformName in customUniforms) {\n          parameters.uniforms[uniformName] = customUniforms[uniformName];\n        }\n        currentOnBeforeCompile.call(this, parameters, renderer);\n      };\n      this.material.defines = this.material.defines || {};\n      this.material.defines.BATCHING = false;\n    }\n  }, {\n    key: \"getGeometryCount\",\n    value: function getGeometryCount() {\n      return this._geometryCount;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      return this._vertexCount;\n    }\n  }, {\n    key: \"getIndexCount\",\n    value: function getIndexCount() {\n      return this._indexCount;\n    }\n  }, {\n    key: \"applyGeometry\",\n    value: function applyGeometry(geometry) {\n      var _a;\n      if (this._geometryCount >= this._maxGeometryCount) ;\n      if (this._geometryInitialized === false) {\n        for (var attributeName in geometry.attributes) {\n          var srcAttribute = geometry.getAttribute(attributeName);\n          var array = srcAttribute.array,\n            itemSize = srcAttribute.itemSize,\n            normalized = srcAttribute.normalized;\n          var dstArray = new array.constructor(this._maxVertexCount * itemSize);\n          var dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);\n          dstAttribute.setUsage(srcAttribute.usage);\n          this.geometry.setAttribute(attributeName, dstAttribute);\n        }\n        if (geometry.getIndex() !== null) {\n          var indexArray = this._maxVertexCount > 65536 ? new Uint32Array(this._maxIndexCount) : new Uint16Array(this._maxIndexCount);\n          this.geometry.setIndex(new BufferAttribute(indexArray, 1));\n        }\n        var idArray = this._maxGeometryCount > 65536 ? new Uint32Array(this._maxVertexCount) : new Uint16Array(this._maxVertexCount);\n        this.geometry.setAttribute(\"id\", new BufferAttribute(idArray, 1));\n        this._geometryInitialized = true;\n      }\n      var hasIndex = this.geometry.getIndex() !== null;\n      var dstIndex = this.geometry.getIndex();\n      var srcIndex = geometry.getIndex();\n      var srcPositionAttribute = geometry.getAttribute(\"position\");\n      this._vertexStarts.push(this._vertexCount);\n      this._vertexCounts.push(srcPositionAttribute.count);\n      if (hasIndex) {\n        this._indexStarts.push(this._indexCount);\n        this._indexCounts.push(srcIndex.count);\n      }\n      this._visibles.push(true);\n      this._alives.push(true);\n      for (var _attributeName in geometry.attributes) {\n        var _srcAttribute = geometry.getAttribute(_attributeName);\n        var _dstAttribute = this.geometry.getAttribute(_attributeName);\n        _dstAttribute.array.set(_srcAttribute.array, this._vertexCount * _dstAttribute.itemSize);\n        _dstAttribute.needsUpdate = true;\n      }\n      if (hasIndex) {\n        for (var i = 0; i < srcIndex.count; i++) {\n          dstIndex.setX(this._indexCount + i, this._vertexCount + srcIndex.getX(i));\n        }\n        this._indexCount += srcIndex.count;\n        dstIndex.needsUpdate = true;\n      }\n      var geometryId = this._geometryCount;\n      this._geometryCount++;\n      var idAttribute = this.geometry.getAttribute(\"id\");\n      for (var _i = 0; _i < srcPositionAttribute.count; _i++) {\n        idAttribute.setX(this._vertexCount + _i, geometryId);\n      }\n      idAttribute.needsUpdate = true;\n      this._vertexCount += srcPositionAttribute.count;\n      this._matrices.push(new Matrix4());\n      _identityMatrix.toArray((_a = this._matricesArray) != null ? _a : void 0, geometryId * 16);\n      this._matricesTexture.needsUpdate = true;\n      return geometryId;\n    }\n  }, {\n    key: \"deleteGeometry\",\n    value: function deleteGeometry(geometryId) {\n      if (geometryId >= this._alives.length || this._alives[geometryId] === false) {\n        return this;\n      }\n      this._alives[geometryId] = false;\n      _zeroMatrix.toArray(this._matricesArray, geometryId * 16);\n      this._matricesTexture.needsUpdate = true;\n      return this;\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize() {\n      return this;\n    }\n  }, {\n    key: \"setMatrixAt\",\n    value: function setMatrixAt(geometryId, matrix) {\n      if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {\n        return this;\n      }\n      this._matrices[geometryId].copy(matrix);\n      if (this._visibles[geometryId] === true) {\n        matrix.toArray(this._matricesArray, geometryId * 16);\n        this._matricesTexture.needsUpdate = true;\n      }\n      return this;\n    }\n  }, {\n    key: \"getMatrixAt\",\n    value: function getMatrixAt(geometryId, matrix) {\n      if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {\n        return matrix;\n      }\n      return matrix.copy(this._matrices[geometryId]);\n    }\n  }, {\n    key: \"setVisibleAt\",\n    value: function setVisibleAt(geometryId, visible) {\n      if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {\n        return this;\n      }\n      if (this._visibles[geometryId] === visible) {\n        return this;\n      }\n      if (visible === true) {\n        this._matrices[geometryId].toArray(this._matricesArray, geometryId * 16);\n      } else {\n        _zeroMatrix.toArray(this._matricesArray, geometryId * 16);\n      }\n      this._matricesTexture.needsUpdate = true;\n      this._visibles[geometryId] = visible;\n      return this;\n    }\n  }, {\n    key: \"getVisibleAt\",\n    value: function getVisibleAt(geometryId) {\n      if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {\n        return false;\n      }\n      return this._visibles[geometryId];\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(BatchedMesh.prototype), \"copy\", this).call(this, source);\n      return this;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(meta) {\n      return _get(_getPrototypeOf(BatchedMesh.prototype), \"toJSON\", this).call(this, meta);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _a;\n      this.geometry.dispose();\n      (_a = this._matricesTexture) == null ? void 0 : _a.dispose();\n      this._matricesTexture = null;\n      return this;\n    }\n    // @ts-ignore\n  }, {\n    key: \"onBeforeRender\",\n    value: function onBeforeRender() {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = true;\n      }\n    }\n    // @ts-ignore\n  }, {\n    key: \"onAfterRender\",\n    value: function onAfterRender() {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = false;\n      }\n    }\n  }]);\n  return BatchedMesh;\n}(Mesh);\nexport { BatchedMesh };\n//# sourceMappingURL=BatchedMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}