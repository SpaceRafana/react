{"ast":null,"code":"import _slicedToArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\", \"events\", \"blur\", \"eventPriority\", \"renderPriority\", \"worldUnits\", \"resolution\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { useIntersect } from './useIntersect.js';\nimport { useFBO } from './useFBO.js';\nimport { RenderTexture } from './RenderTexture.js';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { FullScreenQuad } from 'three-stdlib';\nimport { version } from '../helpers/constants.js';\nvar PortalMaterialImpl = /* @__PURE__ */shaderMaterial({\n  blur: 0,\n  map: null,\n  sdf: null,\n  blend: 0,\n  size: 0,\n  resolution: /* @__PURE__ */new THREE.Vector2()\n}, \"varying vec2 vUv;\\n   void main() {\\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n     vUv = uv;\\n   }\", \"uniform sampler2D sdf;\\n   uniform sampler2D map;\\n   uniform float blur;\\n   uniform float size;\\n   uniform float time;\\n   uniform vec2 resolution;\\n   varying vec2 vUv;\\n   #include <packing>\\n   void main() {\\n     vec2 uv = gl_FragCoord.xy / resolution.xy;\\n     vec4 t = texture2D(map, uv);\\n     float k = blur;\\n     float d = texture2D(sdf, vUv).r/size;\\n     float alpha = 1.0 - smoothstep(0.0, 1.0, clamp(d/k + 1.0, 0.0, 1.0));\\n     gl_FragColor = vec4(t.rgb, blur == 0.0 ? t.a : t.a * alpha);\\n     #include <tonemapping_fragment>\\n     #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n   }\"));\nvar MeshPortalMaterial = /* @__PURE__ */React.forwardRef(function (_ref, fref) {\n  var children = _ref.children,\n    _ref$events = _ref.events,\n    events = _ref$events === void 0 ? undefined : _ref$events,\n    _ref$blur = _ref.blur,\n    blur = _ref$blur === void 0 ? 0 : _ref$blur,\n    _ref$eventPriority = _ref.eventPriority,\n    eventPriority = _ref$eventPriority === void 0 ? 0 : _ref$eventPriority,\n    _ref$renderPriority = _ref.renderPriority,\n    renderPriority = _ref$renderPriority === void 0 ? 0 : _ref$renderPriority,\n    _ref$worldUnits = _ref.worldUnits,\n    worldUnits = _ref$worldUnits === void 0 ? false : _ref$worldUnits,\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? 512 : _ref$resolution,\n    props = _objectWithoutProperties(_ref, _excluded);\n  extend({\n    PortalMaterialImpl: PortalMaterialImpl\n  });\n  var ref = React.useRef(null);\n  var _useThree = useThree(),\n    scene = _useThree.scene,\n    gl = _useThree.gl,\n    size = _useThree.size,\n    viewport = _useThree.viewport,\n    setEvents = _useThree.setEvents;\n  var maskRenderTarget = useFBO(resolution, resolution);\n  var _React$useState = React.useState(0),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    priority = _React$useState2[0],\n    setPriority = _React$useState2[1];\n  useFrame(function () {\n    // If blend is > 0 then the portal is being entered, the render-priority must change\n    var p = ref.current.blend > 0 ? Math.max(1, renderPriority) : 0;\n    if (priority !== p) setPriority(p);\n  });\n  React.useEffect(function () {\n    if (events !== undefined) setEvents({\n      enabled: !events\n    });\n  }, [events]);\n  var _React$useState3 = React.useState(true),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    visible = _React$useState4[0],\n    setVisible = _React$useState4[1];\n  // See if the parent mesh is in the camera frustum\n  var parent = useIntersect(setVisible);\n  React.useLayoutEffect(function () {\n    var _ref$current;\n    // Since the ref above is not tied to a mesh directly (we're inside a material),\n    // it has to be tied to the parent mesh here\n    parent.current = (_ref$current = ref.current) == null ? void 0 : _ref$current.__r3f.parent;\n  }, []);\n  React.useLayoutEffect(function () {\n    if (!parent.current) return;\n\n    // Apply the SDF mask only once\n    if (blur && ref.current.sdf === null) {\n      var tempMesh = new THREE.Mesh(parent.current.geometry, new THREE.MeshBasicMaterial());\n      var boundingBox = new THREE.Box3().setFromBufferAttribute(tempMesh.geometry.attributes.position);\n      var orthoCam = new THREE.OrthographicCamera(boundingBox.min.x * (1 + 2 / resolution), boundingBox.max.x * (1 + 2 / resolution), boundingBox.max.y * (1 + 2 / resolution), boundingBox.min.y * (1 + 2 / resolution), 0.1, 1000);\n      orthoCam.position.set(0, 0, 1);\n      orthoCam.lookAt(0, 0, 0);\n      gl.setRenderTarget(maskRenderTarget);\n      gl.render(tempMesh, orthoCam);\n      var sg = makeSDFGenerator(resolution, resolution, gl);\n      var sdf = sg(maskRenderTarget.texture);\n      var readSdf = new Float32Array(resolution * resolution);\n      gl.readRenderTargetPixels(sdf, 0, 0, resolution, resolution, readSdf);\n      // Get smallest value in sdf\n      var min = Infinity;\n      for (var i = 0; i < readSdf.length; i++) {\n        if (readSdf[i] < min) min = readSdf[i];\n      }\n      min = -min;\n      ref.current.size = min;\n      ref.current.sdf = sdf.texture;\n      gl.setRenderTarget(null);\n    }\n  }, [resolution, blur]);\n  React.useImperativeHandle(fref, function () {\n    return ref.current;\n  });\n  var compute = React.useCallback(function (event, state, previous) {\n    var _ref$current2;\n    if (!parent.current) return false;\n    state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n    state.raycaster.setFromCamera(state.pointer, state.camera);\n    if (((_ref$current2 = ref.current) == null ? void 0 : _ref$current2.blend) === 0) {\n      // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n      var _state$raycaster$inte = state.raycaster.intersectObject(parent.current),\n        _state$raycaster$inte2 = _slicedToArray(_state$raycaster$inte, 1),\n        intersection = _state$raycaster$inte2[0];\n      if (!intersection) {\n        // Cancel out the raycast camera if the parent mesh isn't hit\n        state.raycaster.camera = undefined;\n        return false;\n      }\n    }\n  }, []);\n  return /*#__PURE__*/React.createElement(\"portalMaterialImpl\", _extends({\n    ref: ref,\n    blur: blur,\n    blend: 0,\n    resolution: [size.width * viewport.dpr, size.height * viewport.dpr],\n    toneMapped: false,\n    attach: \"material\"\n  }, props), /*#__PURE__*/React.createElement(RenderTexture, {\n    attach: \"map\",\n    frames: visible ? Infinity : 0,\n    eventPriority: eventPriority,\n    renderPriority: renderPriority,\n    compute: compute\n  }, children, /*#__PURE__*/React.createElement(ManagePortalScene, {\n    events: events,\n    rootScene: scene,\n    priority: priority,\n    material: ref,\n    worldUnits: worldUnits\n  })));\n});\nfunction ManagePortalScene(_ref2) {\n  var _ref2$events = _ref2.events,\n    events = _ref2$events === void 0 ? undefined : _ref2$events,\n    rootScene = _ref2.rootScene,\n    material = _ref2.material,\n    priority = _ref2.priority,\n    worldUnits = _ref2.worldUnits;\n  var scene = useThree(function (state) {\n    return state.scene;\n  });\n  var setEvents = useThree(function (state) {\n    return state.setEvents;\n  });\n  var buffer1 = useFBO();\n  var buffer2 = useFBO();\n  React.useLayoutEffect(function () {\n    scene.matrixAutoUpdate = false;\n  }, []);\n  React.useEffect(function () {\n    if (events !== undefined) setEvents({\n      enabled: events\n    });\n  }, [events]);\n  var _React$useMemo = React.useMemo(function () {\n      // This fullscreen-quad is used to blend the two textures\n      var blend = {\n        value: 0\n      };\n      var quad = new FullScreenQuad(new THREE.ShaderMaterial({\n        uniforms: {\n          a: {\n            value: buffer1.texture\n          },\n          b: {\n            value: buffer2.texture\n          },\n          blend: blend\n        },\n        vertexShader: /*glsl*/\"\\n          varying vec2 vUv;\\n          void main() {\\n            vUv = uv;\\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n          }\",\n        fragmentShader: /*glsl*/\"\\n          uniform sampler2D a;\\n          uniform sampler2D b;\\n          uniform float blend;\\n          varying vec2 vUv;\\n          #include <packing>\\n          void main() {\\n            vec4 ta = texture2D(a, vUv);\\n            vec4 tb = texture2D(b, vUv);\\n            gl_FragColor = mix(tb, ta, blend);\\n            #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n          }\")\n      }));\n      return [quad, blend];\n    }, []),\n    _React$useMemo2 = _slicedToArray(_React$useMemo, 2),\n    quad = _React$useMemo2[0],\n    blend = _React$useMemo2[1];\n  useFrame(function (state) {\n    var _material$current;\n    var parent = material == null || (_material$current = material.current) == null ? void 0 : _material$current.__r3f.parent;\n    if (parent) {\n      // Move portal contents along with the parent if worldUnits is true\n      if (!worldUnits) {\n        var _material$current2;\n        // If the portal renders exclusively the original scene needs to be updated\n        if (priority && ((_material$current2 = material.current) == null ? void 0 : _material$current2.blend) === 1) parent.updateWorldMatrix(true, false);\n        scene.matrixWorld.copy(parent.matrixWorld);\n      } else scene.matrixWorld.identity();\n\n      // This bit is only necessary if the portal is blended, now it has a render-priority\n      // and will take over the render loop\n      if (priority) {\n        var _material$current3, _material$current4, _material$current5;\n        if (((_material$current3 = material.current) == null ? void 0 : _material$current3.blend) > 0 && ((_material$current4 = material.current) == null ? void 0 : _material$current4.blend) < 1) {\n          // If blend is ongoing (> 0 and < 1) then we need to render both the root scene\n          // and the portal scene, both will then be mixed in the quad from above\n          blend.value = material.current.blend;\n          state.gl.setRenderTarget(buffer1);\n          state.gl.render(scene, state.camera);\n          state.gl.setRenderTarget(buffer2);\n          state.gl.render(rootScene, state.camera);\n          state.gl.setRenderTarget(null);\n          quad.render(state.gl);\n        } else if (((_material$current5 = material.current) == null ? void 0 : _material$current5.blend) === 1) {\n          // However if blend is 1 we only need to render the portal scene\n          state.gl.render(scene, state.camera);\n        }\n      }\n    }\n  }, priority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null);\n}\nvar makeSDFGenerator = function makeSDFGenerator(clientWidth, clientHeight, renderer) {\n  var finalTarget = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.LinearMipmapLinearFilter,\n    magFilter: THREE.LinearFilter,\n    type: THREE.FloatType,\n    format: THREE.RedFormat,\n    generateMipmaps: true\n  });\n  var outsideRenderTarget = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  var insideRenderTarget = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  var outsideRenderTarget2 = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  var insideRenderTarget2 = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter\n  });\n  var outsideRenderTargetFinal = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter,\n    type: THREE.FloatType,\n    format: THREE.RedFormat\n  });\n  var insideRenderTargetFinal = new THREE.WebGLRenderTarget(clientWidth, clientHeight, {\n    minFilter: THREE.NearestFilter,\n    magFilter: THREE.NearestFilter,\n    type: THREE.FloatType,\n    format: THREE.RedFormat\n  });\n  var uvRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      }\n    },\n    vertexShader: /*glsl*/\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",\n    fragmentShader: /*glsl*/\"\\n        uniform sampler2D tex;\\n        varying vec2 vUv;\\n        #include <packing>\\n        void main() {\\n          gl_FragColor = pack2HalfToRGBA(vUv * (round(texture2D(tex, vUv).x)));\\n        }\"\n  }));\n  var uvRenderInside = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      }\n    },\n    vertexShader: /*glsl*/\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",\n    fragmentShader: /*glsl*/\"\\n        uniform sampler2D tex;\\n        varying vec2 vUv;\\n        #include <packing>\\n        void main() {\\n          gl_FragColor = pack2HalfToRGBA(vUv * (1.0 - round(texture2D(tex, vUv).x)));\\n        }\"\n  }));\n  var jumpFloodRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      },\n      offset: {\n        value: 0.0\n      },\n      level: {\n        value: 0.0\n      },\n      maxSteps: {\n        value: 0.0\n      }\n    },\n    vertexShader: /*glsl*/\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",\n    fragmentShader: /*glsl*/\"\\n        varying vec2 vUv;\\n        uniform sampler2D tex;\\n        uniform float offset;\\n        uniform float level;\\n        uniform float maxSteps;\\n        #include <packing>\\n        void main() {\\n          float closestDist = 9999999.9;\\n          vec2 closestPos = vec2(0.0);\\n          for (float x = -1.0; x <= 1.0; x += 1.0) {\\n            for (float y = -1.0; y <= 1.0; y += 1.0) {\\n              vec2 voffset = vUv;\\n              voffset += vec2(x, y) * vec2(\".concat(1 / clientWidth, \", \").concat(1 / clientHeight, \") * offset;\\n              vec2 pos = unpackRGBATo2Half(texture2D(tex, voffset));\\n              float dist = distance(pos.xy, vUv);\\n              if(pos.x != 0.0 && pos.y != 0.0 && dist < closestDist) {\\n                closestDist = dist;\\n                closestPos = pos;\\n              }\\n            }\\n          }\\n          gl_FragColor = pack2HalfToRGBA(closestPos);\\n        }\")\n  }));\n  var distanceFieldRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      tex: {\n        value: null\n      },\n      size: {\n        value: new THREE.Vector2(clientWidth, clientHeight)\n      }\n    },\n    vertexShader: /*glsl*/\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",\n    fragmentShader: /*glsl*/\"\\n        varying vec2 vUv;\\n        uniform sampler2D tex;\\n        uniform vec2 size;\\n        #include <packing>\\n        void main() {\\n          gl_FragColor = vec4(distance(size * unpackRGBATo2Half(texture2D(tex, vUv)), size * vUv), 0.0, 0.0, 0.0);\\n        }\"\n  }));\n  var compositeRender = new FullScreenQuad(new THREE.ShaderMaterial({\n    uniforms: {\n      inside: {\n        value: insideRenderTargetFinal.texture\n      },\n      outside: {\n        value: outsideRenderTargetFinal.texture\n      },\n      tex: {\n        value: null\n      }\n    },\n    vertexShader: /*glsl*/\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",\n    fragmentShader: /*glsl*/\"\\n        varying vec2 vUv;\\n        uniform sampler2D inside;\\n        uniform sampler2D outside;\\n        uniform sampler2D tex;\\n        #include <packing>\\n        void main() {\\n          float i = texture2D(inside, vUv).x;\\n          float o =texture2D(outside, vUv).x;\\n          if (texture2D(tex, vUv).x == 0.0) {\\n            gl_FragColor = vec4(o, 0.0, 0.0, 0.0);\\n          } else {\\n            gl_FragColor = vec4(-i, 0.0, 0.0, 0.0);\\n          }\\n        }\"\n  }));\n  return function (image) {\n    var ft = finalTarget;\n    image.minFilter = THREE.NearestFilter;\n    image.magFilter = THREE.NearestFilter;\n    uvRender.material.uniforms.tex.value = image;\n    renderer.setRenderTarget(outsideRenderTarget);\n    uvRender.render(renderer);\n    var passes = Math.ceil(Math.log(Math.max(clientWidth, clientHeight)) / Math.log(2.0));\n    var lastTarget = outsideRenderTarget;\n    var target = null;\n    for (var i = 0; i < passes; i++) {\n      var offset = Math.pow(2, passes - i - 1);\n      target = lastTarget === outsideRenderTarget ? outsideRenderTarget2 : outsideRenderTarget;\n      jumpFloodRender.material.uniforms.level.value = i;\n      jumpFloodRender.material.uniforms.maxSteps.value = passes;\n      jumpFloodRender.material.uniforms.offset.value = offset;\n      jumpFloodRender.material.uniforms.tex.value = lastTarget.texture;\n      renderer.setRenderTarget(target);\n      jumpFloodRender.render(renderer);\n      lastTarget = target;\n    }\n    renderer.setRenderTarget(outsideRenderTargetFinal);\n    distanceFieldRender.material.uniforms.tex.value = target.texture;\n    distanceFieldRender.render(renderer);\n    uvRenderInside.material.uniforms.tex.value = image;\n    renderer.setRenderTarget(insideRenderTarget);\n    uvRenderInside.render(renderer);\n    lastTarget = insideRenderTarget;\n    for (var _i = 0; _i < passes; _i++) {\n      var _offset = Math.pow(2, passes - _i - 1);\n      target = lastTarget === insideRenderTarget ? insideRenderTarget2 : insideRenderTarget;\n      jumpFloodRender.material.uniforms.level.value = _i;\n      jumpFloodRender.material.uniforms.maxSteps.value = passes;\n      jumpFloodRender.material.uniforms.offset.value = _offset;\n      jumpFloodRender.material.uniforms.tex.value = lastTarget.texture;\n      renderer.setRenderTarget(target);\n      jumpFloodRender.render(renderer);\n      lastTarget = target;\n    }\n    renderer.setRenderTarget(insideRenderTargetFinal);\n    distanceFieldRender.material.uniforms.tex.value = target.texture;\n    distanceFieldRender.render(renderer);\n    renderer.setRenderTarget(ft);\n    compositeRender.material.uniforms.tex.value = image;\n    compositeRender.render(renderer);\n    renderer.setRenderTarget(null);\n    return ft;\n  };\n};\nexport { MeshPortalMaterial };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}