{"ast":null,"code":"import Node, { addNodeClass } from '../core/Node.js';\nimport { vectorComponents } from '../core/constants.js';\nconst stringVectorComponents = vectorComponents.join('');\nclass SplitNode extends Node {\n  constructor(node, components = 'x') {\n    super();\n    this.node = node;\n    this.components = components;\n  }\n  getVectorLength() {\n    let vectorLength = this.components.length;\n    for (const c of this.components) {\n      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);\n    }\n    return vectorLength;\n  }\n  getNodeType(builder) {\n    return builder.getTypeFromLength(this.components.length);\n  }\n  generate(builder, output) {\n    const node = this.node;\n    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));\n    let snippet = null;\n    if (nodeTypeLength > 1) {\n      let type = null;\n      const componentsLength = this.getVectorLength();\n      if (componentsLength >= nodeTypeLength) {\n        // needed expand the input node\n\n        type = builder.getTypeFromLength(this.getVectorLength());\n      }\n      const nodeSnippet = node.build(builder, type);\n      if (this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice(0, this.components.length)) {\n        // unnecessary swizzle\n\n        snippet = builder.format(nodeSnippet, type, output);\n      } else {\n        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);\n      }\n    } else {\n      // ignore .components if .node returns float/integer\n\n      snippet = node.build(builder, output);\n    }\n    return snippet;\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.components = this.components;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.components = data.components;\n  }\n}\nexport default SplitNode;\naddNodeClass('SplitNode', SplitNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}