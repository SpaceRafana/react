{"ast":null,"code":"import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect(bvh) {\n  var nodeIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (nodeIndices && Array.isArray(nodeIndices)) {\n    nodeIndices = new Set(nodeIndices);\n  }\n  var geometry = bvh.geometry;\n  var indexArr = geometry.index ? geometry.index.array : null;\n  var posAttr = geometry.attributes.position;\n  var buffer, uint32Array, uint16Array, float32Array;\n  var byteOffset = 0;\n  var roots = bvh._roots;\n  for (var i = 0, l = roots.length; i < l; i++) {\n    buffer = roots[i];\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    float32Array = new Float32Array(buffer);\n    _traverse(0, byteOffset);\n    byteOffset += buffer.byteLength;\n  }\n  function _traverse(node32Index, byteOffset) {\n    var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var node16Index = node32Index * 2;\n    var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n    if (isLeaf) {\n      var offset = uint32Array[node32Index + 6];\n      var count = uint16Array[node16Index + 14];\n      var minx = Infinity;\n      var miny = Infinity;\n      var minz = Infinity;\n      var maxx = -Infinity;\n      var maxy = -Infinity;\n      var maxz = -Infinity;\n      for (var _i = offset, _l = offset + count; _i < _l; _i++) {\n        var t = 3 * bvh.resolveTriangleIndex(_i);\n        for (var j = 0; j < 3; j++) {\n          var index = t + j;\n          index = indexArr ? indexArr[index] : index;\n          var x = posAttr.getX(index);\n          var y = posAttr.getY(index);\n          var z = posAttr.getZ(index);\n          if (x < minx) minx = x;\n          if (x > maxx) maxx = x;\n          if (y < miny) miny = y;\n          if (y > maxy) maxy = y;\n          if (z < minz) minz = z;\n          if (z > maxz) maxz = z;\n        }\n      }\n      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n        float32Array[node32Index + 0] = minx;\n        float32Array[node32Index + 1] = miny;\n        float32Array[node32Index + 2] = minz;\n        float32Array[node32Index + 3] = maxx;\n        float32Array[node32Index + 4] = maxy;\n        float32Array[node32Index + 5] = maxz;\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      var left = node32Index + 8;\n      var right = uint32Array[node32Index + 6];\n\n      // the identifying node indices provided by the shapecast function include offsets of all\n      // root buffers to guarantee they're unique between roots so offset left and right indices here.\n      var offsetLeft = left + byteOffset;\n      var offsetRight = right + byteOffset;\n      var forceChildren = force;\n      var includesLeft = false;\n      var includesRight = false;\n      if (nodeIndices) {\n        // if we see that neither the left or right child are included in the set that need to be updated\n        // then we assume that all children need to be updated.\n        if (!forceChildren) {\n          includesLeft = nodeIndices.has(offsetLeft);\n          includesRight = nodeIndices.has(offsetRight);\n          forceChildren = !includesLeft && !includesRight;\n        }\n      } else {\n        includesLeft = true;\n        includesRight = true;\n      }\n      var traverseLeft = forceChildren || includesLeft;\n      var traverseRight = forceChildren || includesRight;\n      var leftChange = false;\n      if (traverseLeft) {\n        leftChange = _traverse(left, byteOffset, forceChildren);\n      }\n      var rightChange = false;\n      if (traverseRight) {\n        rightChange = _traverse(right, byteOffset, forceChildren);\n      }\n      var didChange = leftChange || rightChange;\n      if (didChange) {\n        for (var _i2 = 0; _i2 < 3; _i2++) {\n          var lefti = left + _i2;\n          var righti = right + _i2;\n          var minLeftValue = float32Array[lefti];\n          var maxLeftValue = float32Array[lefti + 3];\n          var minRightValue = float32Array[righti];\n          var maxRightValue = float32Array[righti + 3];\n          float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n          float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n        }\n      }\n      return didChange;\n    }\n  }\n}\nexport { refit_indirect };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}