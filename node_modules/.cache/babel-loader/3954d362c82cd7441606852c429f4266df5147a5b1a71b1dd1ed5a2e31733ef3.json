{"ast":null,"code":"import _regeneratorRuntime from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, Ray, Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, REVISION, BufferGeometry, BufferAttribute, LineSegments, Mesh, Matrix4, Group } from \"three\";\nvar FINISH_TYPE_DEFAULT = 0;\nvar FINISH_TYPE_CHROME = 1;\nvar FINISH_TYPE_PEARLESCENT = 2;\nvar FINISH_TYPE_RUBBER = 3;\nvar FINISH_TYPE_MATTE_METALLIC = 4;\nvar FINISH_TYPE_METAL = 5;\nvar FILE_LOCATION_AS_IS = 0;\nvar FILE_LOCATION_TRY_PARTS = 1;\nvar FILE_LOCATION_TRY_P = 2;\nvar FILE_LOCATION_TRY_MODELS = 3;\nvar FILE_LOCATION_TRY_RELATIVE = 4;\nvar FILE_LOCATION_TRY_ABSOLUTE = 5;\nvar FILE_LOCATION_NOT_FOUND = 6;\nvar MAIN_COLOUR_CODE = \"16\";\nvar MAIN_EDGE_COLOUR_CODE = \"24\";\nvar _tempVec0 = new Vector3();\nvar _tempVec1 = new Vector3();\nvar LDrawConditionalLineMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(LDrawConditionalLineMaterial, _ShaderMaterial);\n  var _super = _createSuper(LDrawConditionalLineMaterial);\n  function LDrawConditionalLineMaterial(parameters) {\n    var _this;\n    _classCallCheck(this, LDrawConditionalLineMaterial);\n    _this = _super.call(this, {\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1\n        }\n      }]),\n      vertexShader: /* glsl */\"\\n        attribute vec3 control0;\\n        attribute vec3 control1;\\n        attribute vec3 direction;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_vertex>\\n        #include <fog_pars_vertex>\\n        #include <logdepthbuf_pars_vertex>\\n        #include <clipping_planes_pars_vertex>\\n\\n        void main() {\\n          #include <color_vertex>\\n\\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n          gl_Position = projectionMatrix * mvPosition;\\n\\n          // Transform the line segment ends and control points into camera clip space\\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\\n\\n          c0.xy /= c0.w;\\n          c1.xy /= c1.w;\\n          p0.xy /= p0.w;\\n          p1.xy /= p1.w;\\n\\n          // Get the direction of the segment and an orthogonal vector\\n          vec2 dir = p1.xy - p0.xy;\\n          vec2 norm = vec2(-dir.y, dir.x);\\n\\n          // Get control point directions from the line\\n          vec2 c0dir = c0.xy - p1.xy;\\n          vec2 c1dir = c1.xy - p1.xy;\\n\\n          // If the vectors to the controls points are pointed in different directions away\\n          // from the line segment then the line should not be drawn.\\n          float d0 = dot(normalize(norm), normalize(c0dir));\\n          float d1 = dot(normalize(norm), normalize(c1dir));\\n          discardFlag = float(sign(d0) != sign(d1));\\n\\n          #include <logdepthbuf_vertex>\\n          #include <clipping_planes_vertex>\\n          #include <fog_vertex>\\n        }\\n      \",\n      fragmentShader: /* glsl */\"\\n        uniform vec3 diffuse;\\n        uniform float opacity;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_fragment>\\n        #include <fog_pars_fragment>\\n        #include <logdepthbuf_pars_fragment>\\n        #include <clipping_planes_pars_fragment>\\n\\n        void main() {\\n          if (discardFlag > 0.5) discard;\\n\\n          #include <clipping_planes_fragment>\\n          vec3 outgoingLight = vec3(0.0);\\n          vec4 diffuseColor = vec4(diffuse, opacity);\\n          #include <logdepthbuf_fragment>\\n          #include <color_fragment>\\n          outgoingLight = diffuseColor.rgb; // simple shader\\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\\n          #include <tonemapping_fragment>\\n          #include <\".concat(parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\", \">\\n          #include <fog_fragment>\\n          #include <premultiplied_alpha_fragment>\\n        }\\n      \")\n    });\n    Object.defineProperties(_assertThisInitialized(_this), {\n      opacity: {\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function get() {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    _this.setValues(parameters);\n    _this.isLDrawConditionalLineMaterial = true;\n    return _this;\n  }\n  return _createClass(LDrawConditionalLineMaterial);\n}(ShaderMaterial);\nvar ConditionalLineSegments = /*#__PURE__*/function (_LineSegments) {\n  _inherits(ConditionalLineSegments, _LineSegments);\n  var _super2 = _createSuper(ConditionalLineSegments);\n  function ConditionalLineSegments(geometry, material) {\n    var _this2;\n    _classCallCheck(this, ConditionalLineSegments);\n    _this2 = _super2.call(this, geometry, material);\n    _this2.isConditionalLine = true;\n    return _this2;\n  }\n  return _createClass(ConditionalLineSegments);\n}(LineSegments);\nfunction generateFaceNormals(faces) {\n  for (var i = 0, l = faces.length; i < l; i++) {\n    var face = faces[i];\n    var vertices = face.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    var v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nvar _ray = new Ray();\nfunction smoothNormals(faces, lineSegments) {\n  var checkSubSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var hashMultiplier = (1 + 1e-10) * 100;\n  function hashVertex(v) {\n    var x = ~~(v.x * hashMultiplier);\n    var y = ~~(v.y * hashMultiplier);\n    var z = ~~(v.z * hashMultiplier);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n  function hashEdge(v0, v1) {\n    return \"\".concat(hashVertex(v0), \"_\").concat(hashVertex(v1));\n  }\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    var scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  var hardEdges = /* @__PURE__ */new Set();\n  var hardEdgeRays = /* @__PURE__ */new Map();\n  var halfEdgeList = {};\n  var normals = [];\n  for (var i = 0, l = lineSegments.length; i < l; i++) {\n    var ls = lineSegments[i];\n    var vertices = ls.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n    if (checkSubSegments) {\n      var ray = toNormalizedRay(v0, v1, new Ray());\n      var rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        var rh2 = hashRay(ray);\n        var info2 = {\n          ray: ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n      var info = hardEdgeRays.get(rh1);\n      var d0 = info.ray.direction.dot(v0);\n      var d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        var _ref = [d1, d0];\n        d0 = _ref[0];\n        d1 = _ref[1];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n  for (var _i = 0, _l = faces.length; _i < _l; _i++) {\n    var tri = faces[_i];\n    var _vertices = tri.vertices;\n    var vertCount = _vertices.length;\n    for (var i2 = 0; i2 < vertCount; i2++) {\n      var index = i2;\n      var next = (i2 + 1) % vertCount;\n      var _v = _vertices[index];\n      var _v2 = _vertices[next];\n      var hash = hashEdge(_v, _v2);\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n      if (checkSubSegments) {\n        toNormalizedRay(_v, _v2, _ray);\n        var rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          var _info = hardEdgeRays.get(rayHash);\n          var _ray2 = _info.ray,\n            distances = _info.distances;\n          var _d = _ray2.direction.dot(_v);\n          var _d2 = _ray2.direction.dot(_v2);\n          if (_d > _d2) {\n            var _ref2 = [_d2, _d];\n            _d = _ref2[0];\n            _d2 = _ref2[1];\n          }\n          var found = false;\n          for (var i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (_d >= distances[i3] && _d2 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      var _info2 = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = _info2;\n    }\n  }\n  while (true) {\n    var halfEdge = null;\n    for (var key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n    var queue = [halfEdge];\n    while (queue.length > 0) {\n      var _tri = queue.pop().tri;\n      var _vertices2 = _tri.vertices;\n      var vertNormals = _tri.normals;\n      var faceNormal = _tri.faceNormal;\n      var _vertCount = _vertices2.length;\n      for (var _i2 = 0; _i2 < _vertCount; _i2++) {\n        var _index = _i2;\n        var _next = (_i2 + 1) % _vertCount;\n        var _v3 = _vertices2[_index];\n        var _v4 = _vertices2[_next];\n        var _hash = hashEdge(_v3, _v4);\n        delete halfEdgeList[_hash];\n        var reverseHash = hashEdge(_v4, _v3);\n        var otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          var otherTri = otherInfo.tri;\n          var otherIndex = otherInfo.index;\n          var otherNormals = otherTri.normals;\n          var otherVertCount = otherNormals.length;\n          var otherFaceNormal = otherTri.faceNormal;\n          if (Math.abs(otherTri.faceNormal.dot(_tri.faceNormal)) < 0.25) {\n            continue;\n          }\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n          var otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[_index] && otherNormals[otherNext] && vertNormals[_index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[_index].norm);\n            vertNormals[_index].norm = otherNormals[otherNext].norm;\n          }\n          var sharedNormal1 = vertNormals[_index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[_index] === null) {\n            vertNormals[_index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n          if (vertNormals[_next] && otherNormals[otherIndex] && vertNormals[_next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[_next].norm);\n            vertNormals[_next].norm = otherNormals[otherIndex].norm;\n          }\n          var sharedNormal2 = vertNormals[_next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[_next] === null) {\n            vertNormals[_next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n  for (var _i3 = 0, _l2 = normals.length; _i3 < _l2; _i3++) {\n    normals[_i3].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\nvar LineParser = /*#__PURE__*/function () {\n  function LineParser(line, lineNumber) {\n    _classCallCheck(this, LineParser);\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n  _createClass(LineParser, [{\n    key: \"seekNonSpace\",\n    value: function seekNonSpace() {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n        if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n          return;\n        }\n        this.currentCharIndex++;\n      }\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      var pos0 = this.currentCharIndex++;\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n        if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n          break;\n        }\n        this.currentCharIndex++;\n      }\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    }\n  }, {\n    key: \"getVector\",\n    value: function getVector() {\n      return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n    }\n  }, {\n    key: \"getRemainingString\",\n    value: function getRemainingString() {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    }\n  }, {\n    key: \"isAtTheEnd\",\n    value: function isAtTheEnd() {\n      return this.currentCharIndex >= this.lineLength;\n    }\n  }, {\n    key: \"setToEnd\",\n    value: function setToEnd() {\n      this.currentCharIndex = this.lineLength;\n    }\n  }, {\n    key: \"getLineNumberString\",\n    value: function getLineNumberString() {\n      return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n    }\n  }]);\n  return LineParser;\n}();\nvar LDrawParsedCache = /*#__PURE__*/function () {\n  function LDrawParsedCache(loader) {\n    _classCallCheck(this, LDrawParsedCache);\n    this.loader = loader;\n    this._cache = {};\n  }\n  _createClass(LDrawParsedCache, [{\n    key: \"cloneResult\",\n    value: function cloneResult(original) {\n      var result = {};\n      result.faces = original.faces.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          normals: face.normals.map(function () {\n            return null;\n          }),\n          faceNormal: null\n        };\n      });\n      result.conditionalSegments = original.conditionalSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          controlPoints: face.controlPoints.map(function (v) {\n            return v.clone();\n          })\n        };\n      });\n      result.lineSegments = original.lineSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          })\n        };\n      });\n      result.type = original.type;\n      result.category = original.category;\n      result.keywords = original.keywords;\n      result.subobjects = original.subobjects;\n      result.totalFaces = original.totalFaces;\n      result.startingConstructionStep = original.startingConstructionStep;\n      result.materials = original.materials;\n      result.group = null;\n      return result;\n    }\n  }, {\n    key: \"fetchData\",\n    value: function () {\n      var _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fileName) {\n        var triedLowerCase, locationState, subobjectURL, loader, fileLoader, text;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              triedLowerCase = false;\n              locationState = FILE_LOCATION_AS_IS;\n            case 2:\n              if (!(locationState !== FILE_LOCATION_NOT_FOUND)) {\n                _context.next = 40;\n                break;\n              }\n              subobjectURL = fileName;\n              _context.t0 = locationState;\n              _context.next = _context.t0 === FILE_LOCATION_AS_IS ? 7 : _context.t0 === FILE_LOCATION_TRY_PARTS ? 9 : _context.t0 === FILE_LOCATION_TRY_P ? 12 : _context.t0 === FILE_LOCATION_TRY_MODELS ? 15 : _context.t0 === FILE_LOCATION_TRY_RELATIVE ? 18 : _context.t0 === FILE_LOCATION_TRY_ABSOLUTE ? 21 : 23;\n              break;\n            case 7:\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 9:\n              subobjectURL = \"parts/\" + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 12:\n              subobjectURL = \"p/\" + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 15:\n              subobjectURL = \"models/\" + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 18:\n              subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 21:\n              if (triedLowerCase) {\n                locationState = FILE_LOCATION_NOT_FOUND;\n              } else {\n                fileName = fileName.toLowerCase();\n                subobjectURL = fileName;\n                triedLowerCase = true;\n                locationState = FILE_LOCATION_AS_IS;\n              }\n              return _context.abrupt(\"break\", 23);\n            case 23:\n              loader = this.loader;\n              fileLoader = new FileLoader(loader.manager);\n              fileLoader.setPath(loader.partsLibraryPath);\n              fileLoader.setRequestHeader(loader.requestHeader);\n              fileLoader.setWithCredentials(loader.withCredentials);\n              _context.prev = 28;\n              _context.next = 31;\n              return fileLoader.loadAsync(subobjectURL);\n            case 31:\n              text = _context.sent;\n              return _context.abrupt(\"return\", text);\n            case 35:\n              _context.prev = 35;\n              _context.t1 = _context[\"catch\"](28);\n              return _context.abrupt(\"continue\", 2);\n            case 38:\n              _context.next = 2;\n              break;\n            case 40:\n              throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n            case 41:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[28, 35]]);\n      }));\n      function fetchData(_x) {\n        return _fetchData.apply(this, arguments);\n      }\n      return fetchData;\n    }()\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var fileName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var loader = this.loader;\n      var faces = [];\n      var lineSegments = [];\n      var conditionalSegments = [];\n      var subobjects = [];\n      var materials = {};\n      var getLocalMaterial = function getLocalMaterial(colorCode) {\n        return materials[colorCode] || null;\n      };\n      var type = \"Model\";\n      var category = null;\n      var keywords = null;\n      var totalFaces = 0;\n      if (text.indexOf(\"\\r\\n\") !== -1) {\n        text = text.replace(/\\r\\n/g, \"\\n\");\n      }\n      var lines = text.split(\"\\n\");\n      var numLines = lines.length;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var startingConstructionStep = false;\n      for (var lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith(\"0 FILE \")) {\n            this.setData(currentEmbeddedFileName, currentEmbeddedText);\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = \"\";\n          } else {\n            currentEmbeddedText += line + \"\\n\";\n          }\n          continue;\n        }\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n        if (lp.isAtTheEnd()) {\n          continue;\n        }\n        var lineType = lp.getToken();\n        var material = void 0;\n        var colorCode = void 0;\n        var segment = void 0;\n        var ccw = void 0;\n        var doubleSided = void 0;\n        var v0 = void 0,\n          v1 = void 0,\n          v2 = void 0,\n          v3 = void 0,\n          c0 = void 0,\n          c1 = void 0;\n        switch (lineType) {\n          case \"0\":\n            var meta = lp.getToken();\n            if (meta) {\n              switch (meta) {\n                case \"!LDRAW_ORG\":\n                  type = lp.getToken();\n                  break;\n                case \"!COLOUR\":\n                  material = loader.parseColorMetaDirective(lp);\n                  if (material) {\n                    materials[material.userData.code] = material;\n                  } else {\n                    console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                  }\n                  break;\n                case \"!CATEGORY\":\n                  category = lp.getToken();\n                  break;\n                case \"!KEYWORDS\":\n                  var newKeywords = lp.getRemainingString().split(\",\");\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n                  break;\n                case \"FILE\":\n                  if (lineIndex > 0) {\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = \"\";\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n                  break;\n                case \"BFC\":\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n                    switch (token) {\n                      case \"CERTIFY\":\n                      case \"NOCERTIFY\":\n                        bfcCertified = token === \"CERTIFY\";\n                        bfcCCW = true;\n                        break;\n                      case \"CW\":\n                      case \"CCW\":\n                        bfcCCW = token === \"CCW\";\n                        break;\n                      case \"INVERTNEXT\":\n                        bfcInverted = true;\n                        break;\n                      case \"CLIP\":\n                      case \"NOCLIP\":\n                        bfcCull = token === \"CLIP\";\n                        break;\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n                  break;\n                case \"STEP\":\n                  startingConstructionStep = true;\n                  break;\n              }\n            }\n            break;\n          case \"1\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n            if (loader.fileMap[fileName2]) {\n              fileName2 = loader.fileMap[fileName2];\n            } else {\n              if (fileName2.startsWith(\"s/\")) {\n                fileName2 = \"parts/\" + fileName2;\n              } else if (fileName2.startsWith(\"48/\")) {\n                fileName2 = \"p/\" + fileName2;\n              }\n            }\n            subobjects.push({\n              material: material,\n              colorCode: colorCode,\n              matrix: matrix,\n              fileName: fileName2,\n              inverted: bfcInverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          case \"2\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1]\n            };\n            lineSegments.push(segment);\n            break;\n          case \"5\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            c0 = lp.getVector();\n            c1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1],\n              controlPoints: [c0, c1]\n            };\n            conditionalSegments.push(segment);\n            break;\n          case \"3\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n            } else {\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            }\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v2, v1, v0],\n                normals: [null, null, null]\n              });\n              totalFaces++;\n            }\n            break;\n          case \"4\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n              v3 = lp.getVector();\n            } else {\n              v3 = lp.getVector();\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            }\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2, v3],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v3, v2, v1, v0],\n                normals: [null, null, null, null]\n              });\n              totalFaces += 2;\n            }\n            break;\n          default:\n            throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n        }\n      }\n      if (parsingEmbeddedFiles) {\n        this.setData(currentEmbeddedFileName, currentEmbeddedText);\n      }\n      return {\n        faces: faces,\n        conditionalSegments: conditionalSegments,\n        lineSegments: lineSegments,\n        type: type,\n        category: category,\n        keywords: keywords,\n        subobjects: subobjects,\n        totalFaces: totalFaces,\n        startingConstructionStep: startingConstructionStep,\n        materials: materials,\n        fileName: fileName,\n        group: null\n      };\n    }\n    // returns an (optionally cloned) instance of the data\n  }, {\n    key: \"getData\",\n    value: function getData(fileName) {\n      var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var key = fileName.toLowerCase();\n      var result = this._cache[key];\n      if (result === null || result instanceof Promise) {\n        return null;\n      }\n      if (clone) {\n        return this.cloneResult(result);\n      } else {\n        return result;\n      }\n    }\n    // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n    // the data is ready to use and can be retrieved synchronously with \"getData\".\n  }, {\n    key: \"ensureDataLoaded\",\n    value: function () {\n      var _ensureDataLoaded = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fileName) {\n        var _this3 = this;\n        var key;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              key = fileName.toLowerCase();\n              if (!(key in this._cache)) {\n                this._cache[key] = this.fetchData(fileName).then(function (text) {\n                  var info = _this3.parse(text, fileName);\n                  _this3._cache[key] = info;\n                  return info;\n                });\n              }\n              _context2.next = 4;\n              return this._cache[key];\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function ensureDataLoaded(_x2) {\n        return _ensureDataLoaded.apply(this, arguments);\n      }\n      return ensureDataLoaded;\n    }() // sets the data in the cache from parsed data\n  }, {\n    key: \"setData\",\n    value: function setData(fileName, text) {\n      var key = fileName.toLowerCase();\n      this._cache[key] = this.parse(text, fileName);\n    }\n  }]);\n  return LDrawParsedCache;\n}();\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\nvar LDrawPartsGeometryCache = /*#__PURE__*/function () {\n  function LDrawPartsGeometryCache(loader) {\n    _classCallCheck(this, LDrawPartsGeometryCache);\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n  // Convert the given file information into a mesh by processing subobjects.\n  _createClass(LDrawPartsGeometryCache, [{\n    key: \"processIntoMesh\",\n    value: function () {\n      var _processIntoMesh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(info) {\n        var _this4 = this;\n        var loader, parseCache, faceMaterials, processInfoSubobjects, i, l, checkSubSegments, group;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              loader = this.loader;\n              parseCache = this.parseCache;\n              faceMaterials = /* @__PURE__ */new Set();\n              processInfoSubobjects = /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(info2) {\n                  var subobject,\n                    subobjects,\n                    promises,\n                    _loop,\n                    i,\n                    l,\n                    group2,\n                    subobjectInfos,\n                    _i4,\n                    _l3,\n                    subobject2,\n                    subobjectInfo,\n                    subobjectGroup,\n                    parentLineSegments,\n                    parentConditionalSegments,\n                    parentFaces,\n                    lineSegments,\n                    conditionalSegments,\n                    faces,\n                    matrix,\n                    inverted,\n                    matrixScaleInverted,\n                    colorCode,\n                    lineColorCode,\n                    i2,\n                    l2,\n                    ls,\n                    vertices,\n                    _i5,\n                    _l4,\n                    os,\n                    _vertices3,\n                    controlPoints,\n                    _i6,\n                    _l5,\n                    tri,\n                    _vertices4,\n                    i3,\n                    l3,\n                    _args4 = arguments;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        subobject = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : null;\n                        subobjects = info2.subobjects;\n                        promises = [];\n                        _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                          var subobject2, promise;\n                          return _regeneratorRuntime().wrap(function _loop$(_context3) {\n                            while (1) switch (_context3.prev = _context3.next) {\n                              case 0:\n                                subobject2 = subobjects[i];\n                                promise = parseCache.ensureDataLoaded(subobject2.fileName).then(function () {\n                                  var subobjectInfo = parseCache.getData(subobject2.fileName, false);\n                                  if (!isPrimitiveType(subobjectInfo.type)) {\n                                    return _this4.loadModel(subobject2.fileName).catch(function (error) {\n                                      console.warn(error);\n                                      return null;\n                                    });\n                                  }\n                                  return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n                                });\n                                promises.push(promise);\n                              case 3:\n                              case \"end\":\n                                return _context3.stop();\n                            }\n                          }, _loop);\n                        });\n                        i = 0, l = subobjects.length;\n                      case 5:\n                        if (!(i < l)) {\n                          _context4.next = 10;\n                          break;\n                        }\n                        return _context4.delegateYield(_loop(), \"t0\", 7);\n                      case 7:\n                        i++;\n                        _context4.next = 5;\n                        break;\n                      case 10:\n                        group2 = new Group();\n                        group2.userData.category = info2.category;\n                        group2.userData.keywords = info2.keywords;\n                        info2.group = group2;\n                        _context4.next = 16;\n                        return Promise.all(promises);\n                      case 16:\n                        subobjectInfos = _context4.sent;\n                        _i4 = 0, _l3 = subobjectInfos.length;\n                      case 18:\n                        if (!(_i4 < _l3)) {\n                          _context4.next = 50;\n                          break;\n                        }\n                        subobject2 = info2.subobjects[_i4];\n                        subobjectInfo = subobjectInfos[_i4];\n                        if (!(subobjectInfo === null)) {\n                          _context4.next = 23;\n                          break;\n                        }\n                        return _context4.abrupt(\"continue\", 47);\n                      case 23:\n                        if (!subobjectInfo.isGroup) {\n                          _context4.next = 31;\n                          break;\n                        }\n                        subobjectGroup = subobjectInfo;\n                        subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n                        subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n                        subobjectGroup.name = subobject2.fileName;\n                        loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n                        group2.add(subobjectGroup);\n                        return _context4.abrupt(\"continue\", 47);\n                      case 31:\n                        if (subobjectInfo.group.children.length) {\n                          group2.add(subobjectInfo.group);\n                        }\n                        parentLineSegments = info2.lineSegments;\n                        parentConditionalSegments = info2.conditionalSegments;\n                        parentFaces = info2.faces;\n                        lineSegments = subobjectInfo.lineSegments;\n                        conditionalSegments = subobjectInfo.conditionalSegments;\n                        faces = subobjectInfo.faces;\n                        matrix = subobject2.matrix;\n                        inverted = subobject2.inverted;\n                        matrixScaleInverted = matrix.determinant() < 0;\n                        colorCode = subobject2.colorCode;\n                        lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n                        for (i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n                          ls = lineSegments[i2];\n                          vertices = ls.vertices;\n                          vertices[0].applyMatrix4(matrix);\n                          vertices[1].applyMatrix4(matrix);\n                          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n                          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n                          parentLineSegments.push(ls);\n                        }\n                        for (_i5 = 0, _l4 = conditionalSegments.length; _i5 < _l4; _i5++) {\n                          os = conditionalSegments[_i5];\n                          _vertices3 = os.vertices;\n                          controlPoints = os.controlPoints;\n                          _vertices3[0].applyMatrix4(matrix);\n                          _vertices3[1].applyMatrix4(matrix);\n                          controlPoints[0].applyMatrix4(matrix);\n                          controlPoints[1].applyMatrix4(matrix);\n                          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n                          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n                          parentConditionalSegments.push(os);\n                        }\n                        for (_i6 = 0, _l5 = faces.length; _i6 < _l5; _i6++) {\n                          tri = faces[_i6];\n                          _vertices4 = tri.vertices;\n                          for (i3 = 0, l3 = _vertices4.length; i3 < l3; i3++) {\n                            _vertices4[i3].applyMatrix4(matrix);\n                          }\n                          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n                          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n                          faceMaterials.add(tri.colorCode);\n                          if (matrixScaleInverted !== inverted) {\n                            _vertices4.reverse();\n                          }\n                          parentFaces.push(tri);\n                        }\n                        info2.totalFaces += subobjectInfo.totalFaces;\n                      case 47:\n                        _i4++;\n                        _context4.next = 18;\n                        break;\n                      case 50:\n                        if (subobject) {\n                          loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n                        }\n                        return _context4.abrupt(\"return\", info2);\n                      case 52:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee3);\n                }));\n                return function processInfoSubobjects(_x4) {\n                  return _ref3.apply(this, arguments);\n                };\n              }();\n              for (i = 0, l = info.faces; i < l; i++) {\n                faceMaterials.add(info.faces[i].colorCode);\n              }\n              _context5.next = 7;\n              return processInfoSubobjects(info);\n            case 7:\n              if (loader.smoothNormals) {\n                checkSubSegments = faceMaterials.size > 1;\n                generateFaceNormals(info.faces);\n                smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n              }\n              group = info.group;\n              if (info.faces.length > 0) {\n                group.add(createObject(info.faces, 3, false, info.totalFaces));\n              }\n              if (info.lineSegments.length > 0) {\n                group.add(createObject(info.lineSegments, 2));\n              }\n              if (info.conditionalSegments.length > 0) {\n                group.add(createObject(info.conditionalSegments, 2, true));\n              }\n              return _context5.abrupt(\"return\", group);\n            case 13:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this);\n      }));\n      function processIntoMesh(_x3) {\n        return _processIntoMesh.apply(this, arguments);\n      }\n      return processIntoMesh;\n    }()\n  }, {\n    key: \"hasCachedModel\",\n    value: function hasCachedModel(fileName) {\n      return fileName !== null && fileName.toLowerCase() in this._cache;\n    }\n  }, {\n    key: \"getCachedModel\",\n    value: function () {\n      var _getCachedModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(fileName) {\n        var key, group;\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(fileName !== null && this.hasCachedModel(fileName))) {\n                _context6.next = 8;\n                break;\n              }\n              key = fileName.toLowerCase();\n              _context6.next = 4;\n              return this._cache[key];\n            case 4:\n              group = _context6.sent;\n              return _context6.abrupt(\"return\", group.clone());\n            case 8:\n              return _context6.abrupt(\"return\", null);\n            case 9:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getCachedModel(_x5) {\n        return _getCachedModel.apply(this, arguments);\n      }\n      return getCachedModel;\n    }() // Loads and parses the model with the given file name. Returns a cached copy if available.\n  }, {\n    key: \"loadModel\",\n    value: function () {\n      var _loadModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(fileName) {\n        var parseCache, key, info, promise, group;\n        return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              parseCache = this.parseCache;\n              key = fileName.toLowerCase();\n              if (!this.hasCachedModel(fileName)) {\n                _context7.next = 6;\n                break;\n              }\n              return _context7.abrupt(\"return\", this.getCachedModel(fileName));\n            case 6:\n              _context7.next = 8;\n              return parseCache.ensureDataLoaded(fileName);\n            case 8:\n              info = parseCache.getData(fileName);\n              promise = this.processIntoMesh(info);\n              if (!this.hasCachedModel(fileName)) {\n                _context7.next = 12;\n                break;\n              }\n              return _context7.abrupt(\"return\", this.getCachedModel(fileName));\n            case 12:\n              if (isPartType(info.type)) {\n                this._cache[key] = promise;\n              }\n              _context7.next = 15;\n              return promise;\n            case 15:\n              group = _context7.sent;\n              return _context7.abrupt(\"return\", group.clone());\n            case 17:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee6, this);\n      }));\n      function loadModel(_x6) {\n        return _loadModel.apply(this, arguments);\n      }\n      return loadModel;\n    }() // parses the given model text into a renderable object. Returns cached copy if available.\n  }, {\n    key: \"parseModel\",\n    value: function () {\n      var _parseModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(text) {\n        var parseCache, info;\n        return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              parseCache = this.parseCache;\n              info = parseCache.parse(text);\n              if (!(isPartType(info.type) && this.hasCachedModel(info.fileName))) {\n                _context8.next = 4;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.getCachedModel(info.fileName));\n            case 4:\n              return _context8.abrupt(\"return\", this.processIntoMesh(info));\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee7, this);\n      }));\n      function parseModel(_x7) {\n        return _parseModel.apply(this, arguments);\n      }\n      return parseModel;\n    }()\n  }]);\n  return LDrawPartsGeometryCache;\n}();\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize) {\n  var isConditionalSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var totalElements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  var positions = new Float32Array(elementSize * totalElements * 3);\n  var normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  var materials = [];\n  var quadArray = new Array(6);\n  var bufferGeometry = new BufferGeometry();\n  var prevMaterial = null;\n  var index0 = 0;\n  var numGroupVerts = 0;\n  var offset = 0;\n  for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    var elem = elements[iElem];\n    var vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (var j = 0, l = vertices.length; j < l; j++) {\n      var v = vertices[j];\n      var index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        var v0 = vertices[0];\n        var v1 = vertices[1];\n        var v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      var elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (var _j = 0, _l6 = elemNormals.length; _j < _l6; _j++) {\n        var n = elem.faceNormal;\n        if (elemNormals[_j]) {\n          n = elemNormals[_j].norm;\n        }\n        var _index2 = offset + _j * 3;\n        normals[_index2 + 0] = n.x;\n        normals[_index2 + 1] = n.y;\n        normals[_index2 + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      var material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n  var object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    var controlArray0 = new Float32Array(elements.length * 3 * 2);\n    var controlArray1 = new Float32Array(elements.length * 3 * 2);\n    var directionArray = new Float32Array(elements.length * 3 * 2);\n    for (var i = 0, _l7 = elements.length; i < _l7; i++) {\n      var os = elements[i];\n      var _vertices5 = os.vertices;\n      var controlPoints = os.controlPoints;\n      var c0 = controlPoints[0];\n      var c1 = controlPoints[1];\n      var _v5 = _vertices5[0];\n      var _v6 = _vertices5[1];\n      var _index3 = i * 3 * 2;\n      controlArray0[_index3 + 0] = c0.x;\n      controlArray0[_index3 + 1] = c0.y;\n      controlArray0[_index3 + 2] = c0.z;\n      controlArray0[_index3 + 3] = c0.x;\n      controlArray0[_index3 + 4] = c0.y;\n      controlArray0[_index3 + 5] = c0.z;\n      controlArray1[_index3 + 0] = c1.x;\n      controlArray1[_index3 + 1] = c1.y;\n      controlArray1[_index3 + 2] = c1.z;\n      controlArray1[_index3 + 3] = c1.x;\n      controlArray1[_index3 + 4] = c1.y;\n      controlArray1[_index3 + 5] = c1.z;\n      directionArray[_index3 + 0] = _v6.x - _v5.x;\n      directionArray[_index3 + 1] = _v6.y - _v5.y;\n      directionArray[_index3 + 2] = _v6.z - _v5.z;\n      directionArray[_index3 + 3] = _v6.x - _v5.x;\n      directionArray[_index3 + 4] = _v6.y - _v5.y;\n      directionArray[_index3 + 5] = _v6.z - _v5.z;\n    }\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\nvar LDrawLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LDrawLoader, _Loader);\n  var _super3 = _createSuper(LDrawLoader);\n  function LDrawLoader(manager) {\n    var _this5;\n    _classCallCheck(this, LDrawLoader);\n    _this5 = _super3.call(this, manager);\n    _this5.materials = [];\n    _this5.materialLibrary = {};\n    _this5.partsCache = new LDrawPartsGeometryCache(_assertThisInitialized(_this5));\n    _this5.fileMap = {};\n    _this5.setMaterials([]);\n    _this5.smoothNormals = true;\n    _this5.partsLibraryPath = \"\";\n    return _this5;\n  }\n  _createClass(LDrawLoader, [{\n    key: \"setPartsLibraryPath\",\n    value: function setPartsLibraryPath(path) {\n      this.partsLibraryPath = path;\n      return this;\n    }\n  }, {\n    key: \"preloadMaterials\",\n    value: function () {\n      var _preloadMaterials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(url) {\n        var fileLoader, text, colorLineRegex, lines, materials, i, l, line, directive, material;\n        return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              fileLoader = new FileLoader(this.manager);\n              fileLoader.setPath(this.path);\n              fileLoader.setRequestHeader(this.requestHeader);\n              fileLoader.setWithCredentials(this.withCredentials);\n              _context9.next = 6;\n              return fileLoader.loadAsync(url);\n            case 6:\n              text = _context9.sent;\n              colorLineRegex = /^0 !COLOUR/;\n              lines = text.split(/[\\n\\r]/g);\n              materials = [];\n              for (i = 0, l = lines.length; i < l; i++) {\n                line = lines[i];\n                if (colorLineRegex.test(line)) {\n                  directive = line.replace(colorLineRegex, \"\");\n                  material = this.parseColorMetaDirective(new LineParser(directive));\n                  materials.push(material);\n                }\n              }\n              this.setMaterials(materials);\n            case 12:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee8, this);\n      }));\n      function preloadMaterials(_x8) {\n        return _preloadMaterials.apply(this, arguments);\n      }\n      return preloadMaterials;\n    }()\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this6 = this;\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        _this6.partsCache.parseModel(text, _this6.materialLibrary).then(function (group) {\n          _this6.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, _this6.materialLibrary, true);\n          _this6.computeConstructionSteps(group);\n          onLoad(group);\n        }).catch(onError);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, onLoad) {\n      var _this7 = this;\n      this.partsCache.parseModel(text, this.materialLibrary).then(function (group) {\n        _this7.computeConstructionSteps(group);\n        onLoad(group);\n      });\n    }\n  }, {\n    key: \"setMaterials\",\n    value: function setMaterials(materials) {\n      this.materialLibrary = {};\n      this.materials = [];\n      for (var i = 0, l = materials.length; i < l; i++) {\n        this.addMaterial(materials[i]);\n      }\n      this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n      this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n      return this;\n    }\n  }, {\n    key: \"setFileMap\",\n    value: function setFileMap(fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    }\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(material) {\n      var matLib = this.materialLibrary;\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n        matLib[material.userData.code] = material;\n      }\n      return this;\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(colorCode) {\n      if (colorCode.startsWith(\"0x2\")) {\n        var color = colorCode.substring(3);\n        return this.parseColorMetaDirective(new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color));\n      }\n      return this.materialLibrary[colorCode] || null;\n    }\n    // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n    // in the material array if they need to be filled in.\n  }, {\n    key: \"applyMaterialsToMesh\",\n    value: function applyMaterialsToMesh(group, parentColorCode, materialHierarchy) {\n      var finalMaterialPass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var loader = this;\n      var parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n      group.traverse(function (c) {\n        if (c.isMesh || c.isLineSegments) {\n          if (Array.isArray(c.material)) {\n            for (var i = 0, l = c.material.length; i < l; i++) {\n              if (!c.material[i].isMaterial) {\n                c.material[i] = getMaterial(c, c.material[i]);\n              }\n            }\n          } else if (!c.material.isMaterial) {\n            c.material = getMaterial(c, c.material);\n          }\n        }\n      });\n      function getMaterial(c, colorCode) {\n        if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n          return colorCode;\n        }\n        var forEdge = c.isLineSegments || c.isConditionalLine;\n        var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n        if (isPassthrough) {\n          colorCode = parentColorCode;\n        }\n        var material = null;\n        if (colorCode in materialHierarchy) {\n          material = materialHierarchy[colorCode];\n        } else if (finalMaterialPass) {\n          material = loader.getMaterial(colorCode);\n          if (material === null) {\n            throw new Error(\"LDrawLoader: Material properties for code \".concat(colorCode, \" not available.\"));\n          }\n        } else {\n          return colorCode;\n        }\n        if (c.isLineSegments) {\n          material = material.userData.edgeMaterial;\n          if (c.isConditionalLine) {\n            material = material.userData.conditionalEdgeMaterial;\n          }\n        }\n        return material;\n      }\n    }\n  }, {\n    key: \"getMainMaterial\",\n    value: function getMainMaterial() {\n      return this.getMaterial(MAIN_COLOUR_CODE);\n    }\n  }, {\n    key: \"getMainEdgeMaterial\",\n    value: function getMainEdgeMaterial() {\n      return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n    }\n  }, {\n    key: \"parseColorMetaDirective\",\n    value: function parseColorMetaDirective(lineParser) {\n      var code = null;\n      var color = 16711935;\n      var edgeColor = 16711935;\n      var alpha = 1;\n      var isTransparent = false;\n      var luminance = 0;\n      var finishType = FINISH_TYPE_DEFAULT;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n      if (!name) {\n        throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\");\n      }\n      var token = null;\n      while (true) {\n        token = lineParser.getToken();\n        if (!token) {\n          break;\n        }\n        switch (token.toUpperCase()) {\n          case \"CODE\":\n            code = lineParser.getToken();\n            break;\n          case \"VALUE\":\n            color = lineParser.getToken();\n            if (color.startsWith(\"0x\")) {\n              color = \"#\" + color.substring(2);\n            } else if (!color.startsWith(\"#\")) {\n              throw new Error(\"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\");\n            }\n            break;\n          case \"EDGE\":\n            edgeColor = lineParser.getToken();\n            if (edgeColor.startsWith(\"0x\")) {\n              edgeColor = \"#\" + edgeColor.substring(2);\n            } else if (!edgeColor.startsWith(\"#\")) {\n              edgeMaterial = this.getMaterial(edgeColor);\n              if (!edgeMaterial) {\n                throw new Error(\"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\");\n              }\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n            break;\n          case \"ALPHA\":\n            alpha = parseInt(lineParser.getToken());\n            if (isNaN(alpha)) {\n              throw new Error(\"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\");\n            }\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n            break;\n          case \"LUMINANCE\":\n            luminance = parseInt(lineParser.getToken());\n            if (isNaN(luminance)) {\n              throw new Error(\"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\");\n            }\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n          case \"CHROME\":\n            finishType = FINISH_TYPE_CHROME;\n            break;\n          case \"PEARLESCENT\":\n            finishType = FINISH_TYPE_PEARLESCENT;\n            break;\n          case \"RUBBER\":\n            finishType = FINISH_TYPE_RUBBER;\n            break;\n          case \"MATTE_METALLIC\":\n            finishType = FINISH_TYPE_MATTE_METALLIC;\n            break;\n          case \"METAL\":\n            finishType = FINISH_TYPE_METAL;\n            break;\n          case \"MATERIAL\":\n            lineParser.setToEnd();\n            break;\n          default:\n            throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\");\n        }\n      }\n      var material = null;\n      switch (finishType) {\n        case FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0\n          });\n          break;\n        case FINISH_TYPE_PEARLESCENT:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0.25\n          });\n          break;\n        case FINISH_TYPE_CHROME:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n        case FINISH_TYPE_RUBBER:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.9,\n            metalness: 0\n          });\n          break;\n        case FINISH_TYPE_MATTE_METALLIC:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n        case FINISH_TYPE_METAL:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n      }\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n      if (!edgeMaterial) {\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColor,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + \" - Edge\";\n        edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent,\n          color: edgeColor,\n          opacity: alpha\n        });\n      }\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      this.addMaterial(material);\n      return material;\n    }\n  }, {\n    key: \"computeConstructionSteps\",\n    value: function computeConstructionSteps(model) {\n      var stepNumber = 0;\n      model.traverse(function (c) {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    }\n  }]);\n  return LDrawLoader;\n}(Loader);\nexport { LDrawLoader };\n//# sourceMappingURL=LDrawLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}