{"ast":null,"code":"import _toConsumableArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\nvar BIN_COUNT = 32;\nvar binsSort = function binsSort(a, b) {\n  return a.candidate - b.candidate;\n};\nvar sahBins = new Array(BIN_COUNT).fill().map(function () {\n  return {\n    count: 0,\n    bounds: new Float32Array(6),\n    rightCacheBounds: new Float32Array(6),\n    leftCacheBounds: new Float32Array(6),\n    candidate: 0\n  };\n});\nvar leftBounds = new Float32Array(6);\nexport function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n  var axis = -1;\n  var pos = 0;\n\n  // Center\n  if (strategy === CENTER) {\n    axis = getLongestEdgeIndex(centroidBoundingData);\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === AVERAGE) {\n    axis = getLongestEdgeIndex(nodeBoundingData);\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === SAH) {\n    var rootSurfaceArea = computeSurfaceArea(nodeBoundingData);\n    var bestCost = TRIANGLE_INTERSECT_COST * count;\n\n    // iterate over all axes\n    var cStart = offset * 6;\n    var cEnd = (offset + count) * 6;\n    for (var a = 0; a < 3; a++) {\n      var axisLeft = centroidBoundingData[a];\n      var axisRight = centroidBoundingData[a + 3];\n      var axisLength = axisRight - axisLeft;\n      var binWidth = axisLength / BIN_COUNT;\n\n      // If we have fewer triangles than we're planning to split then just check all\n      // the triangle positions because it will be faster.\n      if (count < BIN_COUNT / 4) {\n        // initialize the bin candidates\n        var truncatedBins = _toConsumableArray(sahBins);\n        truncatedBins.length = count;\n\n        // set the candidates\n        var b = 0;\n        for (var c = cStart; c < cEnd; c += 6, b++) {\n          var bin = truncatedBins[b];\n          bin.candidate = triangleBounds[c + 2 * a];\n          bin.count = 0;\n          var bounds = bin.bounds,\n            leftCacheBounds = bin.leftCacheBounds,\n            rightCacheBounds = bin.rightCacheBounds;\n          for (var d = 0; d < 3; d++) {\n            rightCacheBounds[d] = Infinity;\n            rightCacheBounds[d + 3] = -Infinity;\n            leftCacheBounds[d] = Infinity;\n            leftCacheBounds[d + 3] = -Infinity;\n            bounds[d] = Infinity;\n            bounds[d + 3] = -Infinity;\n          }\n          expandByTriangleBounds(c, triangleBounds, bounds);\n        }\n        truncatedBins.sort(binsSort);\n\n        // remove redundant splits\n        var splitCount = count;\n        for (var bi = 0; bi < splitCount; bi++) {\n          var _bin = truncatedBins[bi];\n          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === _bin.candidate) {\n            truncatedBins.splice(bi + 1, 1);\n            splitCount--;\n          }\n        }\n\n        // find the appropriate bin for each triangle and expand the bounds.\n        for (var _c = cStart; _c < cEnd; _c += 6) {\n          var center = triangleBounds[_c + 2 * a];\n          for (var _bi = 0; _bi < splitCount; _bi++) {\n            var _bin2 = truncatedBins[_bi];\n            if (center >= _bin2.candidate) {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.rightCacheBounds);\n            } else {\n              expandByTriangleBounds(_c, triangleBounds, _bin2.leftCacheBounds);\n              _bin2.count++;\n            }\n          }\n        }\n\n        // expand all the bounds\n        for (var _bi2 = 0; _bi2 < splitCount; _bi2++) {\n          var _bin3 = truncatedBins[_bi2];\n          var leftCount = _bin3.count;\n          var rightCount = count - _bin3.count;\n\n          // check the cost of this split\n          var _leftBounds = _bin3.leftCacheBounds;\n          var rightBounds = _bin3.rightCacheBounds;\n          var leftProb = 0;\n          if (leftCount !== 0) {\n            leftProb = computeSurfaceArea(_leftBounds) / rootSurfaceArea;\n          }\n          var rightProb = 0;\n          if (rightCount !== 0) {\n            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n          }\n          var cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n          if (cost < bestCost) {\n            axis = a;\n            bestCost = cost;\n            pos = _bin3.candidate;\n          }\n        }\n      } else {\n        // reset the bins\n        for (var i = 0; i < BIN_COUNT; i++) {\n          var _bin4 = sahBins[i];\n          _bin4.count = 0;\n          _bin4.candidate = axisLeft + binWidth + i * binWidth;\n          var _bounds = _bin4.bounds;\n          for (var _d = 0; _d < 3; _d++) {\n            _bounds[_d] = Infinity;\n            _bounds[_d + 3] = -Infinity;\n          }\n        }\n\n        // iterate over all center positions\n        for (var _c2 = cStart; _c2 < cEnd; _c2 += 6) {\n          var triCenter = triangleBounds[_c2 + 2 * a];\n          var relativeCenter = triCenter - axisLeft;\n\n          // in the partition function if the centroid lies on the split plane then it is\n          // considered to be on the right side of the split\n          var binIndex = ~~(relativeCenter / binWidth);\n          if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n          var _bin5 = sahBins[binIndex];\n          _bin5.count++;\n          expandByTriangleBounds(_c2, triangleBounds, _bin5.bounds);\n        }\n\n        // cache the unioned bounds from right to left so we don't have to regenerate them each time\n        var lastBin = sahBins[BIN_COUNT - 1];\n        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);\n        for (var _i = BIN_COUNT - 2; _i >= 0; _i--) {\n          var _bin6 = sahBins[_i];\n          var nextBin = sahBins[_i + 1];\n          unionBounds(_bin6.bounds, nextBin.rightCacheBounds, _bin6.rightCacheBounds);\n        }\n        var _leftCount = 0;\n        for (var _i2 = 0; _i2 < BIN_COUNT - 1; _i2++) {\n          var _bin7 = sahBins[_i2];\n          var binCount = _bin7.count;\n          var _bounds2 = _bin7.bounds;\n          var _nextBin = sahBins[_i2 + 1];\n          var _rightBounds = _nextBin.rightCacheBounds;\n\n          // don't do anything with the bounds if the new bounds have no triangles\n          if (binCount !== 0) {\n            if (_leftCount === 0) {\n              copyBounds(_bounds2, leftBounds);\n            } else {\n              unionBounds(_bounds2, leftBounds, leftBounds);\n            }\n          }\n          _leftCount += binCount;\n\n          // check the cost of this split\n          var _leftProb = 0;\n          var _rightProb = 0;\n          if (_leftCount !== 0) {\n            _leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;\n          }\n          var _rightCount = count - _leftCount;\n          if (_rightCount !== 0) {\n            _rightProb = computeSurfaceArea(_rightBounds) / rootSurfaceArea;\n          }\n          var _cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (_leftProb * _leftCount + _rightProb * _rightCount);\n          if (_cost < bestCost) {\n            axis = a;\n            bestCost = _cost;\n            pos = _bin7.candidate;\n          }\n        }\n      }\n    }\n  } else {\n    console.warn(\"MeshBVH: Invalid build strategy value \".concat(strategy, \" used.\"));\n  }\n  return {\n    axis: axis,\n    pos: pos\n  };\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage(triangleBounds, offset, count, axis) {\n  var avg = 0;\n  for (var i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n  return avg / count;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}