{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, Vector4, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from \"three\";\nimport { LineSegmentsGeometry } from \"./LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"./LineMaterial.js\";\nvar _start = new Vector3();\nvar _end = new Vector3();\nvar _start4 = new Vector4();\nvar _end4 = new Vector4();\nvar _ssOrigin = new Vector4();\nvar _ssOrigin3 = new Vector3();\nvar _mvMatrix = new Matrix4();\nvar _line = new Line3();\nvar _closestPoint = new Vector3();\nvar _box = new Box3();\nvar _sphere = new Sphere();\nvar _clipToWorldVector = new Vector4();\nvar _ray, _instanceStart, _instanceEnd, _lineWidth;\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (var i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i);\n    _line.end.fromBufferAttribute(_instanceEnd, i);\n    var pointOnLine = new Vector3();\n    var point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    var isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  var projectionMatrix = camera.projectionMatrix;\n  var material = lineSegments.material;\n  var resolution = material.resolution;\n  var matrixWorld = lineSegments.matrixWorld;\n  var geometry = lineSegments.geometry;\n  var instanceStart = geometry.attributes.instanceStart;\n  var instanceEnd = geometry.attributes.instanceEnd;\n  var near = -camera.near;\n  _ray.at(1, _ssOrigin);\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (var i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n    var isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n    if (_start4.z > near) {\n      var deltaDist = _start4.z - _end4.z;\n      var t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      var _deltaDist = _end4.z - _start4.z;\n      var _t = (_end4.z - near) / _deltaDist;\n      _end4.lerp(_start4, _t);\n    }\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n    var param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n    var zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    var isInClipSpace = zPos >= -1 && zPos <= 1;\n    var isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      var pointOnLine = new Vector3();\n      var point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\nvar LineSegments2 = /*#__PURE__*/function (_Mesh) {\n  _inherits(LineSegments2, _Mesh);\n  var _super = _createSuper(LineSegments2);\n  function LineSegments2() {\n    var _this;\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new LineSegmentsGeometry();\n    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineMaterial({\n      color: Math.random() * 16777215\n    });\n    _classCallCheck(this, LineSegments2);\n    _this = _super.call(this, geometry, material);\n    _this.isLineSegments2 = true;\n    _this.type = \"LineSegments2\";\n    return _this;\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  _createClass(LineSegments2, [{\n    key: \"computeLineDistances\",\n    value: function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.count);\n      for (var i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n        _start.fromBufferAttribute(instanceStart, i);\n        _end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n      }\n      var instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);\n      geometry.setAttribute(\"instanceDistanceStart\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n      geometry.setAttribute(\"instanceDistanceEnd\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n      return this;\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {\n      var worldUnits = this.material.worldUnits;\n      var camera = raycaster.camera;\n      if (camera === null && !worldUnits) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n      }\n      var threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;\n      _ray = raycaster.ray;\n      var matrixWorld = this.matrixWorld;\n      var geometry = this.geometry;\n      var material = this.material;\n      _lineWidth = material.linewidth + threshold;\n      _instanceStart = geometry.attributes.instanceStart;\n      _instanceEnd = geometry.attributes.instanceEnd;\n      if (geometry.boundingSphere === null) {\n        geometry.computeBoundingSphere();\n      }\n      _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n      var sphereMargin;\n      if (worldUnits) {\n        sphereMargin = _lineWidth * 0.5;\n      } else {\n        var distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n        sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n      }\n      _sphere.radius += sphereMargin;\n      if (_ray.intersectsSphere(_sphere) === false) {\n        return;\n      }\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n      _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n      var boxMargin;\n      if (worldUnits) {\n        boxMargin = _lineWidth * 0.5;\n      } else {\n        var distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n        boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n      }\n      _box.expandByScalar(boxMargin);\n      if (_ray.intersectsBox(_box) === false) {\n        return;\n      }\n      if (worldUnits) {\n        raycastWorldUnits(this, intersects);\n      } else {\n        raycastScreenSpace(this, camera, intersects);\n      }\n    }\n  }]);\n  return LineSegments2;\n}(Mesh);\nexport { LineSegments2 };\n//# sourceMappingURL=LineSegments2.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}