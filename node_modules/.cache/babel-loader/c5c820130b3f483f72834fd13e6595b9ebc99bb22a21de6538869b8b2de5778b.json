{"ast":null,"code":"import _get from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Quaternion, Vector3, Matrix4, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Mesh, Line, BufferGeometry, BufferAttribute } from \"three\";\nvar _q = new Quaternion();\nvar _targetPos = new Vector3();\nvar _targetVec = new Vector3();\nvar _effectorPos = new Vector3();\nvar _effectorVec = new Vector3();\nvar _linkPos = new Vector3();\nvar _invLinkQ = new Quaternion();\nvar _linkScale = new Vector3();\nvar _axis = new Vector3();\nvar _vector = new Vector3();\nvar _matrix = new Matrix4();\nvar CCDIKSolver = /*#__PURE__*/function () {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  function CCDIKSolver(mesh) {\n    var iks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _classCallCheck(this, CCDIKSolver);\n    this.mesh = mesh;\n    this.iks = iks;\n    this._valid();\n  }\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n  _createClass(CCDIKSolver, [{\n    key: \"update\",\n    value: function update() {\n      var iks = this.iks;\n      for (var i = 0, il = iks.length; i < il; i++) {\n        this.updateOne(iks[i]);\n      }\n      return this;\n    }\n    /**\n     * Update one IK bone\n     *\n     * @param {Object} ik parameter\n     * @return {CCDIKSolver}\n     */\n  }, {\n    key: \"updateOne\",\n    value: function updateOne(ik) {\n      var bones = this.mesh.skeleton.bones;\n      var math = Math;\n      var effector = bones[ik.effector];\n      var target = bones[ik.target];\n      _targetPos.setFromMatrixPosition(target.matrixWorld);\n      var links = ik.links;\n      var iteration = ik.iteration !== void 0 ? ik.iteration : 1;\n      for (var i = 0; i < iteration; i++) {\n        var rotated = false;\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          var link = bones[links[j].index];\n          if (links[j].enabled === false) break;\n          var limitation = links[j].limitation;\n          var rotationMin = links[j].rotationMin;\n          var rotationMax = links[j].rotationMax;\n          link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale);\n          _invLinkQ.invert();\n          _effectorPos.setFromMatrixPosition(effector.matrixWorld);\n          _effectorVec.subVectors(_effectorPos, _linkPos);\n          _effectorVec.applyQuaternion(_invLinkQ);\n          _effectorVec.normalize();\n          _targetVec.subVectors(_targetPos, _linkPos);\n          _targetVec.applyQuaternion(_invLinkQ);\n          _targetVec.normalize();\n          var angle = _targetVec.dot(_effectorVec);\n          if (angle > 1) {\n            angle = 1;\n          } else if (angle < -1) {\n            angle = -1;\n          }\n          angle = math.acos(angle);\n          if (angle < 1e-5) continue;\n          if (ik.minAngle !== void 0 && angle < ik.minAngle) {\n            angle = ik.minAngle;\n          }\n          if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {\n            angle = ik.maxAngle;\n          }\n          _axis.crossVectors(_effectorVec, _targetVec);\n          _axis.normalize();\n          _q.setFromAxisAngle(_axis, angle);\n          link.quaternion.multiply(_q);\n          if (limitation !== void 0) {\n            var c = link.quaternion.w;\n            if (c > 1) c = 1;\n            var c2 = math.sqrt(1 - c * c);\n            link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n          }\n          if (rotationMin !== void 0) {\n            link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin));\n          }\n          if (rotationMax !== void 0) {\n            link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax));\n          }\n          link.updateMatrixWorld(true);\n          rotated = true;\n        }\n        if (!rotated) break;\n      }\n      return this;\n    }\n    /**\n     * Creates Helper\n     *\n     * @return {CCDIKHelper}\n     */\n  }, {\n    key: \"createHelper\",\n    value: function createHelper() {\n      return new CCDIKHelper(this.mesh, this.iks);\n    }\n    // private methods\n  }, {\n    key: \"_valid\",\n    value: function _valid() {\n      var iks = this.iks;\n      var bones = this.mesh.skeleton.bones;\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        var effector = bones[ik.effector];\n        var links = ik.links;\n        var link0 = void 0,\n          link1 = void 0;\n        link0 = effector;\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          link1 = bones[links[j].index];\n          if (link0.parent !== link1) {\n            console.warn(\"THREE.CCDIKSolver: bone \" + link0.name + \" is not the child of bone \" + link1.name);\n          }\n          link0 = link1;\n        }\n      }\n    }\n  }]);\n  return CCDIKSolver;\n}();\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n}\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  var v = getPosition(bone, matrixWorldInv);\n  array[index * 3 + 0] = v.x;\n  array[index * 3 + 1] = v.y;\n  array[index * 3 + 2] = v.z;\n}\nvar CCDIKHelper = /*#__PURE__*/function (_Object3D) {\n  _inherits(CCDIKHelper, _Object3D);\n  var _super = _createSuper(CCDIKHelper);\n  function CCDIKHelper(mesh) {\n    var _this;\n    var iks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var sphereSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.25;\n    _classCallCheck(this, CCDIKHelper);\n    _this = _super.call(this);\n    _this.root = mesh;\n    _this.iks = iks;\n    _this.matrix.copy(mesh.matrixWorld);\n    _this.matrixAutoUpdate = false;\n    _this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    _this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(16746632),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8978312),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8947967),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.lineMaterial = new LineBasicMaterial({\n      color: new Color(16711680),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this._init();\n    return _this;\n  }\n  /**\n   * Updates IK bones visualization.\n   */\n  _createClass(CCDIKHelper, [{\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      var mesh = this.root;\n      if (this.visible) {\n        var offset = 0;\n        var iks = this.iks;\n        var bones = mesh.skeleton.bones;\n        _matrix.copy(mesh.matrixWorld).invert();\n        for (var i = 0, il = iks.length; i < il; i++) {\n          var ik = iks[i];\n          var targetBone = bones[ik.target];\n          var effectorBone = bones[ik.effector];\n          var targetMesh = this.children[offset++];\n          var effectorMesh = this.children[offset++];\n          targetMesh.position.copy(getPosition(targetBone, _matrix));\n          effectorMesh.position.copy(getPosition(effectorBone, _matrix));\n          for (var j = 0, jl = ik.links.length; j < jl; j++) {\n            var link = ik.links[j];\n            var linkBone = bones[link.index];\n            var linkMesh = this.children[offset++];\n            linkMesh.position.copy(getPosition(linkBone, _matrix));\n          }\n          var line = this.children[offset++];\n          var array = line.geometry.attributes.position.array;\n          setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix);\n          setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix);\n          for (var _j = 0, _jl = ik.links.length; _j < _jl; _j++) {\n            var _link = ik.links[_j];\n            var _linkBone = bones[_link.index];\n            setPositionOfBoneToAttributeArray(array, _j + 2, _linkBone, _matrix);\n          }\n          line.geometry.attributes.position.needsUpdate = true;\n        }\n      }\n      this.matrix.copy(mesh.matrixWorld);\n      _get(_getPrototypeOf(CCDIKHelper.prototype), \"updateMatrixWorld\", this).call(this, force);\n    }\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.sphereGeometry.dispose();\n      this.targetSphereMaterial.dispose();\n      this.effectorSphereMaterial.dispose();\n      this.linkSphereMaterial.dispose();\n      this.lineMaterial.dispose();\n      var children = this.children;\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.isLine) child.geometry.dispose();\n      }\n    }\n    // private method\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var scope = this;\n      var iks = this.iks;\n      function createLineGeometry(ik) {\n        var geometry = new BufferGeometry();\n        var vertices = new Float32Array((2 + ik.links.length) * 3);\n        geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n        return geometry;\n      }\n      function createTargetMesh() {\n        return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n      }\n      function createEffectorMesh() {\n        return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n      }\n      function createLinkMesh() {\n        return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n      }\n      function createLine(ik) {\n        return new Line(createLineGeometry(ik), scope.lineMaterial);\n      }\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        this.add(createTargetMesh());\n        this.add(createEffectorMesh());\n        for (var j = 0, jl = ik.links.length; j < jl; j++) {\n          this.add(createLinkMesh());\n        }\n        this.add(createLine(ik));\n      }\n    }\n  }]);\n  return CCDIKHelper;\n}(Object3D);\nexport { CCDIKHelper, CCDIKSolver };\n//# sourceMappingURL=CCDIKSolver.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}