{"ast":null,"code":"import _toConsumableArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\nvar _positionVector = /*@__PURE__*/new Vector3();\nvar _normalVector = /*@__PURE__*/new Vector3();\nvar _tangentVector = /*@__PURE__*/new Vector3();\nvar _tangentVector4 = /*@__PURE__*/new Vector4();\nvar _morphVector = /*@__PURE__*/new Vector3();\nvar _temp = /*@__PURE__*/new Vector3();\nvar _skinIndex = /*@__PURE__*/new Vector4();\nvar _skinWeight = /*@__PURE__*/new Vector4();\nvar _matrix = /*@__PURE__*/new Matrix4();\nvar _boneMatrix = /*@__PURE__*/new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes(attr1, attr2) {\n  if (!attr1 && !attr2) {\n    return;\n  }\n  var sameCount = attr1.count === attr2.count;\n  var sameNormalized = attr1.normalized === attr2.normalized;\n  var sameType = attr1.array.constructor === attr2.array.constructor;\n  var sameItemSize = attr1.itemSize === attr2.itemSize;\n  if (!sameCount || !sameNormalized || !sameType || !sameItemSize) {\n    throw new Error();\n  }\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone(attr) {\n  var countOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var cons = attr.array.constructor;\n  var normalized = attr.normalized;\n  var itemSize = attr.itemSize;\n  var count = countOverride === null ? attr.count : countOverride;\n  return new BufferAttribute(new cons(itemSize * count), itemSize, normalized);\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents(attr, target) {\n  var targetOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (attr.isInterleavedBufferAttribute) {\n    var itemSize = attr.itemSize;\n    for (var i = 0, l = attr.count; i < l; i++) {\n      var io = i + targetOffset;\n      target.setX(io, attr.getX(i));\n      if (itemSize >= 2) target.setY(io, attr.getY(i));\n      if (itemSize >= 3) target.setZ(io, attr.getZ(i));\n      if (itemSize >= 4) target.setW(io, attr.getW(i));\n    }\n  } else {\n    var array = target.array;\n    var cons = array.constructor;\n    var byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n    var temp = new cons(array.buffer, byteOffset, attr.array.length);\n    temp.set(attr.array);\n  }\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix(target, matrix, scale) {\n  var targetArray = target.elements;\n  var matrixArray = matrix.elements;\n  for (var i = 0, l = matrixArray.length; i < l; i++) {\n    targetArray[i] += matrixArray[i] * scale;\n  }\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform(mesh, index, target) {\n  var skeleton = mesh.skeleton;\n  var geometry = mesh.geometry;\n  var bones = skeleton.bones;\n  var boneInverses = skeleton.boneInverses;\n  _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n  _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n  _matrix.elements.fill(0);\n  for (var i = 0; i < 4; i++) {\n    var weight = _skinWeight.getComponent(i);\n    if (weight !== 0) {\n      var boneIndex = _skinIndex.getComponent(i);\n      _boneMatrix.multiplyMatrices(bones[boneIndex].matrixWorld, boneInverses[boneIndex]);\n      addScaledMatrix(_matrix, _boneMatrix, weight);\n    }\n  }\n  _matrix.multiply(mesh.bindMatrix).premultiply(mesh.bindMatrixInverse);\n  target.transformDirection(_matrix);\n  return target;\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget(morphData, morphInfluences, morphTargetsRelative, i, target) {\n  _morphVector.set(0, 0, 0);\n  for (var j = 0, jl = morphData.length; j < jl; j++) {\n    var influence = morphInfluences[j];\n    var morphAttribute = morphData[j];\n    if (influence === 0) continue;\n    _temp.fromBufferAttribute(morphAttribute, i);\n    if (morphTargetsRelative) {\n      _morphVector.addScaledVector(_temp, influence);\n    } else {\n      _morphVector.addScaledVector(_temp.sub(target), influence);\n    }\n  }\n  target.add(_morphVector);\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries(geometries) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    useGroups: false,\n    updateIndex: false,\n    skipAttributes: []\n  };\n  var targetGeometry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BufferGeometry();\n  var isIndexed = geometries[0].index !== null;\n  var _options$useGroups = options.useGroups,\n    useGroups = _options$useGroups === void 0 ? false : _options$useGroups,\n    _options$updateIndex = options.updateIndex,\n    updateIndex = _options$updateIndex === void 0 ? false : _options$updateIndex,\n    _options$skipAttribut = options.skipAttributes,\n    skipAttributes = _options$skipAttribut === void 0 ? [] : _options$skipAttribut;\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  var attributes = {};\n  var offset = 0;\n  targetGeometry.clearGroups();\n  for (var i = 0; i < geometries.length; ++i) {\n    var geometry = geometries[i];\n    var attributesCount = 0;\n\n    // ensure that all geometries are indexed, or none\n    if (isIndexed !== (geometry.index !== null)) {\n      throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n    }\n\n    // gather attributes, exit early if they're different\n    for (var name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n      }\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    }\n\n    // ensure geometries have the same number of attributes\n    if (attributesCount !== attributesUsed.size) {\n      throw new Error('StaticGeometryGenerator: Make sure all geometries have the same number of attributes.');\n    }\n    if (useGroups) {\n      var count = void 0;\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        throw new Error('StaticGeometryGenerator: The geometry must have either an index or a position attribute');\n      }\n      targetGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }\n\n  // merge indices\n  if (isIndexed) {\n    var forceUpdateIndex = false;\n    if (!targetGeometry.index) {\n      var indexCount = 0;\n      for (var _i = 0; _i < geometries.length; ++_i) {\n        indexCount += geometries[_i].index.count;\n      }\n      targetGeometry.setIndex(new BufferAttribute(new Uint32Array(indexCount), 1, false));\n      forceUpdateIndex = true;\n    }\n    if (updateIndex || forceUpdateIndex) {\n      var targetIndex = targetGeometry.index;\n      var targetOffset = 0;\n      var indexOffset = 0;\n      for (var _i2 = 0; _i2 < geometries.length; ++_i2) {\n        var _geometry = geometries[_i2];\n        var index = _geometry.index;\n        if (skipAttributes[_i2] !== true) {\n          for (var j = 0; j < index.count; ++j) {\n            targetIndex.setX(targetOffset, index.getX(j) + indexOffset);\n            targetOffset++;\n          }\n        }\n        indexOffset += _geometry.attributes.position.count;\n      }\n    }\n  }\n\n  // merge attributes\n  for (var _name in attributes) {\n    var attrList = attributes[_name];\n    if (!(_name in targetGeometry.attributes)) {\n      var _count = 0;\n      for (var key in attrList) {\n        _count += attrList[key].count;\n      }\n      targetGeometry.setAttribute(_name, createAttributeClone(attributes[_name][0], _count));\n    }\n    var targetAttribute = targetGeometry.attributes[_name];\n    var _offset = 0;\n    for (var _i3 = 0, l = attrList.length; _i3 < l; _i3++) {\n      var attr = attrList[_i3];\n      if (skipAttributes[_i3] !== true) {\n        copyAttributeContents(attr, targetAttribute, _offset);\n      }\n      _offset += attr.count;\n    }\n  }\n  return targetGeometry;\n}\nfunction checkTypedArrayEquality(a, b) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (var i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks whether the geometry changed between this and last evaluation\nvar GeometryDiff = /*#__PURE__*/function () {\n  function GeometryDiff(mesh) {\n    _classCallCheck(this, GeometryDiff);\n    this.matrixWorld = new Matrix4();\n    this.geometryHash = null;\n    this.boneMatrices = null;\n    this.primitiveCount = -1;\n    this.mesh = mesh;\n    this.update();\n  }\n  _createClass(GeometryDiff, [{\n    key: \"update\",\n    value: function update() {\n      var mesh = this.mesh;\n      var geometry = mesh.geometry;\n      var skeleton = mesh.skeleton;\n      var primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n      this.matrixWorld.copy(mesh.matrixWorld);\n      this.geometryHash = geometry.attributes.position.version;\n      this.primitiveCount = primitiveCount;\n      if (skeleton) {\n        // ensure the bone matrix array is updated to the appropriate length\n        if (!skeleton.boneTexture) {\n          skeleton.computeBoneTexture();\n        }\n        skeleton.update();\n\n        // copy data if possible otherwise clone it\n        var boneMatrices = skeleton.boneMatrices;\n        if (!this.boneMatrices || this.boneMatrices.length !== boneMatrices.length) {\n          this.boneMatrices = boneMatrices.slice();\n        } else {\n          this.boneMatrices.set(boneMatrices);\n        }\n      } else {\n        this.boneMatrices = null;\n      }\n    }\n  }, {\n    key: \"didChange\",\n    value: function didChange() {\n      var mesh = this.mesh;\n      var geometry = mesh.geometry;\n      var primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n      var identical = this.matrixWorld.equals(mesh.matrixWorld) && this.geometryHash === geometry.attributes.position.version && checkTypedArrayEquality(mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices) && this.primitiveCount === primitiveCount;\n      return !identical;\n    }\n  }]);\n  return GeometryDiff;\n}();\nexport var StaticGeometryGenerator = /*#__PURE__*/function () {\n  function StaticGeometryGenerator(meshes) {\n    _classCallCheck(this, StaticGeometryGenerator);\n    if (!Array.isArray(meshes)) {\n      meshes = [meshes];\n    }\n    var finalMeshes = [];\n    meshes.forEach(function (object) {\n      object.traverseVisible(function (c) {\n        if (c.isMesh) {\n          finalMeshes.push(c);\n        }\n      });\n    });\n    this.meshes = finalMeshes;\n    this.useGroups = true;\n    this.applyWorldTransforms = true;\n    this.attributes = ['position', 'normal', 'color', 'tangent', 'uv', 'uv2'];\n    this._intermediateGeometry = new Array(finalMeshes.length).fill().map(function () {\n      return new BufferGeometry();\n    });\n    this._diffMap = new WeakMap();\n  }\n  _createClass(StaticGeometryGenerator, [{\n    key: \"getMaterials\",\n    value: function getMaterials() {\n      var materials = [];\n      this.meshes.forEach(function (mesh) {\n        if (Array.isArray(mesh.material)) {\n          materials.push.apply(materials, _toConsumableArray(mesh.material));\n        } else {\n          materials.push(mesh.material);\n        }\n      });\n      return materials;\n    }\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      var targetGeometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n      // track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n      var skipAttributes = [];\n      var meshes = this.meshes,\n        useGroups = this.useGroups,\n        _intermediateGeometry = this._intermediateGeometry,\n        _diffMap = this._diffMap;\n      for (var i = 0, l = meshes.length; i < l; i++) {\n        var mesh = meshes[i];\n        var geom = _intermediateGeometry[i];\n        var diff = _diffMap.get(mesh);\n        if (!diff || diff.didChange(mesh)) {\n          this._convertToStaticGeometry(mesh, geom);\n          skipAttributes.push(false);\n          if (!diff) {\n            _diffMap.set(mesh, new GeometryDiff(mesh));\n          } else {\n            diff.update();\n          }\n        } else {\n          skipAttributes.push(true);\n        }\n      }\n      mergeBufferGeometries(_intermediateGeometry, {\n        useGroups: useGroups,\n        skipAttributes: skipAttributes\n      }, targetGeometry);\n      for (var key in targetGeometry.attributes) {\n        targetGeometry.attributes[key].needsUpdate = true;\n      }\n      return targetGeometry;\n    }\n  }, {\n    key: \"_convertToStaticGeometry\",\n    value: function _convertToStaticGeometry(mesh) {\n      var targetGeometry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new BufferGeometry();\n      var geometry = mesh.geometry;\n      var applyWorldTransforms = this.applyWorldTransforms;\n      var includeNormal = this.attributes.includes('normal');\n      var includeTangent = this.attributes.includes('tangent');\n      var attributes = geometry.attributes;\n      var targetAttributes = targetGeometry.attributes;\n\n      // initialize the attributes if they don't exist\n      if (!targetGeometry.index) {\n        targetGeometry.index = geometry.index;\n      }\n      if (!targetAttributes.position) {\n        targetGeometry.setAttribute('position', createAttributeClone(attributes.position));\n      }\n      if (includeNormal && !targetAttributes.normal && attributes.normal) {\n        targetGeometry.setAttribute('normal', createAttributeClone(attributes.normal));\n      }\n      if (includeTangent && !targetAttributes.tangent && attributes.tangent) {\n        targetGeometry.setAttribute('tangent', createAttributeClone(attributes.tangent));\n      }\n\n      // ensure the attributes are consistent\n      validateAttributes(geometry.index, targetGeometry.index);\n      validateAttributes(attributes.position, targetAttributes.position);\n      if (includeNormal) {\n        validateAttributes(attributes.normal, targetAttributes.normal);\n      }\n      if (includeTangent) {\n        validateAttributes(attributes.tangent, targetAttributes.tangent);\n      }\n\n      // generate transformed vertex attribute data\n      var position = attributes.position;\n      var normal = includeNormal ? attributes.normal : null;\n      var tangent = includeTangent ? attributes.tangent : null;\n      var morphPosition = geometry.morphAttributes.position;\n      var morphNormal = geometry.morphAttributes.normal;\n      var morphTangent = geometry.morphAttributes.tangent;\n      var morphTargetsRelative = geometry.morphTargetsRelative;\n      var morphInfluences = mesh.morphTargetInfluences;\n      var normalMatrix = new Matrix3();\n      normalMatrix.getNormalMatrix(mesh.matrixWorld);\n      for (var i = 0, l = attributes.position.count; i < l; i++) {\n        _positionVector.fromBufferAttribute(position, i);\n        if (normal) {\n          _normalVector.fromBufferAttribute(normal, i);\n        }\n        if (tangent) {\n          _tangentVector4.fromBufferAttribute(tangent, i);\n          _tangentVector.fromBufferAttribute(tangent, i);\n        }\n\n        // apply morph target transform\n        if (morphInfluences) {\n          if (morphPosition) {\n            applyMorphTarget(morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector);\n          }\n          if (morphNormal) {\n            applyMorphTarget(morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector);\n          }\n          if (morphTangent) {\n            applyMorphTarget(morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector);\n          }\n        }\n\n        // apply bone transform\n        if (mesh.isSkinnedMesh) {\n          mesh.applyBoneTransform(i, _positionVector);\n          if (normal) {\n            boneNormalTransform(mesh, i, _normalVector);\n          }\n          if (tangent) {\n            boneNormalTransform(mesh, i, _tangentVector);\n          }\n        }\n\n        // update the vectors of the attributes\n        if (applyWorldTransforms) {\n          _positionVector.applyMatrix4(mesh.matrixWorld);\n        }\n        targetAttributes.position.setXYZ(i, _positionVector.x, _positionVector.y, _positionVector.z);\n        if (normal) {\n          if (applyWorldTransforms) {\n            _normalVector.applyNormalMatrix(normalMatrix);\n          }\n          targetAttributes.normal.setXYZ(i, _normalVector.x, _normalVector.y, _normalVector.z);\n        }\n        if (tangent) {\n          if (applyWorldTransforms) {\n            _tangentVector.transformDirection(mesh.matrixWorld);\n          }\n          targetAttributes.tangent.setXYZW(i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w);\n        }\n      }\n\n      // copy other attributes over\n      for (var _i4 in this.attributes) {\n        var key = this.attributes[_i4];\n        if (key === 'position' || key === 'tangent' || key === 'normal' || !(key in attributes)) {\n          continue;\n        }\n        if (!targetAttributes[key]) {\n          targetGeometry.setAttribute(key, createAttributeClone(attributes[key]));\n        }\n        validateAttributes(attributes[key], targetAttributes[key]);\n        copyAttributeContents(attributes[key], targetAttributes[key]);\n      }\n      return targetGeometry;\n    }\n  }]);\n  return StaticGeometryGenerator;\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}