{"ast":null,"code":"import _get from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Matrix4, Quaternion, Euler, Bone, Object3D, MeshBasicMaterial, Color, Mesh, BoxGeometry, SphereGeometry } from \"three\";\nimport { CapsuleGeometry } from \"../_polyfill/CapsuleGeometry.js\";\nvar MMDPhysics = /*#__PURE__*/function () {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} rigidBodyParams\n   * @param {Array<Object>} (optional) constraintParams\n   * @param {Object} params - (optional)\n   * @param {Number} params.unitStep - Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Default is 3.\n   * @param {Vector3} params.gravity - Default is ( 0, - 9.8 * 10, 0 )\n   */\n  function MMDPhysics(mesh, rigidBodyParams) {\n    var constraintParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _classCallCheck(this, MMDPhysics);\n    if (typeof Ammo === \"undefined\") {\n      throw new Error(\"THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js\");\n    }\n    this.manager = new ResourceManager();\n    this.mesh = mesh;\n    this.unitStep = params.unitStep !== void 0 ? params.unitStep : 1 / 65;\n    this.maxStepNum = params.maxStepNum !== void 0 ? params.maxStepNum : 3;\n    this.gravity = new Vector3(0, -9.8 * 10, 0);\n    if (params.gravity !== void 0) this.gravity.copy(params.gravity);\n    this.world = params.world !== void 0 ? params.world : null;\n    this.bodies = [];\n    this.constraints = [];\n    this._init(mesh, rigidBodyParams, constraintParams);\n  }\n  /**\n   * Advances Physics calculation and updates bones.\n   *\n   * @param {Number} delta - time in second\n   * @return {MMDPhysics}\n   */\n  _createClass(MMDPhysics, [{\n    key: \"update\",\n    value: function update(delta) {\n      var manager = this.manager;\n      var mesh = this.mesh;\n      var isNonDefaultScale = false;\n      var position = manager.allocThreeVector3();\n      var quaternion = manager.allocThreeQuaternion();\n      var scale = manager.allocThreeVector3();\n      mesh.matrixWorld.decompose(position, quaternion, scale);\n      if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {\n        isNonDefaultScale = true;\n      }\n      var parent;\n      if (isNonDefaultScale) {\n        parent = mesh.parent;\n        if (parent !== null) mesh.parent = null;\n        scale.copy(this.mesh.scale);\n        mesh.scale.set(1, 1, 1);\n        mesh.updateMatrixWorld(true);\n      }\n      this._updateRigidBodies();\n      this._stepSimulation(delta);\n      this._updateBones();\n      if (isNonDefaultScale) {\n        if (parent !== null) mesh.parent = parent;\n        mesh.scale.copy(scale);\n      }\n      manager.freeThreeVector3(scale);\n      manager.freeThreeQuaternion(quaternion);\n      manager.freeThreeVector3(position);\n      return this;\n    }\n    /**\n     * Resets rigid bodies transorm to current bone's.\n     *\n     * @return {MMDPhysics}\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      for (var i = 0, il = this.bodies.length; i < il; i++) {\n        this.bodies[i].reset();\n      }\n      return this;\n    }\n    /**\n     * Warm ups Rigid bodies. Calculates cycles steps.\n     *\n     * @param {Integer} cycles\n     * @return {MMDPhysics}\n     */\n  }, {\n    key: \"warmup\",\n    value: function warmup(cycles) {\n      for (var i = 0; i < cycles; i++) {\n        this.update(1 / 60);\n      }\n      return this;\n    }\n    /**\n     * Sets gravity.\n     *\n     * @param {Vector3} gravity\n     * @return {MMDPhysicsHelper}\n     */\n  }, {\n    key: \"setGravity\",\n    value: function setGravity(gravity) {\n      this.world.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z));\n      this.gravity.copy(gravity);\n      return this;\n    }\n    /**\n     * Creates MMDPhysicsHelper\n     *\n     * @return {MMDPhysicsHelper}\n     */\n  }, {\n    key: \"createHelper\",\n    value: function createHelper() {\n      return new MMDPhysicsHelper(this.mesh, this);\n    }\n    // private methods\n  }, {\n    key: \"_init\",\n    value: function _init(mesh, rigidBodyParams, constraintParams) {\n      var manager = this.manager;\n      var parent = mesh.parent;\n      if (parent !== null) mesh.parent = null;\n      var currentPosition = manager.allocThreeVector3();\n      var currentQuaternion = manager.allocThreeQuaternion();\n      var currentScale = manager.allocThreeVector3();\n      currentPosition.copy(mesh.position);\n      currentQuaternion.copy(mesh.quaternion);\n      currentScale.copy(mesh.scale);\n      mesh.position.set(0, 0, 0);\n      mesh.quaternion.set(0, 0, 0, 1);\n      mesh.scale.set(1, 1, 1);\n      mesh.updateMatrixWorld(true);\n      if (this.world === null) {\n        this.world = this._createWorld();\n        this.setGravity(this.gravity);\n      }\n      this._initRigidBodies(rigidBodyParams);\n      this._initConstraints(constraintParams);\n      if (parent !== null) mesh.parent = parent;\n      mesh.position.copy(currentPosition);\n      mesh.quaternion.copy(currentQuaternion);\n      mesh.scale.copy(currentScale);\n      mesh.updateMatrixWorld(true);\n      this.reset();\n      manager.freeThreeVector3(currentPosition);\n      manager.freeThreeQuaternion(currentQuaternion);\n      manager.freeThreeVector3(currentScale);\n    }\n  }, {\n    key: \"_createWorld\",\n    value: function _createWorld() {\n      var config = new Ammo.btDefaultCollisionConfiguration();\n      var dispatcher = new Ammo.btCollisionDispatcher(config);\n      var cache = new Ammo.btDbvtBroadphase();\n      var solver = new Ammo.btSequentialImpulseConstraintSolver();\n      var world = new Ammo.btDiscreteDynamicsWorld(dispatcher, cache, solver, config);\n      return world;\n    }\n  }, {\n    key: \"_initRigidBodies\",\n    value: function _initRigidBodies(rigidBodies) {\n      for (var i = 0, il = rigidBodies.length; i < il; i++) {\n        this.bodies.push(new RigidBody(this.mesh, this.world, rigidBodies[i], this.manager));\n      }\n    }\n  }, {\n    key: \"_initConstraints\",\n    value: function _initConstraints(constraints) {\n      for (var i = 0, il = constraints.length; i < il; i++) {\n        var params = constraints[i];\n        var bodyA = this.bodies[params.rigidBodyIndex1];\n        var bodyB = this.bodies[params.rigidBodyIndex2];\n        this.constraints.push(new Constraint(this.mesh, this.world, bodyA, bodyB, params, this.manager));\n      }\n    }\n  }, {\n    key: \"_stepSimulation\",\n    value: function _stepSimulation(delta) {\n      var unitStep = this.unitStep;\n      var stepTime = delta;\n      var maxStepNum = (delta / unitStep | 0) + 1;\n      if (stepTime < unitStep) {\n        stepTime = unitStep;\n        maxStepNum = 1;\n      }\n      if (maxStepNum > this.maxStepNum) {\n        maxStepNum = this.maxStepNum;\n      }\n      this.world.stepSimulation(stepTime, maxStepNum, unitStep);\n    }\n  }, {\n    key: \"_updateRigidBodies\",\n    value: function _updateRigidBodies() {\n      for (var i = 0, il = this.bodies.length; i < il; i++) {\n        this.bodies[i].updateFromBone();\n      }\n    }\n  }, {\n    key: \"_updateBones\",\n    value: function _updateBones() {\n      for (var i = 0, il = this.bodies.length; i < il; i++) {\n        this.bodies[i].updateBone();\n      }\n    }\n  }]);\n  return MMDPhysics;\n}();\nvar ResourceManager = /*#__PURE__*/function () {\n  function ResourceManager() {\n    _classCallCheck(this, ResourceManager);\n    this.threeVector3s = [];\n    this.threeMatrix4s = [];\n    this.threeQuaternions = [];\n    this.threeEulers = [];\n    this.transforms = [];\n    this.quaternions = [];\n    this.vector3s = [];\n  }\n  _createClass(ResourceManager, [{\n    key: \"allocThreeVector3\",\n    value: function allocThreeVector3() {\n      return this.threeVector3s.length > 0 ? this.threeVector3s.pop() : new Vector3();\n    }\n  }, {\n    key: \"freeThreeVector3\",\n    value: function freeThreeVector3(v) {\n      this.threeVector3s.push(v);\n    }\n  }, {\n    key: \"allocThreeMatrix4\",\n    value: function allocThreeMatrix4() {\n      return this.threeMatrix4s.length > 0 ? this.threeMatrix4s.pop() : new Matrix4();\n    }\n  }, {\n    key: \"freeThreeMatrix4\",\n    value: function freeThreeMatrix4(m) {\n      this.threeMatrix4s.push(m);\n    }\n  }, {\n    key: \"allocThreeQuaternion\",\n    value: function allocThreeQuaternion() {\n      return this.threeQuaternions.length > 0 ? this.threeQuaternions.pop() : new Quaternion();\n    }\n  }, {\n    key: \"freeThreeQuaternion\",\n    value: function freeThreeQuaternion(q) {\n      this.threeQuaternions.push(q);\n    }\n  }, {\n    key: \"allocThreeEuler\",\n    value: function allocThreeEuler() {\n      return this.threeEulers.length > 0 ? this.threeEulers.pop() : new Euler();\n    }\n  }, {\n    key: \"freeThreeEuler\",\n    value: function freeThreeEuler(e) {\n      this.threeEulers.push(e);\n    }\n  }, {\n    key: \"allocTransform\",\n    value: function allocTransform() {\n      return this.transforms.length > 0 ? this.transforms.pop() : new Ammo.btTransform();\n    }\n  }, {\n    key: \"freeTransform\",\n    value: function freeTransform(t) {\n      this.transforms.push(t);\n    }\n  }, {\n    key: \"allocQuaternion\",\n    value: function allocQuaternion() {\n      return this.quaternions.length > 0 ? this.quaternions.pop() : new Ammo.btQuaternion();\n    }\n  }, {\n    key: \"freeQuaternion\",\n    value: function freeQuaternion(q) {\n      this.quaternions.push(q);\n    }\n  }, {\n    key: \"allocVector3\",\n    value: function allocVector3() {\n      return this.vector3s.length > 0 ? this.vector3s.pop() : new Ammo.btVector3();\n    }\n  }, {\n    key: \"freeVector3\",\n    value: function freeVector3(v) {\n      this.vector3s.push(v);\n    }\n  }, {\n    key: \"setIdentity\",\n    value: function setIdentity(t) {\n      t.setIdentity();\n    }\n  }, {\n    key: \"getBasis\",\n    value: function getBasis(t) {\n      var q = this.allocQuaternion();\n      t.getBasis().getRotation(q);\n      return q;\n    }\n  }, {\n    key: \"getBasisAsMatrix3\",\n    value: function getBasisAsMatrix3(t) {\n      var q = this.getBasis(t);\n      var m = this.quaternionToMatrix3(q);\n      this.freeQuaternion(q);\n      return m;\n    }\n  }, {\n    key: \"getOrigin\",\n    value: function getOrigin(t) {\n      return t.getOrigin();\n    }\n  }, {\n    key: \"setOrigin\",\n    value: function setOrigin(t, v) {\n      t.getOrigin().setValue(v.x(), v.y(), v.z());\n    }\n  }, {\n    key: \"copyOrigin\",\n    value: function copyOrigin(t1, t2) {\n      var o = t2.getOrigin();\n      this.setOrigin(t1, o);\n    }\n  }, {\n    key: \"setBasis\",\n    value: function setBasis(t, q) {\n      t.setRotation(q);\n    }\n  }, {\n    key: \"setBasisFromMatrix3\",\n    value: function setBasisFromMatrix3(t, m) {\n      var q = this.matrix3ToQuaternion(m);\n      this.setBasis(t, q);\n      this.freeQuaternion(q);\n    }\n  }, {\n    key: \"setOriginFromArray3\",\n    value: function setOriginFromArray3(t, a) {\n      t.getOrigin().setValue(a[0], a[1], a[2]);\n    }\n  }, {\n    key: \"setOriginFromThreeVector3\",\n    value: function setOriginFromThreeVector3(t, v) {\n      t.getOrigin().setValue(v.x, v.y, v.z);\n    }\n  }, {\n    key: \"setBasisFromArray3\",\n    value: function setBasisFromArray3(t, a) {\n      var thQ = this.allocThreeQuaternion();\n      var thE = this.allocThreeEuler();\n      thE.set(a[0], a[1], a[2]);\n      this.setBasisFromThreeQuaternion(t, thQ.setFromEuler(thE));\n      this.freeThreeEuler(thE);\n      this.freeThreeQuaternion(thQ);\n    }\n  }, {\n    key: \"setBasisFromThreeQuaternion\",\n    value: function setBasisFromThreeQuaternion(t, a) {\n      var q = this.allocQuaternion();\n      q.setX(a.x);\n      q.setY(a.y);\n      q.setZ(a.z);\n      q.setW(a.w);\n      this.setBasis(t, q);\n      this.freeQuaternion(q);\n    }\n  }, {\n    key: \"multiplyTransforms\",\n    value: function multiplyTransforms(t1, t2) {\n      var t = this.allocTransform();\n      this.setIdentity(t);\n      var m1 = this.getBasisAsMatrix3(t1);\n      var m2 = this.getBasisAsMatrix3(t2);\n      var o1 = this.getOrigin(t1);\n      var o2 = this.getOrigin(t2);\n      var v1 = this.multiplyMatrix3ByVector3(m1, o2);\n      var v2 = this.addVector3(v1, o1);\n      this.setOrigin(t, v2);\n      var m3 = this.multiplyMatrices3(m1, m2);\n      this.setBasisFromMatrix3(t, m3);\n      this.freeVector3(v1);\n      this.freeVector3(v2);\n      return t;\n    }\n  }, {\n    key: \"inverseTransform\",\n    value: function inverseTransform(t) {\n      var t2 = this.allocTransform();\n      var m1 = this.getBasisAsMatrix3(t);\n      var o = this.getOrigin(t);\n      var m2 = this.transposeMatrix3(m1);\n      var v1 = this.negativeVector3(o);\n      var v2 = this.multiplyMatrix3ByVector3(m2, v1);\n      this.setOrigin(t2, v2);\n      this.setBasisFromMatrix3(t2, m2);\n      this.freeVector3(v1);\n      this.freeVector3(v2);\n      return t2;\n    }\n  }, {\n    key: \"multiplyMatrices3\",\n    value: function multiplyMatrices3(m1, m2) {\n      var m3 = [];\n      var v10 = this.rowOfMatrix3(m1, 0);\n      var v11 = this.rowOfMatrix3(m1, 1);\n      var v12 = this.rowOfMatrix3(m1, 2);\n      var v20 = this.columnOfMatrix3(m2, 0);\n      var v21 = this.columnOfMatrix3(m2, 1);\n      var v22 = this.columnOfMatrix3(m2, 2);\n      m3[0] = this.dotVectors3(v10, v20);\n      m3[1] = this.dotVectors3(v10, v21);\n      m3[2] = this.dotVectors3(v10, v22);\n      m3[3] = this.dotVectors3(v11, v20);\n      m3[4] = this.dotVectors3(v11, v21);\n      m3[5] = this.dotVectors3(v11, v22);\n      m3[6] = this.dotVectors3(v12, v20);\n      m3[7] = this.dotVectors3(v12, v21);\n      m3[8] = this.dotVectors3(v12, v22);\n      this.freeVector3(v10);\n      this.freeVector3(v11);\n      this.freeVector3(v12);\n      this.freeVector3(v20);\n      this.freeVector3(v21);\n      this.freeVector3(v22);\n      return m3;\n    }\n  }, {\n    key: \"addVector3\",\n    value: function addVector3(v1, v2) {\n      var v = this.allocVector3();\n      v.setValue(v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z());\n      return v;\n    }\n  }, {\n    key: \"dotVectors3\",\n    value: function dotVectors3(v1, v2) {\n      return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z();\n    }\n  }, {\n    key: \"rowOfMatrix3\",\n    value: function rowOfMatrix3(m, i) {\n      var v = this.allocVector3();\n      v.setValue(m[i * 3 + 0], m[i * 3 + 1], m[i * 3 + 2]);\n      return v;\n    }\n  }, {\n    key: \"columnOfMatrix3\",\n    value: function columnOfMatrix3(m, i) {\n      var v = this.allocVector3();\n      v.setValue(m[i + 0], m[i + 3], m[i + 6]);\n      return v;\n    }\n  }, {\n    key: \"negativeVector3\",\n    value: function negativeVector3(v) {\n      var v2 = this.allocVector3();\n      v2.setValue(-v.x(), -v.y(), -v.z());\n      return v2;\n    }\n  }, {\n    key: \"multiplyMatrix3ByVector3\",\n    value: function multiplyMatrix3ByVector3(m, v) {\n      var v4 = this.allocVector3();\n      var v0 = this.rowOfMatrix3(m, 0);\n      var v1 = this.rowOfMatrix3(m, 1);\n      var v2 = this.rowOfMatrix3(m, 2);\n      var x = this.dotVectors3(v0, v);\n      var y = this.dotVectors3(v1, v);\n      var z = this.dotVectors3(v2, v);\n      v4.setValue(x, y, z);\n      this.freeVector3(v0);\n      this.freeVector3(v1);\n      this.freeVector3(v2);\n      return v4;\n    }\n  }, {\n    key: \"transposeMatrix3\",\n    value: function transposeMatrix3(m) {\n      var m2 = [];\n      m2[0] = m[0];\n      m2[1] = m[3];\n      m2[2] = m[6];\n      m2[3] = m[1];\n      m2[4] = m[4];\n      m2[5] = m[7];\n      m2[6] = m[2];\n      m2[7] = m[5];\n      m2[8] = m[8];\n      return m2;\n    }\n  }, {\n    key: \"quaternionToMatrix3\",\n    value: function quaternionToMatrix3(q) {\n      var m = [];\n      var x = q.x();\n      var y = q.y();\n      var z = q.z();\n      var w = q.w();\n      var xx = x * x;\n      var yy = y * y;\n      var zz = z * z;\n      var xy = x * y;\n      var yz = y * z;\n      var zx = z * x;\n      var xw = x * w;\n      var yw = y * w;\n      var zw = z * w;\n      m[0] = 1 - 2 * (yy + zz);\n      m[1] = 2 * (xy - zw);\n      m[2] = 2 * (zx + yw);\n      m[3] = 2 * (xy + zw);\n      m[4] = 1 - 2 * (zz + xx);\n      m[5] = 2 * (yz - xw);\n      m[6] = 2 * (zx - yw);\n      m[7] = 2 * (yz + xw);\n      m[8] = 1 - 2 * (xx + yy);\n      return m;\n    }\n  }, {\n    key: \"matrix3ToQuaternion\",\n    value: function matrix3ToQuaternion(m) {\n      var t = m[0] + m[4] + m[8];\n      var s, x, y, z, w;\n      if (t > 0) {\n        s = Math.sqrt(t + 1) * 2;\n        w = 0.25 * s;\n        x = (m[7] - m[5]) / s;\n        y = (m[2] - m[6]) / s;\n        z = (m[3] - m[1]) / s;\n      } else if (m[0] > m[4] && m[0] > m[8]) {\n        s = Math.sqrt(1 + m[0] - m[4] - m[8]) * 2;\n        w = (m[7] - m[5]) / s;\n        x = 0.25 * s;\n        y = (m[1] + m[3]) / s;\n        z = (m[2] + m[6]) / s;\n      } else if (m[4] > m[8]) {\n        s = Math.sqrt(1 + m[4] - m[0] - m[8]) * 2;\n        w = (m[2] - m[6]) / s;\n        x = (m[1] + m[3]) / s;\n        y = 0.25 * s;\n        z = (m[5] + m[7]) / s;\n      } else {\n        s = Math.sqrt(1 + m[8] - m[0] - m[4]) * 2;\n        w = (m[3] - m[1]) / s;\n        x = (m[2] + m[6]) / s;\n        y = (m[5] + m[7]) / s;\n        z = 0.25 * s;\n      }\n      var q = this.allocQuaternion();\n      q.setX(x);\n      q.setY(y);\n      q.setZ(z);\n      q.setW(w);\n      return q;\n    }\n  }]);\n  return ResourceManager;\n}();\nvar RigidBody = /*#__PURE__*/function () {\n  function RigidBody(mesh, world, params, manager) {\n    _classCallCheck(this, RigidBody);\n    this.mesh = mesh;\n    this.world = world;\n    this.params = params;\n    this.manager = manager;\n    this.body = null;\n    this.bone = null;\n    this.boneOffsetForm = null;\n    this.boneOffsetFormInverse = null;\n    this._init();\n  }\n  /**\n   * Resets rigid body transform to the current bone's.\n   *\n   * @return {RigidBody}\n   */\n  _createClass(RigidBody, [{\n    key: \"reset\",\n    value: function reset() {\n      this._setTransformFromBone();\n      return this;\n    }\n    /**\n     * Updates rigid body's transform from the current bone.\n     *\n     * @return {RidigBody}\n     */\n  }, {\n    key: \"updateFromBone\",\n    value: function updateFromBone() {\n      if (this.params.boneIndex !== -1 && this.params.type === 0) {\n        this._setTransformFromBone();\n      }\n      return this;\n    }\n    /**\n     * Updates bone from the current ridid body's transform.\n     *\n     * @return {RidigBody}\n     */\n  }, {\n    key: \"updateBone\",\n    value: function updateBone() {\n      if (this.params.type === 0 || this.params.boneIndex === -1) {\n        return this;\n      }\n      this._updateBoneRotation();\n      if (this.params.type === 1) {\n        this._updateBonePosition();\n      }\n      this.bone.updateMatrixWorld(true);\n      if (this.params.type === 2) {\n        this._setPositionFromBone();\n      }\n      return this;\n    }\n    // private methods\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      function generateShape(p) {\n        switch (p.shapeType) {\n          case 0:\n            return new Ammo.btSphereShape(p.width);\n          case 1:\n            return new Ammo.btBoxShape(new Ammo.btVector3(p.width, p.height, p.depth));\n          case 2:\n            return new Ammo.btCapsuleShape(p.width, p.height);\n          default:\n            throw new Error(\"unknown shape type \" + p.shapeType);\n        }\n      }\n      var manager = this.manager;\n      var params = this.params;\n      var bones = this.mesh.skeleton.bones;\n      var bone = params.boneIndex === -1 ? new Bone() : bones[params.boneIndex];\n      var shape = generateShape(params);\n      var weight = params.type === 0 ? 0 : params.weight;\n      var localInertia = manager.allocVector3();\n      localInertia.setValue(0, 0, 0);\n      if (weight !== 0) {\n        shape.calculateLocalInertia(weight, localInertia);\n      }\n      var boneOffsetForm = manager.allocTransform();\n      manager.setIdentity(boneOffsetForm);\n      manager.setOriginFromArray3(boneOffsetForm, params.position);\n      manager.setBasisFromArray3(boneOffsetForm, params.rotation);\n      var vector = manager.allocThreeVector3();\n      var boneForm = manager.allocTransform();\n      manager.setIdentity(boneForm);\n      manager.setOriginFromThreeVector3(boneForm, bone.getWorldPosition(vector));\n      var form = manager.multiplyTransforms(boneForm, boneOffsetForm);\n      var state = new Ammo.btDefaultMotionState(form);\n      var info = new Ammo.btRigidBodyConstructionInfo(weight, state, shape, localInertia);\n      info.set_m_friction(params.friction);\n      info.set_m_restitution(params.restitution);\n      var body = new Ammo.btRigidBody(info);\n      if (params.type === 0) {\n        body.setCollisionFlags(body.getCollisionFlags() | 2);\n        body.setActivationState(4);\n      }\n      body.setDamping(params.positionDamping, params.rotationDamping);\n      body.setSleepingThresholds(0, 0);\n      this.world.addRigidBody(body, 1 << params.groupIndex, params.groupTarget);\n      this.body = body;\n      this.bone = bone;\n      this.boneOffsetForm = boneOffsetForm;\n      this.boneOffsetFormInverse = manager.inverseTransform(boneOffsetForm);\n      manager.freeVector3(localInertia);\n      manager.freeTransform(form);\n      manager.freeTransform(boneForm);\n      manager.freeThreeVector3(vector);\n    }\n  }, {\n    key: \"_getBoneTransform\",\n    value: function _getBoneTransform() {\n      var manager = this.manager;\n      var p = manager.allocThreeVector3();\n      var q = manager.allocThreeQuaternion();\n      var s = manager.allocThreeVector3();\n      this.bone.matrixWorld.decompose(p, q, s);\n      var tr = manager.allocTransform();\n      manager.setOriginFromThreeVector3(tr, p);\n      manager.setBasisFromThreeQuaternion(tr, q);\n      var form = manager.multiplyTransforms(tr, this.boneOffsetForm);\n      manager.freeTransform(tr);\n      manager.freeThreeVector3(s);\n      manager.freeThreeQuaternion(q);\n      manager.freeThreeVector3(p);\n      return form;\n    }\n  }, {\n    key: \"_getWorldTransformForBone\",\n    value: function _getWorldTransformForBone() {\n      var manager = this.manager;\n      var tr = this.body.getCenterOfMassTransform();\n      return manager.multiplyTransforms(tr, this.boneOffsetFormInverse);\n    }\n  }, {\n    key: \"_setTransformFromBone\",\n    value: function _setTransformFromBone() {\n      var manager = this.manager;\n      var form = this._getBoneTransform();\n      this.body.setCenterOfMassTransform(form);\n      this.body.getMotionState().setWorldTransform(form);\n      manager.freeTransform(form);\n    }\n  }, {\n    key: \"_setPositionFromBone\",\n    value: function _setPositionFromBone() {\n      var manager = this.manager;\n      var form = this._getBoneTransform();\n      var tr = manager.allocTransform();\n      this.body.getMotionState().getWorldTransform(tr);\n      manager.copyOrigin(tr, form);\n      this.body.setCenterOfMassTransform(tr);\n      this.body.getMotionState().setWorldTransform(tr);\n      manager.freeTransform(tr);\n      manager.freeTransform(form);\n    }\n  }, {\n    key: \"_updateBoneRotation\",\n    value: function _updateBoneRotation() {\n      var manager = this.manager;\n      var tr = this._getWorldTransformForBone();\n      var q = manager.getBasis(tr);\n      var thQ = manager.allocThreeQuaternion();\n      var thQ2 = manager.allocThreeQuaternion();\n      var thQ3 = manager.allocThreeQuaternion();\n      thQ.set(q.x(), q.y(), q.z(), q.w());\n      thQ2.setFromRotationMatrix(this.bone.matrixWorld);\n      thQ2.conjugate();\n      thQ2.multiply(thQ);\n      thQ3.setFromRotationMatrix(this.bone.matrix);\n      this.bone.quaternion.copy(thQ2.multiply(thQ3).normalize());\n      manager.freeThreeQuaternion(thQ);\n      manager.freeThreeQuaternion(thQ2);\n      manager.freeThreeQuaternion(thQ3);\n      manager.freeQuaternion(q);\n      manager.freeTransform(tr);\n    }\n  }, {\n    key: \"_updateBonePosition\",\n    value: function _updateBonePosition() {\n      var manager = this.manager;\n      var tr = this._getWorldTransformForBone();\n      var thV = manager.allocThreeVector3();\n      var o = manager.getOrigin(tr);\n      thV.set(o.x(), o.y(), o.z());\n      if (this.bone.parent) {\n        this.bone.parent.worldToLocal(thV);\n      }\n      this.bone.position.copy(thV);\n      manager.freeThreeVector3(thV);\n      manager.freeTransform(tr);\n    }\n  }]);\n  return RigidBody;\n}();\nvar Constraint = /*#__PURE__*/function () {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Ammo.btDiscreteDynamicsWorld} world\n   * @param {RigidBody} bodyA\n   * @param {RigidBody} bodyB\n   * @param {Object} params\n   * @param {ResourceManager} manager\n   */\n  function Constraint(mesh, world, bodyA, bodyB, params, manager) {\n    _classCallCheck(this, Constraint);\n    this.mesh = mesh;\n    this.world = world;\n    this.bodyA = bodyA;\n    this.bodyB = bodyB;\n    this.params = params;\n    this.manager = manager;\n    this.constraint = null;\n    this._init();\n  }\n  // private method\n  _createClass(Constraint, [{\n    key: \"_init\",\n    value: function _init() {\n      var manager = this.manager;\n      var params = this.params;\n      var bodyA = this.bodyA;\n      var bodyB = this.bodyB;\n      var form = manager.allocTransform();\n      manager.setIdentity(form);\n      manager.setOriginFromArray3(form, params.position);\n      manager.setBasisFromArray3(form, params.rotation);\n      var formA = manager.allocTransform();\n      var formB = manager.allocTransform();\n      bodyA.body.getMotionState().getWorldTransform(formA);\n      bodyB.body.getMotionState().getWorldTransform(formB);\n      var formInverseA = manager.inverseTransform(formA);\n      var formInverseB = manager.inverseTransform(formB);\n      var formA2 = manager.multiplyTransforms(formInverseA, form);\n      var formB2 = manager.multiplyTransforms(formInverseB, form);\n      var constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.body, bodyB.body, formA2, formB2, true);\n      var lll = manager.allocVector3();\n      var lul = manager.allocVector3();\n      var all = manager.allocVector3();\n      var aul = manager.allocVector3();\n      lll.setValue(params.translationLimitation1[0], params.translationLimitation1[1], params.translationLimitation1[2]);\n      lul.setValue(params.translationLimitation2[0], params.translationLimitation2[1], params.translationLimitation2[2]);\n      all.setValue(params.rotationLimitation1[0], params.rotationLimitation1[1], params.rotationLimitation1[2]);\n      aul.setValue(params.rotationLimitation2[0], params.rotationLimitation2[1], params.rotationLimitation2[2]);\n      constraint.setLinearLowerLimit(lll);\n      constraint.setLinearUpperLimit(lul);\n      constraint.setAngularLowerLimit(all);\n      constraint.setAngularUpperLimit(aul);\n      for (var i = 0; i < 3; i++) {\n        if (params.springPosition[i] !== 0) {\n          constraint.enableSpring(i, true);\n          constraint.setStiffness(i, params.springPosition[i]);\n        }\n      }\n      for (var _i = 0; _i < 3; _i++) {\n        if (params.springRotation[_i] !== 0) {\n          constraint.enableSpring(_i + 3, true);\n          constraint.setStiffness(_i + 3, params.springRotation[_i]);\n        }\n      }\n      if (constraint.setParam !== void 0) {\n        for (var _i2 = 0; _i2 < 6; _i2++) {\n          constraint.setParam(2, 0.475, _i2);\n        }\n      }\n      this.world.addConstraint(constraint, true);\n      this.constraint = constraint;\n      manager.freeTransform(form);\n      manager.freeTransform(formA);\n      manager.freeTransform(formB);\n      manager.freeTransform(formInverseA);\n      manager.freeTransform(formInverseB);\n      manager.freeTransform(formA2);\n      manager.freeTransform(formB2);\n      manager.freeVector3(lll);\n      manager.freeVector3(lul);\n      manager.freeVector3(all);\n      manager.freeVector3(aul);\n    }\n  }]);\n  return Constraint;\n}();\nvar _position = new Vector3();\nvar _quaternion = new Quaternion();\nvar _scale = new Vector3();\nvar _matrixWorldInv = new Matrix4();\nvar MMDPhysicsHelper = /*#__PURE__*/function (_Object3D) {\n  _inherits(MMDPhysicsHelper, _Object3D);\n  var _super = _createSuper(MMDPhysicsHelper);\n  /**\n   * Visualize Rigid bodies\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Physics} physics\n   */\n  function MMDPhysicsHelper(mesh, physics) {\n    var _this;\n    _classCallCheck(this, MMDPhysicsHelper);\n    _this = _super.call(this);\n    _this.root = mesh;\n    _this.physics = physics;\n    _this.matrix.copy(mesh.matrixWorld);\n    _this.matrixAutoUpdate = false;\n    _this.materials = [];\n    _this.materials.push(new MeshBasicMaterial({\n      color: new Color(16746632),\n      wireframe: true,\n      depthTest: false,\n      depthWrite: false,\n      opacity: 0.25,\n      transparent: true\n    }));\n    _this.materials.push(new MeshBasicMaterial({\n      color: new Color(8978312),\n      wireframe: true,\n      depthTest: false,\n      depthWrite: false,\n      opacity: 0.25,\n      transparent: true\n    }));\n    _this.materials.push(new MeshBasicMaterial({\n      color: new Color(8947967),\n      wireframe: true,\n      depthTest: false,\n      depthWrite: false,\n      opacity: 0.25,\n      transparent: true\n    }));\n    _this._init();\n    return _this;\n  }\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n  _createClass(MMDPhysicsHelper, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var materials = this.materials;\n      var children = this.children;\n      for (var i = 0; i < materials.length; i++) {\n        materials[i].dispose();\n      }\n      for (var _i3 = 0; _i3 < children.length; _i3++) {\n        var child = children[_i3];\n        if (child.isMesh) child.geometry.dispose();\n      }\n    }\n    /**\n     * Updates Rigid Bodies visualization.\n     */\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      var mesh = this.root;\n      if (this.visible) {\n        var bodies = this.physics.bodies;\n        _matrixWorldInv.copy(mesh.matrixWorld).decompose(_position, _quaternion, _scale).compose(_position, _quaternion, _scale.set(1, 1, 1)).invert();\n        for (var i = 0, il = bodies.length; i < il; i++) {\n          var body = bodies[i].body;\n          var child = this.children[i];\n          var tr = body.getCenterOfMassTransform();\n          var origin = tr.getOrigin();\n          var rotation = tr.getRotation();\n          child.position.set(origin.x(), origin.y(), origin.z()).applyMatrix4(_matrixWorldInv);\n          child.quaternion.setFromRotationMatrix(_matrixWorldInv).multiply(_quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w()));\n        }\n      }\n      this.matrix.copy(mesh.matrixWorld).decompose(_position, _quaternion, _scale).compose(_position, _quaternion, _scale.set(1, 1, 1));\n      _get(_getPrototypeOf(MMDPhysicsHelper.prototype), \"updateMatrixWorld\", this).call(this, force);\n    }\n    // private method\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var bodies = this.physics.bodies;\n      function createGeometry(param2) {\n        switch (param2.shapeType) {\n          case 0:\n            return new SphereGeometry(param2.width, 16, 8);\n          case 1:\n            return new BoxGeometry(param2.width * 2, param2.height * 2, param2.depth * 2, 8, 8, 8);\n          case 2:\n            return new CapsuleGeometry(param2.width, param2.height, 8, 16);\n          default:\n            return null;\n        }\n      }\n      for (var i = 0, il = bodies.length; i < il; i++) {\n        var param = bodies[i].params;\n        this.add(new Mesh(createGeometry(param), this.materials[param.type]));\n      }\n    }\n  }]);\n  return MMDPhysicsHelper;\n}(Object3D);\nexport { MMDPhysics };\n//# sourceMappingURL=MMDPhysics.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}