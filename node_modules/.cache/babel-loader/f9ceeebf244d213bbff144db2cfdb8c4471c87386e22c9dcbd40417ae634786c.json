{"ast":null,"code":"import BRDF_Lambert from './BSDF/BRDF_Lambert.js';\nimport BRDF_GGX from './BSDF/BRDF_GGX.js';\nimport DFGApprox from './BSDF/DFGApprox.js';\nimport EnvironmentBRDF from './BSDF/EnvironmentBRDF.js';\nimport F_Schlick from './BSDF/F_Schlick.js';\nimport Schlick_to_F0 from './BSDF/Schlick_to_F0.js';\nimport BRDF_Sheen from './BSDF/BRDF_Sheen.js';\nimport LightingModel from '../core/LightingModel.js';\nimport { diffuseColor, specularColor, roughness, clearcoat, clearcoatRoughness, sheen, sheenRoughness, iridescence, iridescenceIOR, iridescenceThickness } from '../core/PropertyNode.js';\nimport { transformedNormalView, transformedClearcoatNormalView } from '../accessors/NormalNode.js';\nimport { positionViewDirection } from '../accessors/PositionNode.js';\nimport { float, vec3, mat3 } from '../shadernode/ShaderNode.js';\nimport { cond } from '../math/CondNode.js';\nimport { mix, smoothstep } from '../math/MathNode.js';\n\n//\n// Iridescence\n//\n\n// XYZ to linear-sRGB color space\nconst XYZ_TO_REC709 = mat3(3.2404542, -0.9692660, 0.0556434, -1.5371385, 1.8760108, -0.2040259, -0.4985314, 0.0415560, 1.0572252);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nconst Fresnel0ToIor = fresnel0 => {\n  const sqrtF0 = fresnel0.sqrt();\n  return vec3(1.0).add(sqrtF0).div(vec3(1.0).sub(sqrtF0));\n};\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nconst IorToFresnel0 = (transmittedIor, incidentIor) => {\n  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();\n};\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nconst evalSensitivity = (OPD, shift) => {\n  const phase = OPD.mul(2.0 * Math.PI * 1.0e-9);\n  const val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n  const pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n  const VAR = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n  const x = float(9.7470e-14 * Math.sqrt(2.0 * Math.PI * 4.5282e+09)).mul(phase.mul(2.2399e+06).add(shift.x).cos()).mul(phase.pow2().mul(-4.5282e+09).exp());\n  let xyz = val.mul(VAR.mul(2.0 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());\n  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(1.0685e-7);\n  const rgb = XYZ_TO_REC709.mul(xyz);\n  return rgb;\n};\nconst evalIridescence = (outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0) => {\n  // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n  const iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\n  // Evaluate the cosTheta on the base layer (Snell law)\n  const sinTheta2Sq = outsideIOR.div(iridescenceIOR).pow2().mul(float(1).sub(cosTheta1.pow2()));\n\n  // Handle TIR:\n  const cosTheta2Sq = float(1).sub(sinTheta2Sq);\n  /*if ( cosTheta2Sq < 0.0 ) {\n  \t\t\treturn vec3( 1.0 );\n  \t}*/\n\n  const cosTheta2 = cosTheta2Sq.sqrt();\n\n  // First interface\n  const R0 = IorToFresnel0(iridescenceIOR, outsideIOR);\n  const R12 = F_Schlick({\n    f0: R0,\n    f90: 1.0,\n    dotVH: cosTheta1\n  });\n  //const R21 = R12;\n  const T121 = R12.oneMinus();\n  const phi12 = iridescenceIOR.lessThan(outsideIOR).cond(Math.PI, 0.0);\n  const phi21 = float(Math.PI).sub(phi12);\n\n  // Second interface\n  const baseIOR = Fresnel0ToIor(baseF0.clamp(0.0, 0.9999)); // guard against 1.0\n  const R1 = IorToFresnel0(baseIOR, iridescenceIOR.vec3());\n  const R23 = F_Schlick({\n    f0: R1,\n    f90: 1.0,\n    dotVH: cosTheta2\n  });\n  const phi23 = vec3(baseIOR.x.lessThan(iridescenceIOR).cond(Math.PI, 0.0), baseIOR.y.lessThan(iridescenceIOR).cond(Math.PI, 0.0), baseIOR.z.lessThan(iridescenceIOR).cond(Math.PI, 0.0));\n\n  // Phase shift\n  const OPD = iridescenceIOR.mul(thinFilmThickness, cosTheta2, 2.0);\n  const phi = vec3(phi21).add(phi23);\n\n  // Compound terms\n  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);\n  const r123 = R123.sqrt();\n  const Rs = T121.pow2().mul(R23).div(vec3(1.0).sub(R123));\n\n  // Reflectance term for m = 0 (DC term amplitude)\n  const C0 = R12.add(Rs);\n  let I = C0;\n\n  // Reflectance term for m > 0 (pairs of diracs)\n  let Cm = Rs.sub(T121);\n  for (let m = 1; m <= 2; ++m) {\n    Cm = Cm.mul(r123);\n    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2.0);\n    I = I.add(Cm.mul(Sm));\n  }\n\n  // Since out of gamut colors might be produced, negative color values are clamped to 0.\n  return I.max(vec3(0.0));\n};\n\n//\n//\tSheen\n//\n\n// This is a curve-fit approxmation to the \"Charlie sheen\" BRDF integrated over the hemisphere from\n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nconst IBLSheenBRDF = (normal, viewDir, roughness) => {\n  const dotNV = normal.dot(viewDir).saturate();\n  const r2 = roughness.pow2();\n  const a = cond(roughness.lessThan(0.25), float(-339.2).mul(r2).add(float(161.4).mul(roughness)).sub(25.9), float(-8.48).mul(r2).add(float(14.3).mul(roughness)).sub(9.95));\n  const b = cond(roughness.lessThan(0.25), float(44.0).mul(r2).sub(float(23.7).mul(roughness)).add(3.26), float(1.97).mul(r2).sub(float(3.27).mul(roughness)).add(0.72));\n  const DG = cond(roughness.lessThan(0.25), 0.0, float(0.1).mul(roughness).sub(0.025)).add(a.mul(dotNV).add(b).exp());\n  return DG.mul(1.0 / Math.PI).saturate();\n};\nconst clearcoatF0 = vec3(0.04);\nconst clearcoatF90 = vec3(1);\n\n//\n\nclass PhysicalLightingModel extends LightingModel {\n  constructor(clearcoat = true, sheen = true, iridescence = true) {\n    super();\n    this.clearcoat = clearcoat;\n    this.sheen = sheen;\n    this.iridescence = iridescence;\n    this.clearcoatRadiance = null;\n    this.clearcoatSpecular = null;\n    this.sheenSpecular = null;\n    this.iridescenceFresnel = null;\n    this.iridescenceF0 = null;\n  }\n  init({\n    reflectedLight\n  }) {\n    if (this.clearcoat === true) {\n      this.clearcoatRadiance = vec3().temp();\n      this.clearcoatSpecular = vec3().temp();\n      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      const Fcc = F_Schlick({\n        dotVH: dotNVcc,\n        f0: clearcoatF0,\n        f90: clearcoatF90\n      });\n      const outgoingLight = reflectedLight.total;\n      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecular.mul(clearcoat));\n      outgoingLight.assign(clearcoatLight);\n    }\n    if (this.sheen === true) {\n      this.sheenSpecular = vec3().temp();\n      const outgoingLight = reflectedLight.total;\n      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();\n      const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecular);\n      outgoingLight.assign(sheenLight);\n    }\n    if (this.iridescence === true) {\n      const dotNVi = transformedNormalView.dot(positionViewDirection).clamp();\n      this.iridescenceFresnel = evalIridescence(float(1.0), iridescenceIOR, dotNVi, iridescenceThickness, specularColor);\n      this.iridescenceF0 = Schlick_to_F0({\n        f: this.iridescenceFresnel,\n        f90: 1.0,\n        dotVH: dotNVi\n      });\n    }\n  }\n\n  // Fdez-Ag√ºera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n  // Approximates multiscattering in order to preserve energy.\n  // http://www.jcgt.org/published/0008/01/03/\n\n  computeMultiscattering(singleScatter, multiScatter, specularF90 = float(1)) {\n    const fab = DFGApprox({\n      roughness\n    });\n    const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;\n    const FssEss = Fr.mul(fab.x).add(specularF90.mul(fab.y));\n    const Ess = fab.x.add(fab.y);\n    const Ems = Ess.oneMinus();\n    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619)); // 1/21\n    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());\n    singleScatter.addAssign(FssEss);\n    multiScatter.addAssign(Fms.mul(Ems));\n  }\n  direct({\n    lightDirection,\n    lightColor,\n    reflectedLight\n  }) {\n    const dotNL = transformedNormalView.dot(lightDirection).clamp();\n    const irradiance = dotNL.mul(lightColor);\n    if (this.sheen === true) {\n      this.sheenSpecular.addAssign(irradiance.mul(BRDF_Sheen({\n        lightDirection\n      })));\n    }\n    if (this.clearcoat === true) {\n      const dotNLcc = transformedClearcoatNormalView.dot(lightDirection).clamp();\n      const ccIrradiance = dotNLcc.mul(lightColor);\n      this.clearcoatSpecular.addAssign(ccIrradiance.mul(BRDF_GGX({\n        lightDirection,\n        f0: clearcoatF0,\n        f90: clearcoatF90,\n        roughness: clearcoatRoughness,\n        normalView: transformedClearcoatNormalView\n      })));\n    }\n    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor: diffuseColor.rgb\n    })));\n    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX({\n      lightDirection,\n      f0: specularColor,\n      f90: 1,\n      roughness,\n      iridescence: this.iridescence,\n      iridescenceFresnel: this.iridescenceFresnel\n    })));\n  }\n  indirectDiffuse({\n    irradiance,\n    reflectedLight\n  }) {\n    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({\n      diffuseColor\n    })));\n  }\n  indirectSpecular({\n    radiance,\n    iblIrradiance,\n    reflectedLight\n  }) {\n    if (this.sheen === true) {\n      this.sheenSpecular.addAssign(iblIrradiance.mul(sheen, IBLSheenBRDF(transformedNormalView, positionViewDirection, sheenRoughness)));\n    }\n    if (this.clearcoat === true) {\n      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();\n      const clearcoatEnv = EnvironmentBRDF({\n        dotNV: dotNVcc,\n        specularColor: clearcoatF0,\n        specularF90: clearcoatF90,\n        roughness: clearcoatRoughness\n      });\n      this.clearcoatSpecular.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));\n    }\n\n    // Both indirect specular and indirect diffuse light accumulate here\n\n    const singleScattering = vec3().temp();\n    const multiScattering = vec3().temp();\n    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);\n    this.computeMultiscattering(singleScattering, multiScattering);\n    const totalScattering = singleScattering.add(multiScattering);\n    const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());\n    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));\n    reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));\n    reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));\n  }\n  ambientOcclusion({\n    ambientOcclusion,\n    reflectedLight\n  }) {\n    const dotNV = transformedNormalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV\n\n    const aoNV = dotNV.add(ambientOcclusion);\n    const aoExp = roughness.mul(-16.0).oneMinus().negate().exp2();\n    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();\n    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);\n    reflectedLight.indirectSpecular.mulAssign(aoNode);\n  }\n}\nexport default PhysicalLightingModel;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}