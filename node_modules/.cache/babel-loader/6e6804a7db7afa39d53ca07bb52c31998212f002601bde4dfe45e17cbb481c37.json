{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Object3D, Mesh, SphereGeometry, MeshBasicMaterial } from \"three\";\nimport { GLTFLoader } from \"../loaders/GLTFLoader.js\";\nimport { MotionControllerConstants, fetchProfile, MotionController } from \"../libs/MotionControllers.js\";\nvar DEFAULT_PROFILES_PATH = \"https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles\";\nvar DEFAULT_PROFILE = \"generic-trigger\";\nvar applyEnvironmentMap = function applyEnvironmentMap(envMap, obj) {\n  obj.traverse(function (child) {\n    if (child instanceof Mesh && \"envMap\" in child.material) {\n      child.material.envMap = envMap;\n      child.material.needsUpdate = true;\n    }\n  });\n};\nvar XRControllerModel = /*#__PURE__*/function (_Object3D) {\n  _inherits(XRControllerModel, _Object3D);\n  var _super = _createSuper(XRControllerModel);\n  function XRControllerModel() {\n    var _this;\n    _classCallCheck(this, XRControllerModel);\n    _this = _super.call(this);\n    __publicField(_assertThisInitialized(_this), \"envMap\");\n    __publicField(_assertThisInitialized(_this), \"motionController\");\n    _this.motionController = null;\n    _this.envMap = null;\n    return _this;\n  }\n  _createClass(XRControllerModel, [{\n    key: \"setEnvironmentMap\",\n    value: function setEnvironmentMap(envMap) {\n      if (this.envMap == envMap) {\n        return this;\n      }\n      this.envMap = envMap;\n      applyEnvironmentMap(this.envMap, this);\n      return this;\n    }\n    /**\n     * Polls data from the XRInputSource and updates the model's components to match\n     * the real world data\n     */\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      _get(_getPrototypeOf(XRControllerModel.prototype), \"updateMatrixWorld\", this).call(this, force);\n      if (!this.motionController) return;\n      this.motionController.updateFromGamepad();\n      Object.values(this.motionController.components).forEach(function (component) {\n        Object.values(component.visualResponses).forEach(function (visualResponse) {\n          var valueNode = visualResponse.valueNode,\n            minNode = visualResponse.minNode,\n            maxNode = visualResponse.maxNode,\n            value = visualResponse.value,\n            valueNodeProperty = visualResponse.valueNodeProperty;\n          if (!valueNode) return;\n          if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY && typeof value === \"boolean\") {\n            valueNode.visible = value;\n          } else if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNode && maxNode && typeof value === \"number\") {\n            valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);\n            valueNode.position.lerpVectors(minNode.position, maxNode.position, value);\n          }\n        });\n      });\n    }\n  }]);\n  return XRControllerModel;\n}(Object3D);\nfunction findNodes(motionController, scene) {\n  Object.values(motionController.components).forEach(function (component) {\n    var type = component.type,\n      touchPointNodeName = component.touchPointNodeName,\n      visualResponses = component.visualResponses;\n    if (type === MotionControllerConstants.ComponentType.TOUCHPAD && touchPointNodeName) {\n      component.touchPointNode = scene.getObjectByName(touchPointNodeName);\n      if (component.touchPointNode) {\n        var sphereGeometry = new SphereGeometry(1e-3);\n        var material = new MeshBasicMaterial({\n          color: 255\n        });\n        var sphere = new Mesh(sphereGeometry, material);\n        component.touchPointNode.add(sphere);\n      } else {\n        console.warn(\"Could not find touch dot, \".concat(component.touchPointNodeName, \", in touchpad component \").concat(component.id));\n      }\n    }\n    Object.values(visualResponses).forEach(function (visualResponse) {\n      var valueNodeName = visualResponse.valueNodeName,\n        minNodeName = visualResponse.minNodeName,\n        maxNodeName = visualResponse.maxNodeName,\n        valueNodeProperty = visualResponse.valueNodeProperty;\n      if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNodeName && maxNodeName) {\n        visualResponse.minNode = scene.getObjectByName(minNodeName);\n        visualResponse.maxNode = scene.getObjectByName(maxNodeName);\n        if (!visualResponse.minNode) {\n          console.warn(\"Could not find \".concat(minNodeName, \" in the model\"));\n          return;\n        }\n        if (!visualResponse.maxNode) {\n          console.warn(\"Could not find \".concat(maxNodeName, \" in the model\"));\n          return;\n        }\n      }\n      visualResponse.valueNode = scene.getObjectByName(valueNodeName);\n      if (!visualResponse.valueNode) {\n        console.warn(\"Could not find \".concat(valueNodeName, \" in the model\"));\n      }\n    });\n  });\n}\nfunction addAssetSceneToControllerModel(controllerModel, scene) {\n  findNodes(controllerModel.motionController, scene);\n  if (controllerModel.envMap) {\n    applyEnvironmentMap(controllerModel.envMap, scene);\n  }\n  controllerModel.add(scene);\n}\nvar XRControllerModelFactory = /*#__PURE__*/function () {\n  function XRControllerModelFactory() {\n    var gltfLoader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, XRControllerModelFactory);\n    __publicField(this, \"gltfLoader\");\n    __publicField(this, \"path\");\n    __publicField(this, \"_assetCache\");\n    this.gltfLoader = gltfLoader;\n    this.path = DEFAULT_PROFILES_PATH;\n    this._assetCache = {};\n    if (!this.gltfLoader) {\n      this.gltfLoader = new GLTFLoader();\n    }\n  }\n  _createClass(XRControllerModelFactory, [{\n    key: \"createControllerModel\",\n    value: function createControllerModel(controller) {\n      var _this2 = this;\n      var controllerModel = new XRControllerModel();\n      var scene = null;\n      var onConnected = function onConnected(event) {\n        var xrInputSource = event.data;\n        if (xrInputSource.targetRayMode !== \"tracked-pointer\" || !xrInputSource.gamepad) return;\n        fetchProfile(xrInputSource, _this2.path, DEFAULT_PROFILE).then(function (_ref) {\n          var profile = _ref.profile,\n            assetPath = _ref.assetPath;\n          if (!assetPath) {\n            throw new Error(\"no asset path\");\n          }\n          controllerModel.motionController = new MotionController(xrInputSource, profile, assetPath);\n          var assetUrl = controllerModel.motionController.assetUrl;\n          var cachedAsset = _this2._assetCache[assetUrl];\n          if (cachedAsset) {\n            scene = cachedAsset.scene.clone();\n            addAssetSceneToControllerModel(controllerModel, scene);\n          } else {\n            if (!_this2.gltfLoader) {\n              throw new Error(\"GLTFLoader not set.\");\n            }\n            _this2.gltfLoader.setPath(\"\");\n            _this2.gltfLoader.load(controllerModel.motionController.assetUrl, function (asset) {\n              if (!controllerModel.motionController) {\n                console.warn(\"motionController gone while gltf load, bailing...\");\n                return;\n              }\n              _this2._assetCache[assetUrl] = asset;\n              scene = asset.scene.clone();\n              addAssetSceneToControllerModel(controllerModel, scene);\n            }, function () {}, function () {\n              throw new Error(\"Asset \".concat(assetUrl, \" missing or malformed.\"));\n            });\n          }\n        }).catch(function (err) {\n          console.warn(err);\n        });\n      };\n      controller.addEventListener(\"connected\", onConnected);\n      var onDisconnected = function onDisconnected() {\n        controller.removeEventListener(\"connected\", onConnected);\n        controller.removeEventListener(\"disconnected\", onDisconnected);\n        controllerModel.motionController = null;\n        if (scene) {\n          controllerModel.remove(scene);\n        }\n        scene = null;\n      };\n      controller.addEventListener(\"disconnected\", onDisconnected);\n      return controllerModel;\n    }\n  }]);\n  return XRControllerModelFactory;\n}();\nexport { XRControllerModelFactory };\n//# sourceMappingURL=XRControllerModelFactory.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}