{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { sub, mul, div } from './OperatorNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeObject, nodeProxy, float, vec3, vec4 } from '../shadernode/ShaderNode.js';\nclass MathNode extends TempNode {\n  constructor(method, aNode, bNode = null, cNode = null) {\n    super();\n    this.method = method;\n    this.aNode = aNode;\n    this.bNode = bNode;\n    this.cNode = cNode;\n  }\n  getInputType(builder) {\n    const aType = this.aNode.getNodeType(builder);\n    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;\n    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;\n    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);\n    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);\n    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);\n    if (aLen > bLen && aLen > cLen) {\n      return aType;\n    } else if (bLen > cLen) {\n      return bType;\n    } else if (cLen > aLen) {\n      return cType;\n    }\n    return aType;\n  }\n  getNodeType(builder) {\n    const method = this.method;\n    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {\n      return 'float';\n    } else if (method === MathNode.CROSS) {\n      return 'vec3';\n    } else {\n      return this.getInputType(builder);\n    }\n  }\n  generate(builder, output) {\n    const method = this.method;\n    const type = this.getNodeType(builder);\n    const inputType = this.getInputType(builder);\n    const a = this.aNode;\n    const b = this.bNode;\n    const c = this.cNode;\n    const isWebGL = builder.renderer.isWebGLRenderer === true;\n    if (method === MathNode.TRANSFORM_DIRECTION) {\n      // dir can be either a direction vector or a normal vector\n      // upper-left 3x3 of matrix is assumed to be orthogonal\n\n      let tA = a;\n      let tB = b;\n      if (builder.isMatrix(tA.getNodeType(builder))) {\n        tB = vec4(vec3(tB), 0.0);\n      } else {\n        tA = vec4(vec3(tA), 0.0);\n      }\n      const mulNode = mul(tA, tB).xyz;\n      return normalize(mulNode).build(builder, output);\n    } else if (method === MathNode.NEGATE) {\n      return builder.format('( - ' + a.build(builder, inputType) + ' )', type, output);\n    } else if (method === MathNode.ONE_MINUS) {\n      return sub(1.0, a).build(builder, output);\n    } else if (method === MathNode.RECIPROCAL) {\n      return div(1.0, a).build(builder, output);\n    } else if (method === MathNode.DIFFERENCE) {\n      return abs(sub(a, b)).build(builder, output);\n    } else {\n      const params = [];\n      if (method === MathNode.CROSS) {\n        params.push(a.build(builder, type), b.build(builder, type));\n      } else if (method === MathNode.STEP) {\n        params.push(a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? 'float' : inputType), b.build(builder, inputType));\n      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {\n        params.push(a.build(builder, inputType), b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else if (method === MathNode.REFRACT) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, 'float'));\n      } else if (method === MathNode.MIX) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else {\n        params.push(a.build(builder, inputType));\n        if (b !== null) params.push(b.build(builder, inputType));\n        if (c !== null) params.push(c.build(builder, inputType));\n      }\n      return builder.format(`${builder.getMethod(method)}( ${params.join(', ')} )`, type, output);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.method = this.method;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.method = data.method;\n  }\n}\n\n// 1 input\n\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\n\n// 2 inputs\n\nMathNode.ATAN2 = 'atan2';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.MOD = 'mod';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\nexport default MathNode;\nexport const EPSILON = float(1e-6);\nexport const INFINITY = float(1e6);\nexport const radians = nodeProxy(MathNode, MathNode.RADIANS);\nexport const degrees = nodeProxy(MathNode, MathNode.DEGREES);\nexport const exp = nodeProxy(MathNode, MathNode.EXP);\nexport const exp2 = nodeProxy(MathNode, MathNode.EXP2);\nexport const log = nodeProxy(MathNode, MathNode.LOG);\nexport const log2 = nodeProxy(MathNode, MathNode.LOG2);\nexport const sqrt = nodeProxy(MathNode, MathNode.SQRT);\nexport const inverseSqrt = nodeProxy(MathNode, MathNode.INVERSE_SQRT);\nexport const floor = nodeProxy(MathNode, MathNode.FLOOR);\nexport const ceil = nodeProxy(MathNode, MathNode.CEIL);\nexport const normalize = nodeProxy(MathNode, MathNode.NORMALIZE);\nexport const fract = nodeProxy(MathNode, MathNode.FRACT);\nexport const sin = nodeProxy(MathNode, MathNode.SIN);\nexport const cos = nodeProxy(MathNode, MathNode.COS);\nexport const tan = nodeProxy(MathNode, MathNode.TAN);\nexport const asin = nodeProxy(MathNode, MathNode.ASIN);\nexport const acos = nodeProxy(MathNode, MathNode.ACOS);\nexport const atan = nodeProxy(MathNode, MathNode.ATAN);\nexport const abs = nodeProxy(MathNode, MathNode.ABS);\nexport const sign = nodeProxy(MathNode, MathNode.SIGN);\nexport const length = nodeProxy(MathNode, MathNode.LENGTH);\nexport const negate = nodeProxy(MathNode, MathNode.NEGATE);\nexport const oneMinus = nodeProxy(MathNode, MathNode.ONE_MINUS);\nexport const dFdx = nodeProxy(MathNode, MathNode.DFDX);\nexport const dFdy = nodeProxy(MathNode, MathNode.DFDY);\nexport const round = nodeProxy(MathNode, MathNode.ROUND);\nexport const reciprocal = nodeProxy(MathNode, MathNode.RECIPROCAL);\nexport const trunc = nodeProxy(MathNode, MathNode.TRUNC);\nexport const fwidth = nodeProxy(MathNode, MathNode.FWIDTH);\nexport const atan2 = nodeProxy(MathNode, MathNode.ATAN2);\nexport const min = nodeProxy(MathNode, MathNode.MIN);\nexport const max = nodeProxy(MathNode, MathNode.MAX);\nexport const mod = nodeProxy(MathNode, MathNode.MOD);\nexport const step = nodeProxy(MathNode, MathNode.STEP);\nexport const reflect = nodeProxy(MathNode, MathNode.REFLECT);\nexport const distance = nodeProxy(MathNode, MathNode.DISTANCE);\nexport const difference = nodeProxy(MathNode, MathNode.DIFFERENCE);\nexport const dot = nodeProxy(MathNode, MathNode.DOT);\nexport const cross = nodeProxy(MathNode, MathNode.CROSS);\nexport const pow = nodeProxy(MathNode, MathNode.POW);\nexport const pow2 = nodeProxy(MathNode, MathNode.POW, 2);\nexport const pow3 = nodeProxy(MathNode, MathNode.POW, 3);\nexport const pow4 = nodeProxy(MathNode, MathNode.POW, 4);\nexport const transformDirection = nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);\nexport const mix = nodeProxy(MathNode, MathNode.MIX);\nexport const clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));\nexport const saturate = value => clamp(value);\nexport const refract = nodeProxy(MathNode, MathNode.REFRACT);\nexport const smoothstep = nodeProxy(MathNode, MathNode.SMOOTHSTEP);\nexport const faceForward = nodeProxy(MathNode, MathNode.FACEFORWARD);\nexport const mixElement = (t, e1, e2) => mix(e1, e2, t);\nexport const smoothstepElement = (x, low, high) => smoothstep(low, high, x);\naddNodeElement('radians', radians);\naddNodeElement('degrees', degrees);\naddNodeElement('exp', exp);\naddNodeElement('exp2', exp2);\naddNodeElement('log', log);\naddNodeElement('log2', log2);\naddNodeElement('sqrt', sqrt);\naddNodeElement('inverseSqrt', inverseSqrt);\naddNodeElement('floor', floor);\naddNodeElement('ceil', ceil);\naddNodeElement('normalize', normalize);\naddNodeElement('fract', fract);\naddNodeElement('sin', sin);\naddNodeElement('cos', cos);\naddNodeElement('tan', tan);\naddNodeElement('asin', asin);\naddNodeElement('acos', acos);\naddNodeElement('atan', atan);\naddNodeElement('abs', abs);\naddNodeElement('sign', sign);\naddNodeElement('length', length);\naddNodeElement('negate', negate);\naddNodeElement('oneMinus', oneMinus);\naddNodeElement('dFdx', dFdx);\naddNodeElement('dFdy', dFdy);\naddNodeElement('round', round);\naddNodeElement('reciprocal', reciprocal);\naddNodeElement('trunc', trunc);\naddNodeElement('fwidth', fwidth);\naddNodeElement('atan2', atan2);\naddNodeElement('min', min);\naddNodeElement('max', max);\naddNodeElement('mod', mod);\naddNodeElement('step', step);\naddNodeElement('reflect', reflect);\naddNodeElement('distance', distance);\naddNodeElement('dot', dot);\naddNodeElement('cross', cross);\naddNodeElement('pow', pow);\naddNodeElement('pow2', pow2);\naddNodeElement('pow3', pow3);\naddNodeElement('pow4', pow4);\naddNodeElement('transformDirection', transformDirection);\naddNodeElement('mix', mixElement);\naddNodeElement('clamp', clamp);\naddNodeElement('refract', refract);\naddNodeElement('smoothstep', smoothstepElement);\naddNodeElement('faceForward', faceForward);\naddNodeElement('difference', difference);\naddNodeElement('saturate', saturate);\naddNodeClass('MathNode', MathNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}