{"ast":null,"code":"import TempNode from '../core/TempNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeProxy } from '../shadernode/ShaderNode.js';\nclass OperatorNode extends TempNode {\n  constructor(op, aNode, bNode, ...params) {\n    super();\n    this.op = op;\n    if (params.length > 0) {\n      let finalBNode = bNode;\n      for (let i = 0; i < params.length; i++) {\n        finalBNode = new OperatorNode(op, finalBNode, params[i]);\n      }\n      bNode = finalBNode;\n    }\n    this.aNode = aNode;\n    this.bNode = bNode;\n  }\n  hasDependencies(builder) {\n    return this.op !== '=' ? super.hasDependencies(builder) : false;\n  }\n  getNodeType(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const typeA = aNode.getNodeType(builder);\n    const typeB = bNode.getNodeType(builder);\n    if (typeA === 'void' || typeB === 'void') {\n      return 'void';\n    } else if (op === '=' || op === '%') {\n      return typeA;\n    } else if (op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {\n      return builder.getIntegerType(typeA);\n    } else if (op === '==' || op === '&&' || op === '||' || op === '^^') {\n      return 'bool';\n    } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n      const typeLength = output ? builder.getTypeLength(output) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));\n      return typeLength > 1 ? `bvec${typeLength}` : 'bool';\n    } else {\n      if (typeA === 'float' && builder.isMatrix(typeB)) {\n        return typeB;\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n\n        return builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n\n        return builder.getVectorFromMatrix(typeB);\n      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\n        // anytype x anytype: use the greater length vector\n\n        return typeB;\n      }\n      return typeA;\n    }\n  }\n  generate(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const type = this.getNodeType(builder, output);\n    let typeA = null;\n    let typeB = null;\n    if (type !== 'void') {\n      typeA = aNode.getNodeType(builder);\n      typeB = bNode.getNodeType(builder);\n      if (op === '=') {\n        typeB = typeA;\n      } else if (op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==') {\n        if (builder.isVector(typeA)) {\n          typeB = typeA;\n        } else {\n          typeA = typeB = 'float';\n        }\n      } else if (op === '>>' || op === '<<') {\n        typeA = type;\n        typeB = builder.changeComponentType(typeB, 'uint');\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n\n        typeB = builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n\n        typeA = builder.getVectorFromMatrix(typeB);\n      } else {\n        // anytype x anytype\n\n        typeA = typeB = type;\n      }\n    } else {\n      typeA = typeB = type;\n    }\n    const a = aNode.build(builder, typeA);\n    const b = bNode.build(builder, typeB);\n    const outputLength = builder.getTypeLength(output);\n    if (output !== 'void') {\n      if (op === '=') {\n        builder.addLineFlowCode(`${a} ${this.op} ${b}`);\n        return a;\n      } else if (op === '<' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('lessThan')}( ${a}, ${b} )`, type, output);\n      } else if (op === '<=' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('lessThanEqual')}( ${a}, ${b} )`, type, output);\n      } else if (op === '>' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('greaterThan')}( ${a}, ${b} )`, type, output);\n      } else if (op === '>=' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('greaterThanEqual')}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);\n      }\n    } else if (typeA !== 'void') {\n      return builder.format(`${a} ${this.op} ${b}`, type, output);\n    }\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.op = this.op;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.op = data.op;\n  }\n}\nexport default OperatorNode;\nexport const add = nodeProxy(OperatorNode, '+');\nexport const sub = nodeProxy(OperatorNode, '-');\nexport const mul = nodeProxy(OperatorNode, '*');\nexport const div = nodeProxy(OperatorNode, '/');\nexport const remainder = nodeProxy(OperatorNode, '%');\nexport const equal = nodeProxy(OperatorNode, '==');\nexport const assign = nodeProxy(OperatorNode, '=');\nexport const lessThan = nodeProxy(OperatorNode, '<');\nexport const greaterThan = nodeProxy(OperatorNode, '>');\nexport const lessThanEqual = nodeProxy(OperatorNode, '<=');\nexport const greaterThanEqual = nodeProxy(OperatorNode, '>=');\nexport const and = nodeProxy(OperatorNode, '&&');\nexport const or = nodeProxy(OperatorNode, '||');\nexport const xor = nodeProxy(OperatorNode, '^^');\nexport const bitAnd = nodeProxy(OperatorNode, '&');\nexport const bitOr = nodeProxy(OperatorNode, '|');\nexport const bitXor = nodeProxy(OperatorNode, '^');\nexport const shiftLeft = nodeProxy(OperatorNode, '<<');\nexport const shiftRight = nodeProxy(OperatorNode, '>>');\naddNodeElement('add', add);\naddNodeElement('sub', sub);\naddNodeElement('mul', mul);\naddNodeElement('div', div);\naddNodeElement('remainder', remainder);\naddNodeElement('equal', equal);\naddNodeElement('assign', assign);\naddNodeElement('lessThan', lessThan);\naddNodeElement('greaterThan', greaterThan);\naddNodeElement('lessThanEqual', lessThanEqual);\naddNodeElement('greaterThanEqual', greaterThanEqual);\naddNodeElement('and', and);\naddNodeElement('or', or);\naddNodeElement('xor', xor);\naddNodeElement('bitAnd', bitAnd);\naddNodeElement('bitOr', bitOr);\naddNodeElement('bitXor', bitXor);\naddNodeElement('shiftLeft', shiftLeft);\naddNodeElement('shiftRight', shiftRight);\naddNodeClass('OperatorNode', OperatorNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}