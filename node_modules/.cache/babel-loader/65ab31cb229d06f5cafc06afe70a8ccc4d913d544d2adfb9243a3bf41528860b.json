{"ast":null,"code":"import _slicedToArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"color\", \"opacity\", \"transparent\", \"screenspace\", \"toneMapped\", \"polygonOffset\", \"polygonOffsetFactor\", \"renderOrder\", \"thickness\", \"angle\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { useThree, extend, applyProps } from '@react-three/fiber';\nimport { toCreasedNormals } from 'three-stdlib';\nimport { version } from '../helpers/constants.js';\nvar OutlinesMaterial = /* @__PURE__ */shaderMaterial({\n  screenspace: false,\n  color: /* @__PURE__ */new THREE.Color('black'),\n  opacity: 1,\n  thickness: 0.05,\n  size: /* @__PURE__ */new THREE.Vector2()\n}, \"#include <common>\\n   #include <morphtarget_pars_vertex>\\n   #include <skinning_pars_vertex>\\n   uniform float thickness;\\n   uniform float screenspace;\\n   uniform vec2 size;\\n   void main() {\\n     #if defined (USE_SKINNING)\\n\\t     #include <beginnormal_vertex>\\n       #include <morphnormal_vertex>\\n       #include <skinbase_vertex>\\n       #include <skinnormal_vertex>\\n       #include <defaultnormal_vertex>\\n     #endif\\n     #include <begin_vertex>\\n\\t   #include <morphtarget_vertex>\\n\\t   #include <skinning_vertex>\\n     #include <project_vertex>\\n     vec4 tNormal = vec4(normal, 0.0);\\n     vec4 tPosition = vec4(transformed, 1.0);\\n     #ifdef USE_INSTANCING\\n       tNormal = instanceMatrix * tNormal;\\n       tPosition = instanceMatrix * tPosition;\\n     #endif\\n     if (screenspace == 0.0) {\\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \\n     } else {\\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\\n       clipPosition.xy += offset;\\n       gl_Position = clipPosition;\\n     }\\n   }\", \"uniform vec3 color;\\n   uniform float opacity;\\n   void main(){\\n     gl_FragColor = vec4(color, opacity);\\n     #include <tonemapping_fragment>\\n     #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n   }\"));\nfunction Outlines(_ref) {\n  var _ref$color = _ref.color,\n    color = _ref$color === void 0 ? 'black' : _ref$color,\n    _ref$opacity = _ref.opacity,\n    opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,\n    _ref$transparent = _ref.transparent,\n    transparent = _ref$transparent === void 0 ? false : _ref$transparent,\n    _ref$screenspace = _ref.screenspace,\n    screenspace = _ref$screenspace === void 0 ? false : _ref$screenspace,\n    _ref$toneMapped = _ref.toneMapped,\n    toneMapped = _ref$toneMapped === void 0 ? true : _ref$toneMapped,\n    _ref$polygonOffset = _ref.polygonOffset,\n    polygonOffset = _ref$polygonOffset === void 0 ? false : _ref$polygonOffset,\n    _ref$polygonOffsetFac = _ref.polygonOffsetFactor,\n    polygonOffsetFactor = _ref$polygonOffsetFac === void 0 ? 0 : _ref$polygonOffsetFac,\n    _ref$renderOrder = _ref.renderOrder,\n    renderOrder = _ref$renderOrder === void 0 ? 0 : _ref$renderOrder,\n    _ref$thickness = _ref.thickness,\n    thickness = _ref$thickness === void 0 ? 0.05 : _ref$thickness,\n    _ref$angle = _ref.angle,\n    angle = _ref$angle === void 0 ? Math.PI : _ref$angle,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var _ref$current;\n  var ref = React.useRef(null);\n  var _React$useState = React.useState(function () {\n      return new OutlinesMaterial({\n        side: THREE.BackSide\n      });\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    material = _React$useState2[0];\n  var _useThree = useThree(),\n    gl = _useThree.gl;\n  var contextSize = gl.getDrawingBufferSize(new THREE.Vector2());\n  React.useMemo(function () {\n    return extend({\n      OutlinesMaterial: OutlinesMaterial\n    });\n  }, []);\n  React.useLayoutEffect(function () {\n    var group = ref.current;\n    var parent = group.parent;\n    if (parent && parent.geometry) {\n      var mesh;\n      if (parent.skeleton) {\n        mesh = new THREE.SkinnedMesh();\n        mesh.material = material;\n        mesh.bind(parent.skeleton, parent.bindMatrix);\n        group.add(mesh);\n      } else if (parent.isInstancedMesh) {\n        mesh = new THREE.InstancedMesh(parent.geometry, material, parent.count);\n        mesh.instanceMatrix = parent.instanceMatrix;\n        group.add(mesh);\n      } else {\n        mesh = new THREE.Mesh();\n        mesh.material = material;\n        group.add(mesh);\n      }\n      mesh.geometry = angle ? toCreasedNormals(parent.geometry, angle) : parent.geometry;\n      return function () {\n        if (angle) mesh.geometry.dispose();\n        group.remove(mesh);\n      };\n    }\n  }, [angle, (_ref$current = ref.current) == null || (_ref$current = _ref$current.parent) == null ? void 0 : _ref$current.geometry]);\n  React.useLayoutEffect(function () {\n    var group = ref.current;\n    var mesh = group.children[0];\n    if (mesh) {\n      mesh.renderOrder = renderOrder;\n      applyProps(mesh.material, {\n        transparent: transparent,\n        thickness: thickness,\n        color: color,\n        opacity: opacity,\n        size: contextSize,\n        screenspace: screenspace,\n        toneMapped: toneMapped,\n        polygonOffset: polygonOffset,\n        polygonOffsetFactor: polygonOffsetFactor\n      });\n    }\n  }, [angle, transparent, thickness, color, opacity, screenspace, toneMapped, polygonOffset, polygonOffsetFactor, contextSize, renderOrder]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props));\n}\nexport { Outlines };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}