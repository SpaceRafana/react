{"ast":null,"code":"import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { /*vec2,*/vec3 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\nimport { normalWorld } from '../accessors/NormalNode.js';\n//import { add } from '../math/OperatorNode.js';\n\nimport { Color, DepthTexture, NearestFilter, LessCompare } from 'three';\nlet depthMaterial = null;\nclass AnalyticLightNode extends LightingNode {\n  constructor(light = null) {\n    super();\n    this.updateType = NodeUpdateType.FRAME;\n    this.light = light;\n    this.rtt = null;\n    this.shadowNode = null;\n    this.color = new Color();\n    this.colorNode = uniform(this.color);\n  }\n  getHash( /*builder*/\n  ) {\n    return this.light.uuid;\n  }\n  setupShadow(builder) {\n    let shadowNode = this.shadowNode;\n    if (shadowNode === null) {\n      if (depthMaterial === null) depthMaterial = builder.createNodeMaterial('MeshBasicNodeMaterial');\n      const shadow = this.light.shadow;\n      const rtt = builder.getRenderTarget(shadow.mapSize.width, shadow.mapSize.height);\n      const depthTexture = new DepthTexture();\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n      depthTexture.image.width = shadow.mapSize.width;\n      depthTexture.image.height = shadow.mapSize.height;\n      depthTexture.compareFunction = LessCompare;\n      rtt.depthTexture = depthTexture;\n      shadow.camera.updateProjectionMatrix();\n\n      //\n\n      const bias = reference('bias', 'float', shadow);\n      const normalBias = reference('normalBias', 'float', shadow);\n      let shadowCoord = uniform(shadow.matrix).mul(positionWorld.add(normalWorld.mul(normalBias)));\n      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n      const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));\n      shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(),\n      // WebGPU: Flip Y\n      shadowCoord.z.add(bias).mul(2).sub(1) // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]\n      );\n\n      const textureCompare = (depthTexture, shadowCoord, compare) => texture(depthTexture, shadowCoord).compare(compare);\n      //const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );\n\n      // BasicShadowMap\n\n      shadowNode = textureCompare(depthTexture, shadowCoord.xy, shadowCoord.z);\n\n      // PCFShadowMap\n      /*\n      const mapSize = reference( 'mapSize', 'vec2', shadow );\n      const radius = reference( 'radius', 'float', shadow );\n      \tconst texelSize = vec2( 1 ).div( mapSize );\n      const dx0 = texelSize.x.negate().mul( radius );\n      const dy0 = texelSize.y.negate().mul( radius );\n      const dx1 = texelSize.x.mul( radius );\n      const dy1 = texelSize.y.mul( radius );\n      const dx2 = dx0.mul( 2 );\n      const dy2 = dy0.mul( 2 );\n      const dx3 = dx1.mul( 2 );\n      const dy3 = dy1.mul( 2 );\n      \tshadowNode = add(\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n      \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n      ).mul( 1 / 17 );\n      */\n      //\n\n      this.rtt = rtt;\n      this.colorNode = this.colorNode.mul(frustumTest.mix(1, shadowNode));\n      this.shadowNode = shadowNode;\n\n      //\n\n      this.updateBeforeType = NodeUpdateType.RENDER;\n    }\n  }\n  setup(builder) {\n    if (this.light.castShadow) this.setupShadow(builder);\n  }\n  updateShadow(frame) {\n    const {\n      rtt,\n      light\n    } = this;\n    const {\n      renderer,\n      scene\n    } = frame;\n    scene.overrideMaterial = depthMaterial;\n    rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);\n    light.shadow.updateMatrices(light);\n    renderer.setRenderTarget(rtt);\n    renderer.render(scene, light.shadow.camera);\n    renderer.setRenderTarget(null);\n    scene.overrideMaterial = null;\n  }\n  updateBefore(frame) {\n    const {\n      light\n    } = this;\n    if (light.castShadow) this.updateShadow(frame);\n  }\n  update( /*frame*/\n  ) {\n    const {\n      light\n    } = this;\n    this.color.copy(light.color).multiplyScalar(light.intensity);\n  }\n}\nexport default AnalyticLightNode;\naddNodeClass('AnalyticLightNode', AnalyticLightNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}