{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { Vector2, WebGLRenderTarget, UniformsUtils, ShaderMaterial, AdditiveBlending } from \"three\";\nimport { ConvolutionShader } from \"../shaders/ConvolutionShader.js\";\nvar BloomPass = /*#__PURE__*/function (_Pass) {\n  _inherits(BloomPass, _Pass);\n  var _super = _createSuper(BloomPass);\n  function BloomPass() {\n    var _this;\n    var strength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var kernelSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;\n    var sigma = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n    var resolution = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 256;\n    _classCallCheck(this, BloomPass);\n    _this = _super.call(this);\n    __publicField(_assertThisInitialized(_this), \"renderTargetX\");\n    __publicField(_assertThisInitialized(_this), \"renderTargetY\");\n    __publicField(_assertThisInitialized(_this), \"materialCombine\");\n    __publicField(_assertThisInitialized(_this), \"materialConvolution\");\n    __publicField(_assertThisInitialized(_this), \"fsQuad\");\n    __publicField(_assertThisInitialized(_this), \"combineUniforms\");\n    __publicField(_assertThisInitialized(_this), \"convolutionUniforms\");\n    __publicField(_assertThisInitialized(_this), \"blurX\", new Vector2(1953125e-9, 0));\n    __publicField(_assertThisInitialized(_this), \"blurY\", new Vector2(0, 1953125e-9));\n    _this.renderTargetX = new WebGLRenderTarget(resolution, resolution);\n    _this.renderTargetX.texture.name = \"BloomPass.x\";\n    _this.renderTargetY = new WebGLRenderTarget(resolution, resolution);\n    _this.renderTargetY.texture.name = \"BloomPass.y\";\n    _this.combineUniforms = UniformsUtils.clone(CombineShader.uniforms);\n    _this.combineUniforms[\"strength\"].value = strength;\n    _this.materialCombine = new ShaderMaterial({\n      uniforms: _this.combineUniforms,\n      vertexShader: CombineShader.vertexShader,\n      fragmentShader: CombineShader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true\n    });\n    if (ConvolutionShader === void 0) console.error(\"BloomPass relies on ConvolutionShader\");\n    var convolutionShader = ConvolutionShader;\n    _this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);\n    _this.convolutionUniforms[\"uImageIncrement\"].value = _this.blurX;\n    _this.convolutionUniforms[\"cKernel\"].value = ConvolutionShader.buildKernel(sigma);\n    _this.materialConvolution = new ShaderMaterial({\n      uniforms: _this.convolutionUniforms,\n      vertexShader: convolutionShader.vertexShader,\n      fragmentShader: convolutionShader.fragmentShader,\n      defines: {\n        KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),\n        KERNEL_SIZE_INT: kernelSize.toFixed(0)\n      }\n    });\n    _this.needsSwap = false;\n    _this.fsQuad = new FullScreenQuad(_this.materialConvolution);\n    return _this;\n  }\n  _createClass(BloomPass, [{\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      this.fsQuad.material = this.materialConvolution;\n      this.convolutionUniforms[\"tDiffuse\"].value = readBuffer.texture;\n      this.convolutionUniforms[\"uImageIncrement\"].value = this.blurX;\n      renderer.setRenderTarget(this.renderTargetX);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.convolutionUniforms[\"tDiffuse\"].value = this.renderTargetX.texture;\n      this.convolutionUniforms[\"uImageIncrement\"].value = this.blurY;\n      renderer.setRenderTarget(this.renderTargetY);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialCombine;\n      this.combineUniforms[\"tDiffuse\"].value = this.renderTargetY.texture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  }]);\n  return BloomPass;\n}(Pass);\nvar CombineShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    strength: {\n      value: 1\n    }\n  },\n  vertexShader: /* glsl */\"\\n  varying vec2 vUv;\\n  void main() {\\n    vUv = uv;\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n  }\",\n  fragmentShader: /* glsl */\"\\n  uniform float strength;\\n  uniform sampler2D tDiffuse;\\n  varying vec2 vUv;\\n  void main() {\\n    vec4 texel = texture2D( tDiffuse, vUv );\\n    gl_FragColor = strength * texel;\\n  }\"\n};\nexport { BloomPass };\n//# sourceMappingURL=BloomPass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}