{"ast":null,"code":"import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nvar _bufferStack1 = new BufferStack.constructor();\nvar _bufferStack2 = new BufferStack.constructor();\nvar _boxPool = new PrimitivePool(function () {\n  return new Box3();\n});\nvar _leftBox1 = new Box3();\nvar _rightBox1 = new Box3();\nvar _leftBox2 = new Box3();\nvar _rightBox2 = new Box3();\nvar _active = false;\nexport function bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {\n  if (_active) {\n    throw new Error('MeshBVH: Recursive calls to bvhcast not supported.');\n  }\n  _active = true;\n  var roots = bvh._roots;\n  var otherRoots = otherBvh._roots;\n  var result;\n  var offset1 = 0;\n  var offset2 = 0;\n  var invMat = new Matrix4().copy(matrixToLocal).invert();\n\n  // iterate over the first set of roots\n  for (var i = 0, il = roots.length; i < il; i++) {\n    _bufferStack1.setBuffer(roots[i]);\n    offset2 = 0;\n\n    // prep the initial root box\n    var localBox = _boxPool.getPrimitive();\n    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);\n    localBox.applyMatrix4(invMat);\n\n    // iterate over the second set of roots\n    for (var j = 0, jl = otherRoots.length; j < jl; j++) {\n      _bufferStack2.setBuffer(otherRoots[i]);\n      result = _traverse(0, 0, matrixToLocal, invMat, intersectsRanges, offset1, offset2, 0, 0, localBox);\n      _bufferStack2.clearBuffer();\n      offset2 += otherRoots[j].length;\n      if (result) {\n        break;\n      }\n    }\n\n    // release stack info\n    _boxPool.releasePrimitive(localBox);\n    _bufferStack1.clearBuffer();\n    offset1 += roots[i].length;\n    if (result) {\n      break;\n    }\n  }\n  _active = false;\n  return result;\n}\nfunction _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc) {\n  var node1IndexByteOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var node2IndexByteOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var depth1 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  var depth2 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n  var currBox = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var reversed = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;\n  // get the buffer stacks associated with the current indices\n  var bufferStack1, bufferStack2;\n  if (reversed) {\n    bufferStack1 = _bufferStack2;\n    bufferStack2 = _bufferStack1;\n  } else {\n    bufferStack1 = _bufferStack1;\n    bufferStack2 = _bufferStack2;\n  }\n\n  // get the local instances of the typed buffers\n  var float32Array1 = bufferStack1.float32Array,\n    uint32Array1 = bufferStack1.uint32Array,\n    uint16Array1 = bufferStack1.uint16Array,\n    float32Array2 = bufferStack2.float32Array,\n    uint32Array2 = bufferStack2.uint32Array,\n    uint16Array2 = bufferStack2.uint16Array;\n  var node1Index16 = node1Index32 * 2;\n  var node2Index16 = node2Index32 * 2;\n  var isLeaf1 = IS_LEAF(node1Index16, uint16Array1);\n  var isLeaf2 = IS_LEAF(node2Index16, uint16Array2);\n  var result = false;\n  if (isLeaf2 && isLeaf1) {\n    // if both bounds are leaf nodes then fire the callback if the boxes intersect\n    if (reversed) {\n      result = intersectsRangesFunc(OFFSET(node2Index32, uint32Array2), COUNT(node2Index32 * 2, uint16Array2), OFFSET(node1Index32, uint32Array1), COUNT(node1Index32 * 2, uint16Array1), depth2, node2IndexByteOffset + node2Index32, depth1, node1IndexByteOffset + node1Index32);\n    } else {\n      result = intersectsRangesFunc(OFFSET(node1Index32, uint32Array1), COUNT(node1Index32 * 2, uint16Array1), OFFSET(node2Index32, uint32Array2), COUNT(node2Index32 * 2, uint16Array2), depth1, node1IndexByteOffset + node1Index32, depth2, node2IndexByteOffset + node2Index32);\n    }\n  } else if (isLeaf2) {\n    // SWAP\n    // If we've traversed to the leaf node on the other bvh then we need to swap over\n    // to traverse down the first one\n\n    // get the new box to use\n    var newBox = _boxPool.getPrimitive();\n    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);\n    newBox.applyMatrix4(matrix2to1);\n\n    // get the child bounds to check before traversal\n    var cl1 = LEFT_NODE(node1Index32);\n    var cr1 = RIGHT_NODE(node1Index32, uint32Array1);\n    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);\n    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);\n\n    // precompute the intersections otherwise the global boxes will be modified during traversal\n    var intersectCl1 = newBox.intersectsBox(_leftBox1);\n    var intersectCr1 = newBox.intersectsBox(_rightBox1);\n    result = intersectCl1 && _traverse(node2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(node2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n    _boxPool.releasePrimitive(newBox);\n  } else {\n    // if neither are leaves then we should swap if one of the children does not\n    // intersect with the current bounds\n\n    // get the child bounds to check\n    var cl2 = LEFT_NODE(node2Index32);\n    var cr2 = RIGHT_NODE(node2Index32, uint32Array2);\n    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);\n    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);\n    var leftIntersects = currBox.intersectsBox(_leftBox2);\n    var rightIntersects = currBox.intersectsBox(_rightBox2);\n    if (leftIntersects && rightIntersects) {\n      // continue to traverse both children if they both intersect\n      result = _traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed) || _traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n    } else if (leftIntersects) {\n      if (isLeaf1) {\n        // if the current box is a leaf then just continue\n        result = _traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n      } else {\n        // SWAP\n        // if only one box intersects then we have to swap to the other bvh to continue\n        var _newBox = _boxPool.getPrimitive();\n        _newBox.copy(_leftBox2).applyMatrix4(matrix2to1);\n        var _cl = LEFT_NODE(node1Index32);\n        var _cr = RIGHT_NODE(node1Index32, uint32Array1);\n        arrayToBox(BOUNDING_DATA_INDEX(_cl), float32Array1, _leftBox1);\n        arrayToBox(BOUNDING_DATA_INDEX(_cr), float32Array1, _rightBox1);\n\n        // precompute the intersections otherwise the global boxes will be modified during traversal\n        var _intersectCl = _newBox.intersectsBox(_leftBox1);\n        var _intersectCr = _newBox.intersectsBox(_rightBox1);\n        result = _intersectCl && _traverse(cl2, _cl, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, _newBox, !reversed) || _intersectCr && _traverse(cl2, _cr, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, _newBox, !reversed);\n        _boxPool.releasePrimitive(_newBox);\n      }\n    } else if (rightIntersects) {\n      if (isLeaf1) {\n        // if the current box is a leaf then just continue\n        result = _traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n      } else {\n        // SWAP\n        // if only one box intersects then we have to swap to the other bvh to continue\n        var _newBox2 = _boxPool.getPrimitive();\n        _newBox2.copy(_rightBox2).applyMatrix4(matrix2to1);\n        var _cl2 = LEFT_NODE(node1Index32);\n        var _cr2 = RIGHT_NODE(node1Index32, uint32Array1);\n        arrayToBox(BOUNDING_DATA_INDEX(_cl2), float32Array1, _leftBox1);\n        arrayToBox(BOUNDING_DATA_INDEX(_cr2), float32Array1, _rightBox1);\n\n        // precompute the intersections otherwise the global boxes will be modified during traversal\n        var _intersectCl2 = _newBox2.intersectsBox(_leftBox1);\n        var _intersectCr2 = _newBox2.intersectsBox(_rightBox1);\n        result = _intersectCl2 && _traverse(cr2, _cl2, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, _newBox2, !reversed) || _intersectCr2 && _traverse(cr2, _cr2, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, _newBox2, !reversed);\n        _boxPool.releasePrimitive(_newBox2);\n      }\n    }\n  }\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}