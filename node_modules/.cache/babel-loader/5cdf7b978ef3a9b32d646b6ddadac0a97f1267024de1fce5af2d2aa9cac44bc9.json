{"ast":null,"code":"import LightingNode from './LightingNode.js';\nimport { cache } from '../core/CacheNode.js';\nimport { context } from '../core/ContextNode.js';\nimport { roughness, clearcoatRoughness } from '../core/PropertyNode.js';\nimport { equirectUV } from '../utils/EquirectUVNode.js';\nimport { specularMIPLevel } from '../utils/SpecularMIPLevelNode.js';\nimport { cameraViewMatrix } from '../accessors/CameraNode.js';\nimport { transformedClearcoatNormalView, transformedNormalView, transformedNormalWorld } from '../accessors/NormalNode.js';\nimport { positionViewDirection } from '../accessors/PositionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { float, vec2 } from '../shadernode/ShaderNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nconst envNodeCache = new WeakMap();\nclass EnvironmentNode extends LightingNode {\n  constructor(envNode = null) {\n    super();\n    this.envNode = envNode;\n  }\n  setup(builder) {\n    let envNode = this.envNode;\n    const properties = builder.getNodeProperties(this);\n    if (envNode.isTextureNode && envNode.value.isCubeTexture !== true) {\n      let cacheEnvNode = envNodeCache.get(envNode.value);\n      if (cacheEnvNode === undefined) {\n        const texture = envNode.value;\n        const renderer = builder.renderer;\n\n        // @TODO: Add dispose logic here\n        const cubeRTT = builder.getCubeRenderTarget(512).fromEquirectangularTexture(renderer, texture);\n        cacheEnvNode = cubeTexture(cubeRTT.texture);\n        envNodeCache.set(envNode.value, cacheEnvNode);\n      }\n      envNode = cacheEnvNode;\n    }\n\n    //\n\n    const intensity = reference('envMapIntensity', 'float', builder.material); // @TODO: Add materialEnvIntensity in MaterialNode\n\n    const radiance = context(envNode, createRadianceContext(roughness, transformedNormalView)).mul(intensity);\n    const irradiance = context(envNode, createIrradianceContext(transformedNormalWorld)).mul(Math.PI).mul(intensity);\n    const isolateRadiance = cache(radiance);\n\n    //\n\n    builder.context.radiance.addAssign(isolateRadiance);\n    builder.context.iblIrradiance.addAssign(irradiance);\n\n    //\n\n    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n    if (clearcoatRadiance) {\n      const clearcoatRadianceContext = context(envNode, createRadianceContext(clearcoatRoughness, transformedClearcoatNormalView)).mul(intensity);\n      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);\n      clearcoatRadiance.addAssign(isolateClearcoatRadiance);\n    }\n\n    //\n\n    properties.radiance = isolateRadiance;\n    properties.irradiance = irradiance;\n  }\n}\nconst createRadianceContext = (roughnessNode, normalViewNode) => {\n  let reflectVec = null;\n  let textureUVNode = null;\n  return {\n    getUVNode: textureNode => {\n      let node = null;\n      if (reflectVec === null) {\n        reflectVec = positionViewDirection.negate().reflect(normalViewNode);\n        reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();\n        reflectVec = reflectVec.transformDirection(cameraViewMatrix);\n      }\n      if (textureNode.isCubeTextureNode) {\n        node = reflectVec;\n      } else if (textureNode.isTextureNode) {\n        if (textureUVNode === null) {\n          // @TODO: Needed PMREM\n\n          textureUVNode = equirectUV(reflectVec);\n        }\n        node = textureUVNode;\n      }\n      return node;\n    },\n    getSamplerLevelNode: () => {\n      return roughnessNode;\n    },\n    getMIPLevelAlgorithmNode: (textureNode, levelNode) => {\n      return specularMIPLevel(textureNode, levelNode);\n    }\n  };\n};\nconst createIrradianceContext = normalWorldNode => {\n  let textureUVNode = null;\n  return {\n    getUVNode: textureNode => {\n      let node = null;\n      if (textureNode.isCubeTextureNode) {\n        node = normalWorldNode;\n      } else if (textureNode.isTextureNode) {\n        if (textureUVNode === null) {\n          // @TODO: Needed PMREM\n\n          textureUVNode = equirectUV(normalWorldNode);\n          textureUVNode = vec2(textureUVNode.x, textureUVNode.y.oneMinus());\n        }\n        node = textureUVNode;\n      }\n      return node;\n    },\n    getSamplerLevelNode: () => {\n      return float(1);\n    },\n    getMIPLevelAlgorithmNode: (textureNode, levelNode) => {\n      return specularMIPLevel(textureNode, levelNode);\n    }\n  };\n};\nexport default EnvironmentNode;\naddNodeClass('EnvironmentNode', EnvironmentNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}