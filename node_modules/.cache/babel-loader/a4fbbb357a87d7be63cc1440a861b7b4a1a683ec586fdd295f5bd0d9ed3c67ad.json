{"ast":null,"code":"import _createForOfIteratorHelper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps } from './geometryUtils.js';\nimport { getBounds, getCentroidBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nfunction generateIndirectBuffer(geometry, useSharedArrayBuffer) {\n  var triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n  var useUint32 = triCount > Math.pow(2, 16);\n  var byteCount = useUint32 ? 4 : 2;\n  var buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n  var indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n  for (var i = 0, l = indirectBuffer.length; i < l; i++) {\n    indirectBuffer[i] = i;\n  }\n  return indirectBuffer;\n}\nfunction buildTree(bvh, options) {\n  // Compute the full bounds of the geometry at the same time as triangle bounds because\n  // we'll need it for the root bounds in the case with no groups and it should be fast here.\n  // We can't use the geometry bounding box if it's available because it may be out of date.\n  var geometry = bvh.geometry;\n  var indexArray = geometry.index ? geometry.index.array : null;\n  var maxDepth = options.maxDepth;\n  var verbose = options.verbose;\n  var maxLeafTris = options.maxLeafTris;\n  var strategy = options.strategy;\n  var onProgress = options.onProgress;\n  var totalTriangles = getTriCount(geometry);\n  var indirectBuffer = bvh._indirectBuffer;\n  var reachedMaxDepth = false;\n  var fullBounds = new Float32Array(6);\n  var cacheCentroidBoundingData = new Float32Array(6);\n  var triangleBounds = computeTriangleBounds(geometry, fullBounds);\n  var partionFunc = options.indirect ? partition_indirect : partition;\n  var roots = [];\n  var ranges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);\n  if (ranges.length === 1) {\n    var range = ranges[0];\n    var root = new MeshBVHNode();\n    root.boundingData = fullBounds;\n    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    var _iterator = _createForOfIteratorHelper(ranges),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _range = _step.value;\n        var _root = new MeshBVHNode();\n        _root.boundingData = new Float32Array(6);\n        getBounds(triangleBounds, _range.offset, _range.count, _root.boundingData, cacheCentroidBoundingData);\n        splitNode(_root, _range.offset, _range.count, cacheCentroidBoundingData);\n        roots.push(_root);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return roots;\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  }\n\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count) {\n    var centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(\"MeshBVH: Max depth of \".concat(maxDepth, \" reached when generating BVH. Consider increasing maxDepth.\"));\n        console.warn(geometry);\n      }\n    }\n\n    // early out if we've met our capacity\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    // Find where to split the volume\n    var split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    var splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n\n    // create the two new child nodes\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n\n      // create the left child and compute its bounding box\n      var left = new MeshBVHNode();\n      var lstart = offset;\n      var lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n\n      // repeat for right\n      var right = new MeshBVHNode();\n      var rstart = splitOffset;\n      var rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n}\nexport function buildPackedTree(bvh, options) {\n  var geometry = bvh.geometry;\n  if (options.indirect) {\n    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);\n    if (hasGroupGaps(geometry) && !options.verbose) {\n      console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' + 'BVH may incorrectly report intersections on unrendered portions of the geometry.');\n    }\n  }\n  if (!bvh._indirectBuffer) {\n    ensureIndex(geometry, options);\n  }\n\n  // boundingData  \t\t\t\t: 6 float32\n  // right / offset \t\t\t\t: 1 uint32\n  // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n  var roots = buildTree(bvh, options);\n  var float32Array;\n  var uint32Array;\n  var uint16Array;\n  var packedRoots = [];\n  var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n  for (var i = 0; i < roots.length; i++) {\n    var root = roots[i];\n    var nodeCount = countNodes(root);\n    var buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n  bvh._roots = packedRoots;\n  return;\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n  function populateBuffer(byteOffset, node) {\n    var stride4Offset = byteOffset / 4;\n    var stride2Offset = byteOffset / 2;\n    var isLeaf = !!node.count;\n    var boundingData = node.boundingData;\n    for (var _i = 0; _i < 6; _i++) {\n      float32Array[stride4Offset + _i] = boundingData[_i];\n    }\n    if (isLeaf) {\n      var offset = node.offset;\n      var count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      var left = node.left;\n      var right = node.right;\n      var splitAxis = node.splitAxis;\n      var nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n      }\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}