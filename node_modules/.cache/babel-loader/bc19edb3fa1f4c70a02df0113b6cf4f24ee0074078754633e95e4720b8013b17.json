{"ast":null,"code":"import _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { Scene, Camera, Mesh, PlaneGeometry, ShaderMaterial, WebGLRenderTarget, RGBAFormat, DataTexture, FloatType, NoToneMapping, NearestFilter, ClampToEdgeWrapping } from \"three\";\nvar GPUComputationRenderer = /*#__PURE__*/_createClass(function GPUComputationRenderer(sizeX, sizeY, renderer) {\n  _classCallCheck(this, GPUComputationRenderer);\n  this.variables = [];\n  this.currentTextureIndex = 0;\n  var dataType = FloatType;\n  var scene = new Scene();\n  var camera = new Camera();\n  camera.position.z = 1;\n  var passThruUniforms = {\n    passThruTexture: {\n      value: null\n    }\n  };\n  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n  var mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n  scene.add(mesh);\n  this.setDataType = function (type) {\n    dataType = type;\n    return this;\n  };\n  this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n    var material = this.createShaderMaterial(computeFragmentShader);\n    var variable = {\n      name: variableName,\n      initialValueTexture: initialValueTexture,\n      material: material,\n      dependencies: null,\n      renderTargets: [],\n      wrapS: null,\n      wrapT: null,\n      minFilter: NearestFilter,\n      magFilter: NearestFilter\n    };\n    this.variables.push(variable);\n    return variable;\n  };\n  this.setVariableDependencies = function (variable, dependencies) {\n    variable.dependencies = dependencies;\n  };\n  this.init = function () {\n    if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has(\"OES_texture_float\") === false) {\n      return \"No OES_texture_float support for float textures.\";\n    }\n    if (renderer.capabilities.maxVertexTextures === 0) {\n      return \"No support for vertex shader textures.\";\n    }\n    for (var i = 0; i < this.variables.length; i++) {\n      var variable = this.variables[i];\n      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n      var material = variable.material;\n      var uniforms = material.uniforms;\n      if (variable.dependencies !== null) {\n        for (var d = 0; d < variable.dependencies.length; d++) {\n          var depVar = variable.dependencies[d];\n          if (depVar.name !== variable.name) {\n            var found = false;\n            for (var j = 0; j < this.variables.length; j++) {\n              if (depVar.name === this.variables[j].name) {\n                found = true;\n                break;\n              }\n            }\n            if (!found) {\n              return \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n            }\n          }\n          uniforms[depVar.name] = {\n            value: null\n          };\n          material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n        }\n      }\n    }\n    this.currentTextureIndex = 0;\n    return null;\n  };\n  this.compute = function () {\n    var currentTextureIndex = this.currentTextureIndex;\n    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n    for (var i = 0, il = this.variables.length; i < il; i++) {\n      var variable = this.variables[i];\n      if (variable.dependencies !== null) {\n        var uniforms = variable.material.uniforms;\n        for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {\n          var depVar = variable.dependencies[d];\n          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n        }\n      }\n      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n    }\n    this.currentTextureIndex = nextTextureIndex;\n  };\n  this.getCurrentRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex];\n  };\n  this.getAlternateRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n  };\n  this.dispose = function () {\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    var variables = this.variables;\n    for (var i = 0; i < variables.length; i++) {\n      var variable = variables[i];\n      if (variable.initialValueTexture) variable.initialValueTexture.dispose();\n      var renderTargets = variable.renderTargets;\n      for (var j = 0; j < renderTargets.length; j++) {\n        var renderTarget = renderTargets[j];\n        renderTarget.dispose();\n      }\n    }\n  };\n  function addResolutionDefine(materialShader) {\n    materialShader.defines.resolution = \"vec2( \" + sizeX.toFixed(1) + \", \" + sizeY.toFixed(1) + \" )\";\n  }\n  this.addResolutionDefine = addResolutionDefine;\n  function createShaderMaterial(computeFragmentShader, uniforms) {\n    uniforms = uniforms || {};\n    var material = new ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: getPassThroughVertexShader(),\n      fragmentShader: computeFragmentShader\n    });\n    addResolutionDefine(material);\n    return material;\n  }\n  this.createShaderMaterial = createShaderMaterial;\n  this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n    sizeXTexture = sizeXTexture || sizeX;\n    sizeYTexture = sizeYTexture || sizeY;\n    wrapS = wrapS || ClampToEdgeWrapping;\n    wrapT = wrapT || ClampToEdgeWrapping;\n    minFilter = minFilter || NearestFilter;\n    magFilter = magFilter || NearestFilter;\n    var renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n      wrapS: wrapS,\n      wrapT: wrapT,\n      minFilter: minFilter,\n      magFilter: magFilter,\n      format: RGBAFormat,\n      type: dataType,\n      depthBuffer: false\n    });\n    return renderTarget;\n  };\n  this.createTexture = function () {\n    var data = new Float32Array(sizeX * sizeY * 4);\n    var texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n    texture.needsUpdate = true;\n    return texture;\n  };\n  this.renderTexture = function (input, output) {\n    passThruUniforms.passThruTexture.value = input;\n    this.doRenderTarget(passThruShader, output);\n    passThruUniforms.passThruTexture.value = null;\n  };\n  this.doRenderTarget = function (material, output) {\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    var currentOutputColorSpace = renderer.outputColorSpace;\n    var currentToneMapping = renderer.toneMapping;\n    renderer.xr.enabled = false;\n    renderer.shadowMap.autoUpdate = false;\n    if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.encoding = 3e3;\n    renderer.toneMapping = NoToneMapping;\n    mesh.material = material;\n    renderer.setRenderTarget(output);\n    renderer.render(scene, camera);\n    mesh.material = passThruShader;\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.outputColorSpace = currentOutputColorSpace;\n    renderer.toneMapping = currentToneMapping;\n    renderer.setRenderTarget(currentRenderTarget);\n  };\n  function getPassThroughVertexShader() {\n    return \"void main()\t{\\n\\n\tgl_Position = vec4( position, 1.0 );\\n\\n}\\n\";\n  }\n  function getPassThroughFragmentShader() {\n    return \"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\\n\tgl_FragColor = texture2D( passThruTexture, uv );\\n\\n}\\n\";\n  }\n});\nexport { GPUComputationRenderer };\n//# sourceMappingURL=GPUComputationRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}