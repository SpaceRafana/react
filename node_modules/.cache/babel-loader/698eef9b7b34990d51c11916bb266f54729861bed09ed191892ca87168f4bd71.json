{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Color, MathUtils } from \"three\";\nvar Lut = /*#__PURE__*/function () {\n  function Lut(colormap) {\n    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    _classCallCheck(this, Lut);\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n  _createClass(Lut, [{\n    key: \"set\",\n    value: function set(value) {\n      if (value.isLut === true) {\n        this.copy(value);\n      }\n      return this;\n    }\n  }, {\n    key: \"setMin\",\n    value: function setMin(min) {\n      this.minV = min;\n      return this;\n    }\n  }, {\n    key: \"setMax\",\n    value: function setMax(max) {\n      this.maxV = max;\n      return this;\n    }\n  }, {\n    key: \"setColorMap\",\n    value: function setColorMap(colormap) {\n      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n      this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n      this.n = count;\n      var step = 1 / this.n;\n      var minColor = new Color();\n      var maxColor = new Color();\n      this.lut.length = 0;\n      this.lut.push(new Color(this.map[0][1]));\n      for (var i = 1; i < count; i++) {\n        var alpha = i * step;\n        for (var j = 0; j < this.map.length - 1; j++) {\n          if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n            var min = this.map[j][0];\n            var max = this.map[j + 1][0];\n            minColor.setHex(this.map[j][1], \"linear-srgb\");\n            maxColor.setHex(this.map[j + 1][1], \"linear-srgb\");\n            var color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n            this.lut.push(color);\n          }\n        }\n      }\n      this.lut.push(new Color(this.map[this.map.length - 1][1]));\n      return this;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(lut) {\n      this.lut = lut.lut;\n      this.map = lut.map;\n      this.n = lut.n;\n      this.minV = lut.minV;\n      this.maxV = lut.maxV;\n      return this;\n    }\n  }, {\n    key: \"getColor\",\n    value: function getColor(alpha) {\n      alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n      alpha = (alpha - this.minV) / (this.maxV - this.minV);\n      var colorPosition = Math.round(alpha * this.n);\n      return this.lut[colorPosition];\n    }\n  }, {\n    key: \"addColorMap\",\n    value: function addColorMap(name, arrayOfColors) {\n      ColorMapKeywords[name] = arrayOfColors;\n      return this;\n    }\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas() {\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = 1;\n      canvas.height = this.n;\n      this.updateCanvas(canvas);\n      return canvas;\n    }\n  }, {\n    key: \"updateCanvas\",\n    value: function updateCanvas(canvas) {\n      var ctx = canvas.getContext(\"2d\", {\n        alpha: false\n      });\n      var imageData = ctx.getImageData(0, 0, 1, this.n);\n      var data = imageData.data;\n      var k = 0;\n      var step = 1 / this.n;\n      var minColor = new Color();\n      var maxColor = new Color();\n      var finalColor = new Color();\n      for (var i = 1; i >= 0; i -= step) {\n        for (var j = this.map.length - 1; j >= 0; j--) {\n          if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n            var min = this.map[j - 1][0];\n            var max = this.map[j][0];\n            minColor.setHex(this.map[j - 1][1], \"linear-srgb\");\n            maxColor.setHex(this.map[j][1], \"linear-srgb\");\n            finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n            data[k * 4] = Math.round(finalColor.r * 255);\n            data[k * 4 + 1] = Math.round(finalColor.g * 255);\n            data[k * 4 + 2] = Math.round(finalColor.b * 255);\n            data[k * 4 + 3] = 255;\n            k += 1;\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, 0);\n      return canvas;\n    }\n  }]);\n  return Lut;\n}();\nvar ColorMapKeywords = {\n  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],\n  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],\n  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],\n  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]\n};\nexport { ColorMapKeywords, Lut };\n//# sourceMappingURL=Lut.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}