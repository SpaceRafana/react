{"ast":null,"code":"import UniformNode, { uniform } from '../core/UniformNode.js';\nimport { uv } from './UVNode.js';\nimport { textureSize } from './TextureSizeNode.js';\nimport { colorSpaceToLinear } from '../display/ColorSpaceNode.js';\nimport { context } from '../core/ContextNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { addNodeElement, nodeProxy, vec3, nodeObject } from '../shadernode/ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nclass TextureNode extends UniformNode {\n  constructor(value, uvNode = null, levelNode = null, compareNode = null) {\n    super(value);\n    this.isTextureNode = true;\n    this.uvNode = uvNode;\n    this.levelNode = levelNode;\n    this.compareNode = compareNode;\n    this.updateMatrix = false;\n    this.updateType = NodeUpdateType.NONE;\n    this.setUpdateMatrix(uvNode === null);\n  }\n  getUniformHash( /*builder*/\n  ) {\n    return this.value.uuid;\n  }\n  getNodeType( /*builder*/\n  ) {\n    if (this.value.isDepthTexture === true) return 'float';\n    return 'vec4';\n  }\n  getInputType( /*builder*/\n  ) {\n    return 'texture';\n  }\n  getDefaultUV() {\n    return uv(this.value.channel);\n  }\n  updateReference( /*frame*/\n  ) {\n    return this.value;\n  }\n  getTransformedUV(uvNode) {\n    const texture = this.value;\n    return uniform(texture.matrix).mul(vec3(uvNode, 1)).xy;\n  }\n  setUpdateMatrix(value) {\n    this.updateMatrix = value;\n    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;\n    return this;\n  }\n  setup(builder) {\n    const properties = builder.getNodeProperties(this);\n\n    //\n\n    let uvNode = this.uvNode;\n    if (uvNode === null && builder.context.getUVNode) {\n      uvNode = builder.context.getUVNode(this);\n    }\n    if (!uvNode) uvNode = this.getDefaultUV();\n    if (this.updateMatrix === true) {\n      uvNode = this.getTransformedUV(uvNode);\n    }\n\n    //\n\n    let levelNode = this.levelNode;\n    if (levelNode === null && builder.context.getSamplerLevelNode) {\n      levelNode = builder.context.getSamplerLevelNode(this);\n    }\n\n    //\n\n    properties.uvNode = uvNode;\n    properties.levelNode = levelNode ? builder.context.getMIPLevelAlgorithmNode(this, levelNode) : null;\n  }\n  generate(builder, output) {\n    const {\n      uvNode,\n      levelNode\n    } = builder.getNodeProperties(this);\n    const compareNode = this.compareNode;\n    const texture = this.value;\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('TextureNode: Need a three.js texture.');\n    }\n    const textureProperty = super.generate(builder, 'property');\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeType = this.getNodeType(builder);\n      const nodeData = builder.getDataFromNode(this);\n      let propertyName = nodeData.propertyName;\n      if (propertyName === undefined) {\n        const uvSnippet = uvNode.build(builder, 'vec2');\n        const nodeVar = builder.getVarFromNode(this, nodeType);\n        propertyName = builder.getPropertyName(nodeVar);\n        let snippet = null;\n        if (levelNode && levelNode.isNode === true) {\n          const levelSnippet = levelNode.build(builder, 'float');\n          snippet = builder.getTextureLevel(texture, textureProperty, uvSnippet, levelSnippet);\n        } else if (compareNode !== null) {\n          const compareSnippet = compareNode.build(builder, 'float');\n          snippet = builder.getTextureCompare(texture, textureProperty, uvSnippet, compareSnippet);\n        } else {\n          snippet = builder.getTexture(texture, textureProperty, uvSnippet);\n        }\n        builder.addLineFlowCode(`${propertyName} = ${snippet}`);\n        if (builder.context.tempWrite !== false) {\n          nodeData.snippet = snippet;\n          nodeData.propertyName = propertyName;\n        }\n      }\n      let snippet = propertyName;\n      if (builder.needsColorSpaceToLinear(this.value)) {\n        snippet = colorSpaceToLinear(expression(snippet, nodeType), this.value.colorSpace).setup(builder).build(builder, nodeType);\n      }\n      return builder.format(snippet, nodeType, output);\n    }\n  }\n  uv(uvNode) {\n    const textureNode = this.clone();\n    textureNode.uvNode = uvNode;\n    return nodeObject(textureNode);\n  }\n  level(levelNode) {\n    const textureNode = this.clone();\n    textureNode.levelNode = levelNode;\n    return context(textureNode, {\n      getMIPLevelAlgorithmNode: (textureNode, levelNode) => levelNode\n    });\n  }\n  size(levelNode) {\n    return textureSize(this, levelNode);\n  }\n  compare(compareNode) {\n    const textureNode = this.clone();\n    textureNode.compareNode = nodeObject(compareNode);\n    return nodeObject(textureNode);\n  }\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n  }\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n  }\n  update() {\n    const texture = this.value;\n    if (texture.matrixAutoUpdate === true) {\n      texture.updateMatrix();\n    }\n  }\n  clone() {\n    return new this.constructor(this.value, this.uvNode, this.levelNode, this.compareNode);\n  }\n}\nexport default TextureNode;\nexport const texture = nodeProxy(TextureNode);\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\nexport const sampler = aTexture => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert('sampler');\naddNodeElement('texture', texture);\n//addNodeElement( 'textureLevel', textureLevel );\n\naddNodeClass('TextureNode', TextureNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}