{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, MeshBasicMaterial, LinearMipmapLinearFilter } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityShader } from \"../shaders/LuminosityShader.js\";\nimport { ToneMapShader } from \"../shaders/ToneMapShader.js\";\nvar AdaptiveToneMappingPass = /*#__PURE__*/function (_Pass) {\n  _inherits(AdaptiveToneMappingPass, _Pass);\n  var _super = _createSuper(AdaptiveToneMappingPass);\n  function AdaptiveToneMappingPass(adaptive, resolution) {\n    var _this;\n    _classCallCheck(this, AdaptiveToneMappingPass);\n    _this = _super.call(this);\n    _this.resolution = resolution !== void 0 ? resolution : 256;\n    _this.needsInit = true;\n    _this.adaptive = adaptive !== void 0 ? !!adaptive : true;\n    _this.luminanceRT = null;\n    _this.previousLuminanceRT = null;\n    _this.currentLuminanceRT = null;\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false\n    });\n    _this.materialLuminance = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n      vertexShader: LuminosityShader.vertexShader,\n      fragmentShader: LuminosityShader.fragmentShader,\n      blending: NoBlending\n    });\n    _this.adaptLuminanceShader = {\n      defines: {\n        MIP_LEVEL_1X1: (Math.log(_this.resolution) / Math.log(2)).toFixed(1)\n      },\n      uniforms: {\n        lastLum: {\n          value: null\n        },\n        currentLum: {\n          value: null\n        },\n        minLuminance: {\n          value: 0.01\n        },\n        delta: {\n          value: 0.016\n        },\n        tau: {\n          value: 1\n        }\n      },\n      vertexShader: \"varying vec2 vUv;\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\t\\t}\",\n      fragmentShader: \"varying vec2 vUv;\\n\\n\\t\\t\\t\\tuniform sampler2D lastLum;\\n\\t\\t\\t\\tuniform sampler2D currentLum;\\n\\t\\t\\t\\tuniform float minLuminance;\\n\\t\\t\\t\\tuniform float delta;\\n\\t\\t\\t\\tuniform float tau;\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\\n\\t\\t\\t\\t\\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\\n\\n\\t\\t\\t\\t\\tfloat fLastLum = max( minLuminance, lastLum.r );\\n\\t\\t\\t\\t\\tfloat fCurrentLum = max( minLuminance, currentLum.r );\\n\\n\\t\\t\\t\\t\\t//The adaption seems to work better in extreme lighting differences\\n\\t\\t\\t\\t\\t//if the input luminance is squared.\\n\\t\\t\\t\\t\\tfCurrentLum *= fCurrentLum;\\n\\n\\t\\t\\t\\t\\t// Adapt the luminance using Pattanaik's technique\\n\\t\\t\\t\\t\\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\\n\\t\\t\\t\\t\\t// \\\"fAdaptedLum = sqrt(fAdaptedLum);\\n\\t\\t\\t\\t\\tgl_FragColor.r = fAdaptedLum;\\n\\t\\t\\t\\t}\"\n    };\n    _this.materialAdaptiveLum = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(_this.adaptLuminanceShader.uniforms),\n      vertexShader: _this.adaptLuminanceShader.vertexShader,\n      fragmentShader: _this.adaptLuminanceShader.fragmentShader,\n      defines: Object.assign({}, _this.adaptLuminanceShader.defines),\n      blending: NoBlending\n    });\n    _this.materialToneMap = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n      vertexShader: ToneMapShader.vertexShader,\n      fragmentShader: ToneMapShader.fragmentShader,\n      blending: NoBlending\n    });\n    _this.fsQuad = new FullScreenQuad(null);\n    return _this;\n  }\n  _createClass(AdaptiveToneMappingPass, [{\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime) {\n      if (this.needsInit) {\n        this.reset(renderer);\n        this.luminanceRT.texture.type = readBuffer.texture.type;\n        this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n        this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n        this.needsInit = false;\n      }\n      if (this.adaptive) {\n        this.fsQuad.material = this.materialLuminance;\n        this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n        renderer.setRenderTarget(this.currentLuminanceRT);\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.materialAdaptiveLum;\n        this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n        this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n        this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n        renderer.setRenderTarget(this.luminanceRT);\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n        renderer.setRenderTarget(this.previousLuminanceRT);\n        this.fsQuad.render(renderer);\n      }\n      this.fsQuad.material = this.materialToneMap;\n      this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n      if (this.renderToScreen) {\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      } else {\n        renderer.setRenderTarget(writeBuffer);\n        if (this.clear) renderer.clear();\n        this.fsQuad.render(renderer);\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.luminanceRT) {\n        this.luminanceRT.dispose();\n      }\n      if (this.currentLuminanceRT) {\n        this.currentLuminanceRT.dispose();\n      }\n      if (this.previousLuminanceRT) {\n        this.previousLuminanceRT.dispose();\n      }\n      this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n      this.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n      this.luminanceRT.texture.generateMipmaps = false;\n      this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n      this.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n      this.previousLuminanceRT.texture.generateMipmaps = false;\n      var pars = {\n        minFilter: LinearMipmapLinearFilter,\n        generateMipmaps: true\n      };\n      this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n      this.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n      if (this.adaptive) {\n        this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n        this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n      }\n      this.fsQuad.material = new MeshBasicMaterial({\n        color: 7829367\n      });\n      this.materialLuminance.needsUpdate = true;\n      this.materialAdaptiveLum.needsUpdate = true;\n      this.materialToneMap.needsUpdate = true;\n    }\n  }, {\n    key: \"setAdaptive\",\n    value: function setAdaptive(adaptive) {\n      if (adaptive) {\n        this.adaptive = true;\n        this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n        this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n      } else {\n        this.adaptive = false;\n        delete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n        this.materialToneMap.uniforms.luminanceMap.value = null;\n      }\n      this.materialToneMap.needsUpdate = true;\n    }\n  }, {\n    key: \"setAdaptionRate\",\n    value: function setAdaptionRate(rate) {\n      if (rate) {\n        this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n      }\n    }\n  }, {\n    key: \"setMinLuminance\",\n    value: function setMinLuminance(minLum) {\n      if (minLum) {\n        this.materialToneMap.uniforms.minLuminance.value = minLum;\n        this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n      }\n    }\n  }, {\n    key: \"setMaxLuminance\",\n    value: function setMaxLuminance(maxLum) {\n      if (maxLum) {\n        this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n      }\n    }\n  }, {\n    key: \"setAverageLuminance\",\n    value: function setAverageLuminance(avgLum) {\n      if (avgLum) {\n        this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n      }\n    }\n  }, {\n    key: \"setMiddleGrey\",\n    value: function setMiddleGrey(middleGrey) {\n      if (middleGrey) {\n        this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.luminanceRT) {\n        this.luminanceRT.dispose();\n      }\n      if (this.previousLuminanceRT) {\n        this.previousLuminanceRT.dispose();\n      }\n      if (this.currentLuminanceRT) {\n        this.currentLuminanceRT.dispose();\n      }\n      if (this.materialLuminance) {\n        this.materialLuminance.dispose();\n      }\n      if (this.materialAdaptiveLum) {\n        this.materialAdaptiveLum.dispose();\n      }\n      if (this.materialCopy) {\n        this.materialCopy.dispose();\n      }\n      if (this.materialToneMap) {\n        this.materialToneMap.dispose();\n      }\n    }\n  }]);\n  return AdaptiveToneMappingPass;\n}(Pass);\nexport { AdaptiveToneMappingPass };\n//# sourceMappingURL=AdaptiveToneMappingPass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}