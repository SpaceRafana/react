{"ast":null,"code":"import _slicedToArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"startFrame\", \"endFrame\", \"fps\", \"frameName\", \"textureDataURL\", \"textureImageURL\", \"loop\", \"numberOfFrames\", \"autoPlay\", \"animationNames\", \"onStart\", \"onEnd\", \"onLoopEnd\", \"onFrame\", \"play\", \"pause\", \"flipX\", \"alphaTest\", \"children\", \"asSprite\"];\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nvar SpriteAnimator = function SpriteAnimator(_ref, fref) {\n  var startFrame = _ref.startFrame,\n    endFrame = _ref.endFrame,\n    fps = _ref.fps,\n    frameName = _ref.frameName,\n    textureDataURL = _ref.textureDataURL,\n    textureImageURL = _ref.textureImageURL,\n    loop = _ref.loop,\n    numberOfFrames = _ref.numberOfFrames,\n    autoPlay = _ref.autoPlay,\n    animationNames = _ref.animationNames,\n    onStart = _ref.onStart,\n    onEnd = _ref.onEnd,\n    onLoopEnd = _ref.onLoopEnd,\n    onFrame = _ref.onFrame,\n    play = _ref.play,\n    pause = _ref.pause,\n    flipX = _ref.flipX,\n    alphaTest = _ref.alphaTest,\n    children = _ref.children,\n    asSprite = _ref.asSprite,\n    props = _objectWithoutProperties(_ref, _excluded);\n  useThree(function (state) {\n    return state.viewport;\n  });\n  var spriteData = React.useRef(null);\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    isJsonReady = _React$useState2[0],\n    setJsonReady = _React$useState2[1];\n  var hasEnded = React.useRef(false);\n  var matRef = React.useRef();\n  var spriteRef = React.useRef();\n  var timerOffset = React.useRef(window.performance.now());\n  var textureData = React.useRef();\n  var currentFrame = React.useRef(startFrame || 0);\n  var currentFrameName = React.useRef(frameName || '');\n  var fpsInterval = 1000 / (fps || 30);\n  var _React$useState3 = React.useState(new THREE.Texture()),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    spriteTexture = _React$useState4[0],\n    setSpriteTexture = _React$useState4[1];\n  var totalFrames = React.useRef(0);\n  var _React$useState5 = React.useState([1, 1, 1]),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    aspect = _React$useState6[0],\n    setAspect = _React$useState6[1];\n  var flipOffset = flipX ? -1 : 1;\n  var _React$useState7 = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true),\n    _React$useState8 = _slicedToArray(_React$useState7, 2),\n    displayAsSprite = _React$useState8[0],\n    setDisplayAsSprite = _React$useState8[1];\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    var textureLoader = new THREE.TextureLoader();\n    var jsonPromise = fetch(jsonUrl).then(function (response) {\n      return response.json();\n    });\n    var texturePromise = new Promise(function (resolve) {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(function (response) {\n      callback(response[0], response[1]);\n    });\n  }\n  var calculateAspectRatio = function calculateAspectRatio(width, height) {\n    var aspectRatio = height / width;\n    if (spriteRef.current) {\n      spriteRef.current.scale.set(1, aspectRatio, 1);\n    }\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(function () {\n    if (textureDataURL && textureImageURL) {\n      loadJsonAndTextureAndExecuteCallback(textureDataURL, textureImageURL, parseSpriteData);\n    } else if (textureImageURL) {\n      // only load the texture, this is an image sprite only\n      var textureLoader = new THREE.TextureLoader();\n      new Promise(function (resolve) {\n        textureLoader.load(textureImageURL, resolve);\n      }).then(function (texture) {\n        parseSpriteData(null, texture);\n      });\n    }\n  }, []);\n  React.useEffect(function () {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n  React.useLayoutEffect(function () {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(function () {}, [pause]);\n  React.useEffect(function () {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      hasEnded.current = false;\n      modifySpritePosition();\n      if (spriteData.current) {\n        var _getFirstItem$sourceS = getFirstItem(spriteData.current.frames).sourceSize,\n          w = _getFirstItem$sourceS.w,\n          h = _getFirstItem$sourceS.h;\n        var _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName]);\n  var parseSpriteData = function parseSpriteData(json, _spriteTexture) {\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        var width = _spriteTexture.image.width;\n        var height = _spriteTexture.image.height;\n        var frameWidth = width / numberOfFrames;\n        var frameHeight = height;\n        textureData.current = _spriteTexture;\n        totalFrames.current = numberOfFrames;\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (var i = 0; i < numberOfFrames; i++) {\n            spriteData.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n      }\n    } else if (_spriteTexture) {\n      spriteData.current = json;\n      spriteData.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      textureData.current = _spriteTexture;\n      var _getFirstItem$sourceS2 = getFirstItem(json.frames).sourceSize,\n        w = _getFirstItem$sourceS2.w,\n        h = _getFirstItem$sourceS2.h;\n      var _aspect2 = calculateAspectRatio(w, h);\n      setAspect(_aspect2);\n      if (matRef.current) {\n        matRef.current.map = _spriteTexture;\n      }\n    }\n    _spriteTexture.premultiplyAlpha = false;\n    setSpriteTexture(_spriteTexture);\n  };\n\n  // for frame based JSON Hash sprite data\n  var parseFrames = function parseFrames() {\n    var sprites = {};\n    var data = spriteData.current;\n    var delimiters = animationNames;\n    if (delimiters) {\n      for (var i = 0; i < delimiters.length; i++) {\n        sprites[delimiters[i]] = [];\n        for (var innerKey in data['frames']) {\n          var value = data['frames'][innerKey];\n          var frameData = value['frame'];\n          var x = frameData['x'];\n          var y = frameData['y'];\n          var width = frameData['w'];\n          var height = frameData['h'];\n          var sourceWidth = value['sourceSize']['w'];\n          var sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n    }\n    return sprites;\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  var modifySpritePosition = function modifySpritePosition() {\n    if (!spriteData.current) return;\n    var _spriteData$current2 = spriteData.current,\n      metaInfo = _spriteData$current2.meta.size,\n      frames = _spriteData$current2.frames;\n    var _ref2 = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n        w: 0,\n        h: 0\n      } : {\n        w: 0,\n        h: 0\n      },\n      frameW = _ref2.w,\n      frameH = _ref2.h;\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    var framesV = (metaInfo.h - 1) / frameH;\n    var frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    setJsonReady(true);\n    if (onStart) onStart({\n      currentFrameName: frameName,\n      currentFrame: currentFrame.current\n    });\n  };\n\n  // run the animation on each frame\n  var runAnimation = function runAnimation() {\n    //if (!frameName) return\n    var now = window.performance.now();\n    var diff = now - timerOffset.current;\n    var _spriteData$current3 = spriteData.current,\n      metaInfo = _spriteData$current3.meta.size,\n      frames = _spriteData$current3.frames;\n    var _getFirstItem$sourceS3 = getFirstItem(frames).sourceSize,\n      frameW = _getFirstItem$sourceS3.w,\n      frameH = _getFirstItem$sourceS3.h;\n    var spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    var finalValX = 0;\n    var finalValY = 0;\n    var _endFrame = endFrame || spriteFrames.length - 1;\n    if (currentFrame.current > _endFrame) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        hasEnded.current = true;\n      }\n      if (!loop) return;\n    }\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateAspectRatio(frameW, frameH);\n    var framesH = (metaInfo.w - 1) / frameW;\n    var framesV = (metaInfo.h - 1) / frameH;\n    var _spriteFrames$current = spriteFrames[currentFrame.current],\n      _spriteFrames$current2 = _spriteFrames$current.frame,\n      frameX = _spriteFrames$current2.x,\n      frameY = _spriteFrames$current2.y,\n      _spriteFrames$current3 = _spriteFrames$current.sourceSize,\n      originalSizeX = _spriteFrames$current3.w,\n      originalSizeY = _spriteFrames$current3.h;\n    var frameOffsetX = 1 / framesH;\n    var frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n    currentFrame.current += 1;\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame(function (state, delta) {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pause) {\n      return;\n    }\n    if (!hasEnded.current && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  var getFirstItem = function getFirstItem(param) {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      var keys = Object.keys(param);\n      return frameName ? param[frameName][0] : param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: [1, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }))), children);\n};\nexport { SpriteAnimator };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}