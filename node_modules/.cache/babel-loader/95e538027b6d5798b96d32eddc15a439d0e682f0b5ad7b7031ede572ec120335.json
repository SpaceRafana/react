{"ast":null,"code":"import _slicedToArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"debug\", \"children\", \"frames\", \"ior\", \"color\", \"causticsOnly\", \"backside\", \"backsideIOR\", \"worldRadius\", \"intensity\", \"resolution\", \"lightSource\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nimport { useHelper } from './useHelper.js';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { Edges } from './Edges.js';\nimport { FullScreenQuad } from 'three-stdlib';\nimport { version } from '../helpers/constants.js';\nfunction createNormalMaterial() {\n  var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : THREE.FrontSide;\n  var viewMatrix = {\n    value: new THREE.Matrix4()\n  };\n  return Object.assign(new THREE.MeshNormalMaterial({\n    side: side\n  }), {\n    viewMatrix: viewMatrix,\n    onBeforeCompile: function onBeforeCompile(shader) {\n      shader.uniforms.viewMatrix = viewMatrix;\n      shader.fragmentShader = \"vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n         }\\n\" + shader.fragmentShader.replace('#include <normal_fragment_maps>', \"#include <normal_fragment_maps>\\n           normal = inverseTransformDirection( normal, viewMatrix );\\n\");\n    }\n  });\n}\nvar CausticsProjectionMaterial = /* @__PURE__ */shaderMaterial({\n  causticsTexture: null,\n  causticsTextureB: null,\n  color: /* @__PURE__ */new THREE.Color(),\n  lightProjMatrix: /* @__PURE__ */new THREE.Matrix4(),\n  lightViewMatrix: /* @__PURE__ */new THREE.Matrix4()\n}, \"varying vec3 vWorldPosition;   \\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\\n     vWorldPosition = worldPosition.xyz;\\n   }\", \"varying vec3 vWorldPosition;\\n  uniform vec3 color;\\n  uniform sampler2D causticsTexture; \\n  uniform sampler2D causticsTextureB; \\n  uniform mat4 lightProjMatrix;\\n  uniform mat4 lightViewMatrix;\\n   void main() {\\n    // Apply caustics  \\n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\\n    lightSpacePos.xyz /= lightSpacePos.w;\\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \\n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\\n    gl_FragColor = vec4((front + back) * color, 1.0);\\n    #include <tonemapping_fragment>\\n    #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n   }\"));\nvar CausticsMaterial = /* @__PURE__ */shaderMaterial({\n  cameraMatrixWorld: /* @__PURE__ */new THREE.Matrix4(),\n  cameraProjectionMatrixInv: /* @__PURE__ */new THREE.Matrix4(),\n  normalTexture: null,\n  depthTexture: null,\n  lightDir: /* @__PURE__ */new THREE.Vector3(0, 1, 0),\n  lightPlaneNormal: /* @__PURE__ */new THREE.Vector3(0, 1, 0),\n  lightPlaneConstant: 0,\n  near: 0.1,\n  far: 100,\n  modelMatrix: /* @__PURE__ */new THREE.Matrix4(),\n  worldRadius: 1 / 40,\n  ior: 1.1,\n  bounces: 0,\n  resolution: 1024,\n  size: 10,\n  intensity: 0.5\n}, /* glsl */\"\\n  varying vec2 vUv;\\n  void main() {\\n      vUv = uv;\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n  }\", /* glsl */\"  \\n  uniform mat4 cameraMatrixWorld;\\n  uniform mat4 cameraProjectionMatrixInv;\\n  uniform vec3 lightDir;\\n  uniform vec3 lightPlaneNormal;\\n  uniform float lightPlaneConstant;\\n  uniform float near;\\n  uniform float far;\\n  uniform float time;\\n  uniform float worldRadius;\\n  uniform float resolution;\\n  uniform float size;\\n  uniform float intensity;\\n  uniform float ior;\\n  precision highp isampler2D;\\n  precision highp usampler2D;\\n  uniform sampler2D normalTexture;\\n  uniform sampler2D depthTexture;\\n  uniform float bounces;\\n  varying vec2 vUv;\\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\\n    float z = depth * 2.0 - 1.0;\\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\\n    // Perspective division\\n    viewSpacePosition /= viewSpacePosition.w;\\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\\n    return worldSpacePosition.xyz;\\n  }                  \\n  float sdPlane( vec3 p, vec3 n, float h ) {\\n    // n must be normalized\\n    return dot(p,n) + h;\\n  }\\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\n  }\\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\\n    rayOrigin = ro;\\n    rayDirection = rd;\\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\\n    rayOrigin = pos + rayDirection * 0.1;\\n    return rayDirection;\\n  }\\n  void main() {\\n    // Each sample consists of random offset in the x and y direction\\n    float caustic = 0.0;\\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\\n    float texelsNeeded = worldRadius / causticTexelSize;\\n    float sampleRadius = texelsNeeded / resolution;\\n    float sum = 0.0;\\n    if (texture2D(depthTexture, vUv).x == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 uv1 = vUv + offset1 * sampleRadius;\\n    vec2 uv2 = vUv + offset2 * sampleRadius;\\n    vec2 uv3 = vUv + offset3 * sampleRadius;\\n    vec2 uv4 = vUv + offset4 * sampleRadius;\\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\\n    // Sanity check the depths\\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\\n    vec3 endPos1, endPos2, endPos3, endPos4;\\n    vec3 endDir1, endDir2, endDir3, endDir4;\\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\\n    caustic += intensity * (lightPosArea / finalArea);\\n    // Calculate the area of the triangle in light spaces\\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\\n  }\");\nvar NORMALPROPS = {\n  depth: true,\n  minFilter: THREE.LinearFilter,\n  magFilter: THREE.LinearFilter,\n  type: THREE.UnsignedByteType\n};\nvar CAUSTICPROPS = {\n  minFilter: THREE.LinearMipmapLinearFilter,\n  magFilter: THREE.LinearFilter,\n  type: THREE.FloatType,\n  generateMipmaps: true\n};\nvar Caustics = /* @__PURE__ */React.forwardRef(function (_ref, fref) {\n  var debug = _ref.debug,\n    children = _ref.children,\n    _ref$frames = _ref.frames,\n    frames = _ref$frames === void 0 ? 1 : _ref$frames,\n    _ref$ior = _ref.ior,\n    ior = _ref$ior === void 0 ? 1.1 : _ref$ior,\n    _ref$color = _ref.color,\n    color = _ref$color === void 0 ? 'white' : _ref$color,\n    _ref$causticsOnly = _ref.causticsOnly,\n    causticsOnly = _ref$causticsOnly === void 0 ? false : _ref$causticsOnly,\n    _ref$backside = _ref.backside,\n    backside = _ref$backside === void 0 ? false : _ref$backside,\n    _ref$backsideIOR = _ref.backsideIOR,\n    backsideIOR = _ref$backsideIOR === void 0 ? 1.1 : _ref$backsideIOR,\n    _ref$worldRadius = _ref.worldRadius,\n    worldRadius = _ref$worldRadius === void 0 ? 0.3125 : _ref$worldRadius,\n    _ref$intensity = _ref.intensity,\n    intensity = _ref$intensity === void 0 ? 0.05 : _ref$intensity,\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? 2024 : _ref$resolution,\n    _ref$lightSource = _ref.lightSource,\n    lightSource = _ref$lightSource === void 0 ? [5, 5, 5] : _ref$lightSource,\n    props = _objectWithoutProperties(_ref, _excluded);\n  extend({\n    CausticsProjectionMaterial: CausticsProjectionMaterial\n  });\n  var ref = React.useRef(null);\n  var camera = React.useRef(null);\n  var scene = React.useRef(null);\n  var plane = React.useRef(null);\n  var gl = useThree(function (state) {\n    return state.gl;\n  });\n  var helper = useHelper(debug && camera, THREE.CameraHelper);\n\n  // Buffers for front and back faces\n  var normalTarget = useFBO(resolution, resolution, NORMALPROPS);\n  var normalTargetB = useFBO(resolution, resolution, NORMALPROPS);\n  var causticsTarget = useFBO(resolution, resolution, CAUSTICPROPS);\n  var causticsTargetB = useFBO(resolution, resolution, CAUSTICPROPS);\n  // Normal materials for front and back faces\n  var _React$useState = React.useState(function () {\n      return createNormalMaterial();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    normalMat = _React$useState2[0];\n  var _React$useState3 = React.useState(function () {\n      return createNormalMaterial(THREE.BackSide);\n    }),\n    _React$useState4 = _slicedToArray(_React$useState3, 1),\n    normalMatB = _React$useState4[0];\n  // The quad that catches the caustics\n  var _React$useState5 = React.useState(function () {\n      return new CausticsMaterial();\n    }),\n    _React$useState6 = _slicedToArray(_React$useState5, 1),\n    causticsMaterial = _React$useState6[0];\n  var _React$useState7 = React.useState(function () {\n      return new FullScreenQuad(causticsMaterial);\n    }),\n    _React$useState8 = _slicedToArray(_React$useState7, 1),\n    causticsQuad = _React$useState8[0];\n  React.useLayoutEffect(function () {\n    ref.current.updateWorldMatrix(false, true);\n  });\n  var count = 0;\n  var v = new THREE.Vector3();\n  var lpF = new THREE.Frustum();\n  var lpM = new THREE.Matrix4();\n  var lpP = new THREE.Plane();\n  var lightDir = new THREE.Vector3();\n  var lightDirInv = new THREE.Vector3();\n  var bounds = new THREE.Box3();\n  var focusPos = new THREE.Vector3();\n  var boundsVertices = [];\n  var worldVerts = [];\n  var projectedVerts = [];\n  var lightDirs = [];\n  var cameraPos = new THREE.Vector3();\n  for (var i = 0; i < 8; i++) {\n    boundsVertices.push(new THREE.Vector3());\n    worldVerts.push(new THREE.Vector3());\n    projectedVerts.push(new THREE.Vector3());\n    lightDirs.push(new THREE.Vector3());\n  }\n  useFrame(function () {\n    if (frames === Infinity || count++ < frames) {\n      var _scene$current$parent, _helper$current;\n      if (Array.isArray(lightSource)) lightDir.fromArray(lightSource).normalize();else lightDir.copy(ref.current.worldToLocal(lightSource.current.getWorldPosition(v)).normalize());\n      lightDirInv.copy(lightDir).multiplyScalar(-1);\n      (_scene$current$parent = scene.current.parent) == null || _scene$current$parent.matrixWorld.identity();\n      bounds.setFromObject(scene.current, true);\n      boundsVertices[0].set(bounds.min.x, bounds.min.y, bounds.min.z);\n      boundsVertices[1].set(bounds.min.x, bounds.min.y, bounds.max.z);\n      boundsVertices[2].set(bounds.min.x, bounds.max.y, bounds.min.z);\n      boundsVertices[3].set(bounds.min.x, bounds.max.y, bounds.max.z);\n      boundsVertices[4].set(bounds.max.x, bounds.min.y, bounds.min.z);\n      boundsVertices[5].set(bounds.max.x, bounds.min.y, bounds.max.z);\n      boundsVertices[6].set(bounds.max.x, bounds.max.y, bounds.min.z);\n      boundsVertices[7].set(bounds.max.x, bounds.max.y, bounds.max.z);\n      for (var _i = 0; _i < 8; _i++) {\n        worldVerts[_i].copy(boundsVertices[_i]);\n      }\n      bounds.getCenter(focusPos);\n      boundsVertices.map(function (v) {\n        return v.sub(focusPos);\n      });\n      var lightPlane = lpP.set(lightDirInv, 0);\n      boundsVertices.map(function (v, i) {\n        return lightPlane.projectPoint(v, projectedVerts[i]);\n      });\n      var centralVert = projectedVerts.reduce(function (a, b) {\n        return a.add(b);\n      }, v.set(0, 0, 0)).divideScalar(projectedVerts.length);\n      var radius = projectedVerts.map(function (v) {\n        return v.distanceTo(centralVert);\n      }).reduce(function (a, b) {\n        return Math.max(a, b);\n      });\n      var dirLength = boundsVertices.map(function (x) {\n        return x.dot(lightDir);\n      }).reduce(function (a, b) {\n        return Math.max(a, b);\n      });\n      // Shadows\n      camera.current.position.copy(cameraPos.copy(lightDir).multiplyScalar(dirLength).add(focusPos));\n      camera.current.lookAt(scene.current.localToWorld(focusPos));\n      var dirMatrix = lpM.lookAt(camera.current.position, focusPos, v.set(0, 1, 0));\n      camera.current.left = -radius;\n      camera.current.right = radius;\n      camera.current.top = radius;\n      camera.current.bottom = -radius;\n      var yOffset = v.set(0, radius, 0).applyMatrix4(dirMatrix);\n      var yTime = (camera.current.position.y + yOffset.y) / lightDir.y;\n      camera.current.near = 0.1;\n      camera.current.far = yTime;\n      camera.current.updateProjectionMatrix();\n      camera.current.updateMatrixWorld();\n\n      // Now find size of ground plane\n      var groundProjectedCoords = worldVerts.map(function (v, i) {\n        return v.add(lightDirs[i].copy(lightDir).multiplyScalar(-v.y / lightDir.y));\n      });\n      var centerPos = groundProjectedCoords.reduce(function (a, b) {\n        return a.add(b);\n      }, v.set(0, 0, 0)).divideScalar(groundProjectedCoords.length);\n      var maxSize = 2 * groundProjectedCoords.map(function (v) {\n        return Math.hypot(v.x - centerPos.x, v.z - centerPos.z);\n      }).reduce(function (a, b) {\n        return Math.max(a, b);\n      });\n      plane.current.scale.setScalar(maxSize);\n      plane.current.position.copy(centerPos);\n      if (debug) (_helper$current = helper.current) == null || _helper$current.update();\n\n      // Inject uniforms\n      normalMatB.viewMatrix.value = normalMat.viewMatrix.value = camera.current.matrixWorldInverse;\n      var dirLightNearPlane = lpF.setFromProjectionMatrix(lpM.multiplyMatrices(camera.current.projectionMatrix, camera.current.matrixWorldInverse)).planes[4];\n      causticsMaterial.cameraMatrixWorld = camera.current.matrixWorld;\n      causticsMaterial.cameraProjectionMatrixInv = camera.current.projectionMatrixInverse;\n      causticsMaterial.lightDir = lightDirInv;\n      causticsMaterial.lightPlaneNormal = dirLightNearPlane.normal;\n      causticsMaterial.lightPlaneConstant = dirLightNearPlane.constant;\n      causticsMaterial.near = camera.current.near;\n      causticsMaterial.far = camera.current.far;\n      causticsMaterial.resolution = resolution;\n      causticsMaterial.size = radius;\n      causticsMaterial.intensity = intensity;\n      causticsMaterial.worldRadius = worldRadius;\n\n      // Switch the scene on\n      scene.current.visible = true;\n\n      // Render front face normals\n      gl.setRenderTarget(normalTarget);\n      gl.clear();\n      scene.current.overrideMaterial = normalMat;\n      gl.render(scene.current, camera.current);\n\n      // Render back face normals, if enabled\n      gl.setRenderTarget(normalTargetB);\n      gl.clear();\n      if (backside) {\n        scene.current.overrideMaterial = normalMatB;\n        gl.render(scene.current, camera.current);\n      }\n\n      // Remove the override material\n      scene.current.overrideMaterial = null;\n\n      // Render front face caustics\n      causticsMaterial.ior = ior;\n      plane.current.material.lightProjMatrix = camera.current.projectionMatrix;\n      plane.current.material.lightViewMatrix = camera.current.matrixWorldInverse;\n      causticsMaterial.normalTexture = normalTarget.texture;\n      causticsMaterial.depthTexture = normalTarget.depthTexture;\n      gl.setRenderTarget(causticsTarget);\n      gl.clear();\n      causticsQuad.render(gl);\n\n      // Render back face caustics, if enabled\n      causticsMaterial.ior = backsideIOR;\n      causticsMaterial.normalTexture = normalTargetB.texture;\n      causticsMaterial.depthTexture = normalTargetB.depthTexture;\n      gl.setRenderTarget(causticsTargetB);\n      gl.clear();\n      if (backside) causticsQuad.render(gl);\n\n      // Reset render target\n      gl.setRenderTarget(null);\n\n      // Switch the scene off if caustics is all that's wanted\n      if (causticsOnly) scene.current.visible = false;\n    }\n  });\n  React.useImperativeHandle(fref, function () {\n    return ref.current;\n  }, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(\"scene\", {\n    ref: scene\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: camera,\n    up: [0, 1, 0]\n  }), children), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: 2,\n    ref: plane,\n    \"rotation-x\": -Math.PI / 2\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"causticsProjectionMaterial\", {\n    transparent: true,\n    color: color,\n    causticsTexture: causticsTarget.texture,\n    causticsTextureB: causticsTargetB.texture,\n    blending: THREE.CustomBlending,\n    blendSrc: THREE.OneFactor,\n    blendDst: THREE.SrcAlphaFactor,\n    depthWrite: false\n  }), debug && /*#__PURE__*/React.createElement(Edges, null, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: \"#ffff00\",\n    toneMapped: false\n  }))));\n});\nexport { Caustics };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}