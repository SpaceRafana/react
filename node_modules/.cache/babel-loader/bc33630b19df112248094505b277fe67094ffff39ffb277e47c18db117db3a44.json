{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Object3D, Vector3, Quaternion, AnimationMixer } from \"three\";\nimport { CCDIKSolver } from \"./CCDIKSolver.js\";\nimport { MMDPhysics } from \"./MMDPhysics.js\";\nvar MMDAnimationHelper = /*#__PURE__*/function () {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  function MMDAnimationHelper() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, MMDAnimationHelper);\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = \"target\";\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = /* @__PURE__ */new WeakMap();\n    this.configuration = {\n      sync: params.sync !== void 0 ? params.sync : true,\n      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== void 0 ? params.pmxAnimation : false\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n    this.onBeforePhysics = function () {};\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n  _createClass(MMDAnimationHelper, [{\n    key: \"add\",\n    value: function add(object) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (object.isSkinnedMesh) {\n        this._addMesh(object, params);\n      } else if (object.isCamera) {\n        this._setupCamera(object, params);\n      } else if (object.type === \"Audio\") {\n        this._setupAudio(object, params);\n      } else {\n        throw new Error(\"THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n      }\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    }\n    /**\n     * Removes an Three.js Object from helper.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @return {MMDAnimationHelper}\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(object) {\n      if (object.isSkinnedMesh) {\n        this._removeMesh(object);\n      } else if (object.isCamera) {\n        this._clearCamera(object);\n      } else if (object.type === \"Audio\") {\n        this._clearAudio(object);\n      } else {\n        throw new Error(\"THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n      }\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    }\n    /**\n     * Updates the animation.\n     *\n     * @param {Number} delta\n     * @return {MMDAnimationHelper}\n     */\n  }, {\n    key: \"update\",\n    value: function update(delta) {\n      if (this.audioManager !== null) this.audioManager.control(delta);\n      for (var i = 0; i < this.meshes.length; i++) {\n        this._animateMesh(this.meshes[i], delta);\n      }\n      if (this.sharedPhysics) this._updateSharedPhysics(delta);\n      if (this.camera !== null) this._animateCamera(this.camera, delta);\n      return this;\n    }\n    /**\n     * Changes the pose of SkinnedMesh as VPD specifies.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @param {Object} vpd - VPD content parsed MMDParser\n     * @param {Object} params - (optional)\n     * @param {boolean} params.resetPose - Default is true.\n     * @param {boolean} params.ik - Default is true.\n     * @param {boolean} params.grant - Default is true.\n     * @return {MMDAnimationHelper}\n     */\n  }, {\n    key: \"pose\",\n    value: function pose(mesh, vpd) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (params.resetPose !== false) mesh.pose();\n      var bones = mesh.skeleton.bones;\n      var boneParams = vpd.bones;\n      var boneNameDictionary = {};\n      for (var i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = i;\n      }\n      var vector = new Vector3();\n      var quaternion = new Quaternion();\n      for (var _i = 0, _il = boneParams.length; _i < _il; _i++) {\n        var boneParam = boneParams[_i];\n        var boneIndex = boneNameDictionary[boneParam.name];\n        if (boneIndex === void 0) continue;\n        var bone = bones[boneIndex];\n        bone.position.add(vector.fromArray(boneParam.translation));\n        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n      }\n      mesh.updateMatrixWorld(true);\n      if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n        var sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n        var ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null;\n        var grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null;\n        this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver);\n      } else {\n        if (params.ik !== false) {\n          this._createCCDIKSolver(mesh).update();\n        }\n        if (params.grant !== false) {\n          this.createGrantSolver(mesh).update();\n        }\n      }\n      return this;\n    }\n    /**\n     * Enabes/Disables an animation feature.\n     *\n     * @param {string} key\n     * @param {boolean} enabled\n     * @return {MMDAnimationHelper}\n     */\n  }, {\n    key: \"enable\",\n    value: function enable(key, enabled) {\n      if (this.enabled[key] === void 0) {\n        throw new Error(\"THREE.MMDAnimationHelper.enable: unknown key \" + key);\n      }\n      this.enabled[key] = enabled;\n      if (key === \"physics\") {\n        for (var i = 0, il = this.meshes.length; i < il; i++) {\n          this._optimizeIK(this.meshes[i], enabled);\n        }\n      }\n      return this;\n    }\n    /**\n     * Creates an GrantSolver instance.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @return {GrantSolver}\n     */\n  }, {\n    key: \"createGrantSolver\",\n    value: function createGrantSolver(mesh) {\n      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n    }\n    // private methods\n  }, {\n    key: \"_addMesh\",\n    value: function _addMesh(mesh, params) {\n      if (this.meshes.indexOf(mesh) >= 0) {\n        throw new Error(\"THREE.MMDAnimationHelper._addMesh: SkinnedMesh '\" + mesh.name + \"' has already been added.\");\n      }\n      this.meshes.push(mesh);\n      this.objects.set(mesh, {\n        looped: false\n      });\n      this._setupMeshAnimation(mesh, params.animation);\n      if (params.physics !== false) {\n        this._setupMeshPhysics(mesh, params);\n      }\n      return this;\n    }\n  }, {\n    key: \"_setupCamera\",\n    value: function _setupCamera(camera, params) {\n      if (this.camera === camera) {\n        throw new Error(\"THREE.MMDAnimationHelper._setupCamera: Camera '\" + camera.name + \"' has already been set.\");\n      }\n      if (this.camera) this.clearCamera(this.camera);\n      this.camera = camera;\n      camera.add(this.cameraTarget);\n      this.objects.set(camera, {});\n      if (params.animation !== void 0) {\n        this._setupCameraAnimation(camera, params.animation);\n      }\n      return this;\n    }\n  }, {\n    key: \"_setupAudio\",\n    value: function _setupAudio(audio, params) {\n      if (this.audio === audio) {\n        throw new Error(\"THREE.MMDAnimationHelper._setupAudio: Audio '\" + audio.name + \"' has already been set.\");\n      }\n      if (this.audio) this.clearAudio(this.audio);\n      this.audio = audio;\n      this.audioManager = new AudioManager(audio, params);\n      this.objects.set(this.audioManager, {\n        duration: this.audioManager.duration\n      });\n      return this;\n    }\n  }, {\n    key: \"_removeMesh\",\n    value: function _removeMesh(mesh) {\n      var found = false;\n      var writeIndex = 0;\n      for (var i = 0, il = this.meshes.length; i < il; i++) {\n        if (this.meshes[i] === mesh) {\n          this.objects.delete(mesh);\n          found = true;\n          continue;\n        }\n        this.meshes[writeIndex++] = this.meshes[i];\n      }\n      if (!found) {\n        throw new Error(\"THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '\" + mesh.name + \"' has not been added yet.\");\n      }\n      this.meshes.length = writeIndex;\n      return this;\n    }\n  }, {\n    key: \"_clearCamera\",\n    value: function _clearCamera(camera) {\n      if (camera !== this.camera) {\n        throw new Error(\"THREE.MMDAnimationHelper._clearCamera: Camera '\" + camera.name + \"' has not been set yet.\");\n      }\n      this.camera.remove(this.cameraTarget);\n      this.objects.delete(this.camera);\n      this.camera = null;\n      return this;\n    }\n  }, {\n    key: \"_clearAudio\",\n    value: function _clearAudio(audio) {\n      if (audio !== this.audio) {\n        throw new Error(\"THREE.MMDAnimationHelper._clearAudio: Audio '\" + audio.name + \"' has not been set yet.\");\n      }\n      this.objects.delete(this.audioManager);\n      this.audio = null;\n      this.audioManager = null;\n      return this;\n    }\n  }, {\n    key: \"_setupMeshAnimation\",\n    value: function _setupMeshAnimation(mesh, animation) {\n      var objects = this.objects.get(mesh);\n      if (animation !== void 0) {\n        var animations = Array.isArray(animation) ? animation : [animation];\n        objects.mixer = new AnimationMixer(mesh);\n        for (var i = 0, il = animations.length; i < il; i++) {\n          objects.mixer.clipAction(animations[i]).play();\n        }\n        objects.mixer.addEventListener(\"loop\", function (event) {\n          var tracks = event.action._clip.tracks;\n          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== \".bones\") return;\n          objects.looped = true;\n        });\n      }\n      objects.ikSolver = this._createCCDIKSolver(mesh);\n      objects.grantSolver = this.createGrantSolver(mesh);\n      return this;\n    }\n  }, {\n    key: \"_setupCameraAnimation\",\n    value: function _setupCameraAnimation(camera, animation) {\n      var animations = Array.isArray(animation) ? animation : [animation];\n      var objects = this.objects.get(camera);\n      objects.mixer = new AnimationMixer(camera);\n      for (var i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n    }\n  }, {\n    key: \"_setupMeshPhysics\",\n    value: function _setupMeshPhysics(mesh, params) {\n      var objects = this.objects.get(mesh);\n      if (params.world === void 0 && this.sharedPhysics) {\n        var masterPhysics = this._getMasterPhysics();\n        if (masterPhysics !== null) world = masterPhysics.world;\n      }\n      objects.physics = this._createMMDPhysics(mesh, params);\n      if (objects.mixer && params.animationWarmup !== false) {\n        this._animateMesh(mesh, 0);\n        objects.physics.reset();\n      }\n      objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);\n      this._optimizeIK(mesh, true);\n    }\n  }, {\n    key: \"_animateMesh\",\n    value: function _animateMesh(mesh, delta) {\n      var objects = this.objects.get(mesh);\n      var mixer = objects.mixer;\n      var ikSolver = objects.ikSolver;\n      var grantSolver = objects.grantSolver;\n      var physics = objects.physics;\n      var looped = objects.looped;\n      if (mixer && this.enabled.animation) {\n        this._restoreBones(mesh);\n        mixer.update(delta);\n        this._saveBones(mesh);\n        if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n          if (!objects.sortedBonesData) objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n          this._animatePMXMesh(mesh, objects.sortedBonesData, ikSolver && this.enabled.ik ? ikSolver : null, grantSolver && this.enabled.grant ? grantSolver : null);\n        } else {\n          if (ikSolver && this.enabled.ik) {\n            mesh.updateMatrixWorld(true);\n            ikSolver.update();\n          }\n          if (grantSolver && this.enabled.grant) {\n            grantSolver.update();\n          }\n        }\n      }\n      if (looped === true && this.enabled.physics) {\n        if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\n        objects.looped = false;\n      }\n      if (physics && this.enabled.physics && !this.sharedPhysics) {\n        this.onBeforePhysics(mesh);\n        physics.update(delta);\n      }\n    }\n    // Sort bones in order by 1. transformationClass and 2. bone index.\n    // In PMX animation system, bone transformations should be processed\n    // in this order.\n  }, {\n    key: \"_sortBoneDataArray\",\n    value: function _sortBoneDataArray(boneDataArray) {\n      return boneDataArray.sort(function (a, b) {\n        if (a.transformationClass !== b.transformationClass) {\n          return a.transformationClass - b.transformationClass;\n        } else {\n          return a.index - b.index;\n        }\n      });\n    }\n    // PMX Animation system is a bit too complex and doesn't great match to\n    // Three.js Animation system. This method attempts to simulate it as much as\n    // possible but doesn't perfectly simulate.\n    // This method is more costly than the regular one so\n    // you are recommended to set constructor parameter \"pmxAnimation: true\"\n    // only if your PMX model animation doesn't work well.\n    // If you need better method you would be required to write your own.\n  }, {\n    key: \"_animatePMXMesh\",\n    value: function _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n      _quaternionIndex = 0;\n      _grantResultMap.clear();\n      for (var i = 0, il = sortedBonesData.length; i < il; i++) {\n        updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver);\n      }\n      mesh.updateMatrixWorld(true);\n      return this;\n    }\n  }, {\n    key: \"_animateCamera\",\n    value: function _animateCamera(camera, delta) {\n      var mixer = this.objects.get(camera).mixer;\n      if (mixer && this.enabled.cameraAnimation) {\n        mixer.update(delta);\n        camera.updateProjectionMatrix();\n        camera.up.set(0, 1, 0);\n        camera.up.applyQuaternion(camera.quaternion);\n        camera.lookAt(this.cameraTarget.position);\n      }\n    }\n  }, {\n    key: \"_optimizeIK\",\n    value: function _optimizeIK(mesh, physicsEnabled) {\n      var iks = mesh.geometry.userData.MMD.iks;\n      var bones = mesh.geometry.userData.MMD.bones;\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        var links = ik.links;\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          var link = links[j];\n          if (physicsEnabled === true) {\n            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n          } else {\n            link.enabled = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_createCCDIKSolver\",\n    value: function _createCCDIKSolver(mesh) {\n      if (CCDIKSolver === void 0) {\n        throw new Error(\"THREE.MMDAnimationHelper: Import CCDIKSolver.\");\n      }\n      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n    }\n  }, {\n    key: \"_createMMDPhysics\",\n    value: function _createMMDPhysics(mesh, params) {\n      if (MMDPhysics === void 0) {\n        throw new Error(\"THREE.MMDPhysics: Import MMDPhysics.\");\n      }\n      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n    }\n    /*\n     * Detects the longest duration and then sets it to them to sync.\n     * TODO: Not to access private properties ( ._actions and ._clip )\n     */\n  }, {\n    key: \"_syncDuration\",\n    value: function _syncDuration() {\n      var max = 0;\n      var objects = this.objects;\n      var meshes = this.meshes;\n      var camera = this.camera;\n      var audioManager = this.audioManager;\n      for (var i = 0, il = meshes.length; i < il; i++) {\n        var mixer = this.objects.get(meshes[i]).mixer;\n        if (mixer === void 0) continue;\n        for (var j = 0; j < mixer._actions.length; j++) {\n          var clip = mixer._actions[j]._clip;\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n      if (camera !== null) {\n        var _mixer = this.objects.get(camera).mixer;\n        if (_mixer !== void 0) {\n          for (var _i2 = 0, _il2 = _mixer._actions.length; _i2 < _il2; _i2++) {\n            var _clip = _mixer._actions[_i2]._clip;\n            if (!objects.has(_clip)) {\n              objects.set(_clip, {\n                duration: _clip.duration\n              });\n            }\n            max = Math.max(max, objects.get(_clip).duration);\n          }\n        }\n      }\n      if (audioManager !== null) {\n        max = Math.max(max, objects.get(audioManager).duration);\n      }\n      max += this.configuration.afterglow;\n      for (var _i3 = 0, _il3 = this.meshes.length; _i3 < _il3; _i3++) {\n        var _mixer2 = this.objects.get(this.meshes[_i3]).mixer;\n        if (_mixer2 === void 0) continue;\n        for (var _j = 0, jl = _mixer2._actions.length; _j < jl; _j++) {\n          _mixer2._actions[_j]._clip.duration = max;\n        }\n      }\n      if (camera !== null) {\n        var _mixer3 = this.objects.get(camera).mixer;\n        if (_mixer3 !== void 0) {\n          for (var _i4 = 0, _il4 = _mixer3._actions.length; _i4 < _il4; _i4++) {\n            _mixer3._actions[_i4]._clip.duration = max;\n          }\n        }\n      }\n      if (audioManager !== null) {\n        audioManager.duration = max;\n      }\n    }\n    // workaround\n  }, {\n    key: \"_updatePropertyMixersBuffer\",\n    value: function _updatePropertyMixersBuffer(mesh) {\n      var mixer = this.objects.get(mesh).mixer;\n      var propertyMixers = mixer._bindings;\n      var accuIndex = mixer._accuIndex;\n      for (var i = 0, il = propertyMixers.length; i < il; i++) {\n        var propertyMixer = propertyMixers[i];\n        var buffer = propertyMixer.buffer;\n        var stride = propertyMixer.valueSize;\n        var offset = (accuIndex + 1) * stride;\n        propertyMixer.binding.getValue(buffer, offset);\n      }\n    }\n    /*\n     * Avoiding these two issues by restore/save bones before/after mixer animation.\n     *\n     * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n     *    Calculating IK, Grant, and Physics after mixer animation can break\n     *    the cache coherency.\n     *\n     * 2. Applying Grant two or more times without reset the posing breaks model.\n     */\n  }, {\n    key: \"_saveBones\",\n    value: function _saveBones(mesh) {\n      var objects = this.objects.get(mesh);\n      var bones = mesh.skeleton.bones;\n      var backupBones = objects.backupBones;\n      if (backupBones === void 0) {\n        backupBones = new Float32Array(bones.length * 7);\n        objects.backupBones = backupBones;\n      }\n      for (var i = 0, il = bones.length; i < il; i++) {\n        var bone = bones[i];\n        bone.position.toArray(backupBones, i * 7);\n        bone.quaternion.toArray(backupBones, i * 7 + 3);\n      }\n    }\n  }, {\n    key: \"_restoreBones\",\n    value: function _restoreBones(mesh) {\n      var objects = this.objects.get(mesh);\n      var backupBones = objects.backupBones;\n      if (backupBones === void 0) return;\n      var bones = mesh.skeleton.bones;\n      for (var i = 0, il = bones.length; i < il; i++) {\n        var bone = bones[i];\n        bone.position.fromArray(backupBones, i * 7);\n        bone.quaternion.fromArray(backupBones, i * 7 + 3);\n      }\n    }\n    // experimental\n  }, {\n    key: \"_getMasterPhysics\",\n    value: function _getMasterPhysics() {\n      if (this.masterPhysics !== null) return this.masterPhysics;\n      for (var i = 0, il = this.meshes.length; i < il; i++) {\n        var physics = this.meshes[i].physics;\n        if (physics !== void 0 && physics !== null) {\n          this.masterPhysics = physics;\n          return this.masterPhysics;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_updateSharedPhysics\",\n    value: function _updateSharedPhysics(delta) {\n      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\n      var physics = this._getMasterPhysics();\n      if (physics === null) return;\n      for (var i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n        if (p !== null && p !== void 0) {\n          p.updateRigidBodies();\n        }\n      }\n      physics.stepSimulation(delta);\n      for (var _i5 = 0, _il5 = this.meshes.length; _i5 < _il5; _i5++) {\n        var _p = this.meshes[_i5].physics;\n        if (_p !== null && _p !== void 0) {\n          _p.updateBones();\n        }\n      }\n    }\n  }]);\n  return MMDAnimationHelper;\n}();\nvar _quaternions = [];\nvar _quaternionIndex = 0;\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion());\n  }\n  return _quaternions[_quaternionIndex++];\n}\nvar _grantResultMap = /* @__PURE__ */new Map();\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  var bones = mesh.skeleton.bones;\n  var bonesData = mesh.geometry.userData.MMD.bones;\n  var boneData = bonesData[boneIndex];\n  var bone = bones[boneIndex];\n  if (_grantResultMap.has(boneIndex)) return;\n  var quaternion = getQuaternion();\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion));\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    var parentIndex = boneData.grant.parentIndex;\n    var ratio = boneData.grant.ratio;\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver);\n    }\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio);\n  }\n  if (ikSolver && boneData.ik) {\n    mesh.updateMatrixWorld(true);\n    ikSolver.updateOne(boneData.ik);\n    var links = boneData.ik.links;\n    for (var i = 0, il = links.length; i < il; i++) {\n      var link = links[i];\n      if (link.enabled === false) continue;\n      var linkIndex = link.index;\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion));\n      }\n    }\n  }\n  quaternion.copy(bone.quaternion);\n}\nvar AudioManager = /*#__PURE__*/function () {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  function AudioManager(audio) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, AudioManager);\n    this.audio = audio;\n    this.elapsedTime = 0;\n    this.currentTime = 0;\n    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n  _createClass(AudioManager, [{\n    key: \"control\",\n    value: function control(delta) {\n      this.elapsed += delta;\n      this.currentTime += delta;\n      if (this._shouldStopAudio()) this.audio.stop();\n      if (this._shouldStartAudio()) this.audio.play();\n      return this;\n    }\n    // private methods\n  }, {\n    key: \"_shouldStartAudio\",\n    value: function _shouldStartAudio() {\n      if (this.audio.isPlaying) return false;\n      while (this.currentTime >= this.duration) {\n        this.currentTime -= this.duration;\n      }\n      if (this.currentTime < this.delayTime) return false;\n      if (this.currentTime - this.delayTime > this.audioDuration) return false;\n      return true;\n    }\n  }, {\n    key: \"_shouldStopAudio\",\n    value: function _shouldStopAudio() {\n      return this.audio.isPlaying && this.currentTime >= this.duration;\n    }\n  }]);\n  return AudioManager;\n}();\nvar _q = new Quaternion();\nvar GrantSolver = /*#__PURE__*/function () {\n  function GrantSolver(mesh) {\n    var grants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _classCallCheck(this, GrantSolver);\n    this.mesh = mesh;\n    this.grants = grants;\n  }\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n  _createClass(GrantSolver, [{\n    key: \"update\",\n    value: function update() {\n      var grants = this.grants;\n      for (var i = 0, il = grants.length; i < il; i++) {\n        this.updateOne(grants[i]);\n      }\n      return this;\n    }\n    /**\n     * Solve a grant bone\n     * @param {Object} grant - grant parameter\n     * @return {GrantSolver}\n     */\n  }, {\n    key: \"updateOne\",\n    value: function updateOne(grant) {\n      var bones = this.mesh.skeleton.bones;\n      var bone = bones[grant.index];\n      var parentBone = bones[grant.parentIndex];\n      if (grant.isLocal) {\n        if (grant.affectPosition) ;\n        if (grant.affectRotation) ;\n      } else {\n        if (grant.affectPosition) ;\n        if (grant.affectRotation) {\n          this.addGrantRotation(bone, parentBone.quaternion, grant.ratio);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"addGrantRotation\",\n    value: function addGrantRotation(bone, q, ratio) {\n      _q.set(0, 0, 0, 1);\n      _q.slerp(q, ratio);\n      bone.quaternion.multiply(_q);\n      return this;\n    }\n  }]);\n  return GrantSolver;\n}();\nexport { MMDAnimationHelper };\n//# sourceMappingURL=MMDAnimationHelper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}