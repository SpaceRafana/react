{"ast":null,"code":"import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nvar boundingBox = /* @__PURE__ */new Box3();\nvar triangle = /* @__PURE__ */new ExtendedTriangle();\nvar triangle2 = /* @__PURE__ */new ExtendedTriangle();\nvar invertedMat = /* @__PURE__ */new Matrix4();\nvar obb = /* @__PURE__ */new OrientedBox();\nvar obb2 = /* @__PURE__ */new OrientedBox();\nfunction intersectsGeometry_indirect(bvh, root, otherGeometry, geometryToBvh) {\n  BufferStack.setBuffer(bvh._roots[root]);\n  var result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n  BufferStack.clearBuffer();\n  return result;\n}\nfunction _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh) {\n  var cachedObb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var float32Array = BufferStack.float32Array,\n    uint16Array = BufferStack.uint16Array,\n    uint32Array = BufferStack.uint32Array;\n  var nodeIndex16 = nodeIndex32 * 2;\n  if (cachedObb === null) {\n    if (!otherGeometry.boundingBox) {\n      otherGeometry.computeBoundingBox();\n    }\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    cachedObb = obb;\n  }\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    var thisGeometry = bvh.geometry;\n    var thisIndex = thisGeometry.index;\n    var thisPos = thisGeometry.attributes.position;\n    var index = otherGeometry.index;\n    var pos = otherGeometry.attributes.position;\n    var offset = OFFSET(nodeIndex32, uint32Array);\n    var count = COUNT(nodeIndex16, uint16Array);\n\n    // get the inverse of the geometry matrix so we can transform our triangles into the\n    // geometry space we're trying to test. We assume there are fewer triangles being checked\n    // here.\n    invertedMat.copy(geometryToBvh).invert();\n    if (otherGeometry.boundsTree) {\n      // if there's a bounds tree\n      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);\n      obb2.matrix.copy(invertedMat);\n      obb2.needsUpdate = true;\n\n      // TODO: use a triangle iteration function here\n      var res = otherGeometry.boundsTree.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return obb2.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          tri.a.applyMatrix4(geometryToBvh);\n          tri.b.applyMatrix4(geometryToBvh);\n          tri.c.applyMatrix4(geometryToBvh);\n          tri.needsUpdate = true;\n          for (var i = offset, l = count + offset; i < l; i++) {\n            // this triangle needs to be transformed into the current BVH coordinate frame\n            setTriangle(triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);\n            triangle2.needsUpdate = true;\n            if (tri.intersectsTriangle(triangle2)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      });\n      return res;\n    } else {\n      // if we're just dealing with raw geometry\n      for (var i = offset, l = count + offset; i < l; i++) {\n        // this triangle needs to be transformed into the current BVH coordinate frame\n        var ti = bvh.resolveTriangleIndex(i);\n        setTriangle(triangle, 3 * ti, thisIndex, thisPos);\n        triangle.a.applyMatrix4(invertedMat);\n        triangle.b.applyMatrix4(invertedMat);\n        triangle.c.applyMatrix4(invertedMat);\n        triangle.needsUpdate = true;\n        for (var i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\n          setTriangle(triangle2, i2, index, pos);\n          triangle2.needsUpdate = true;\n          if (triangle.intersectsTriangle(triangle2)) {\n            return true;\n          }\n        }\n      }\n    }\n  } else {\n    var left = nodeIndex32 + 8;\n    var right = uint32Array[nodeIndex32 + 6];\n    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);\n    var leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n    if (leftIntersection) return true;\n    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);\n    var rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n    if (rightIntersection) return true;\n    return false;\n  }\n}\nexport { intersectsGeometry_indirect };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}