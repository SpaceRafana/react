{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Line3, Plane, Mesh } from \"three\";\nimport { ConvexGeometry } from \"../geometries/ConvexGeometry.js\";\nvar _v1 = new Vector3();\nvar ConvexObjectBreaker = /*#__PURE__*/function () {\n  function ConvexObjectBreaker() {\n    var minSizeForBreak = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.4;\n    var smallDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    _classCallCheck(this, ConvexObjectBreaker);\n    this.minSizeForBreak = minSizeForBreak;\n    this.smallDelta = smallDelta;\n    this.tempLine1 = new Line3();\n    this.tempPlane1 = new Plane();\n    this.tempPlane2 = new Plane();\n    this.tempPlane_Cut = new Plane();\n    this.tempCM1 = new Vector3();\n    this.tempCM2 = new Vector3();\n    this.tempVector3 = new Vector3();\n    this.tempVector3_2 = new Vector3();\n    this.tempVector3_3 = new Vector3();\n    this.tempVector3_P0 = new Vector3();\n    this.tempVector3_P1 = new Vector3();\n    this.tempVector3_P2 = new Vector3();\n    this.tempVector3_N0 = new Vector3();\n    this.tempVector3_N1 = new Vector3();\n    this.tempVector3_AB = new Vector3();\n    this.tempVector3_CB = new Vector3();\n    this.tempResultObjects = {\n      object1: null,\n      object2: null\n    };\n    this.segments = [];\n    var n = 30 * 30;\n    for (var i = 0; i < n; i++) this.segments[i] = false;\n  }\n  _createClass(ConvexObjectBreaker, [{\n    key: \"prepareBreakableObject\",\n    value: function prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n      var userData = object.userData;\n      userData.mass = mass;\n      userData.velocity = velocity.clone();\n      userData.angularVelocity = angularVelocity.clone();\n      userData.breakable = breakable;\n    }\n    /*\n     * @param {int} maxRadialIterations Iterations for radial cuts.\n     * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n     *\n     * Returns the array of pieces\n     */\n  }, {\n    key: \"subdivideByImpact\",\n    value: function subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n      var debris = [];\n      var tempPlane1 = this.tempPlane1;\n      var tempPlane2 = this.tempPlane2;\n      this.tempVector3.addVectors(pointOfImpact, normal);\n      tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n      var maxTotalIterations = maxRandomIterations + maxRadialIterations;\n      var scope = this;\n      function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n        if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n          debris.push(subObject);\n          return;\n        }\n        var angle = Math.PI;\n        if (numIterations === 0) {\n          tempPlane2.normal.copy(tempPlane1.normal);\n          tempPlane2.constant = tempPlane1.constant;\n        } else {\n          if (numIterations <= maxRadialIterations) {\n            angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;\n            scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n            tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n          } else {\n            angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;\n            scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n            scope.tempVector3_3.copy(normal).add(subObject.position);\n            tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n          }\n        }\n        scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n        var obj1 = scope.tempResultObjects.object1;\n        var obj2 = scope.tempResultObjects.object2;\n        if (obj1) {\n          subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n        }\n        if (obj2) {\n          subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n        }\n      }\n      subdivideRadial(object, 0, 2 * Math.PI, 0);\n      return debris;\n    }\n  }, {\n    key: \"cutByPlane\",\n    value: function cutByPlane(object, plane, output) {\n      var geometry = object.geometry;\n      var coords = geometry.attributes.position.array;\n      var normals = geometry.attributes.normal.array;\n      var numPoints = coords.length / 3;\n      var numFaces = numPoints / 3;\n      var indices = geometry.getIndex();\n      if (indices) {\n        indices = indices.array;\n        numFaces = indices.length / 3;\n      }\n      function getVertexIndex(faceIdx, vert) {\n        var idx = faceIdx * 3 + vert;\n        return indices ? indices[idx] : idx;\n      }\n      var points1 = [];\n      var points2 = [];\n      var delta = this.smallDelta;\n      var numPointPairs = numPoints * numPoints;\n      for (var i = 0; i < numPointPairs; i++) this.segments[i] = false;\n      var p0 = this.tempVector3_P0;\n      var p1 = this.tempVector3_P1;\n      var n0 = this.tempVector3_N0;\n      var n1 = this.tempVector3_N1;\n      for (var _i = 0; _i < numFaces - 1; _i++) {\n        var a1 = getVertexIndex(_i, 0);\n        var b1 = getVertexIndex(_i, 1);\n        var c1 = getVertexIndex(_i, 2);\n        n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n        for (var j = _i + 1; j < numFaces; j++) {\n          var a2 = getVertexIndex(j, 0);\n          var b2 = getVertexIndex(j, 1);\n          var c2 = getVertexIndex(j, 2);\n          n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n          var coplanar = 1 - n0.dot(n1) < delta;\n          if (coplanar) {\n            if (a1 === a2 || a1 === b2 || a1 === c2) {\n              if (b1 === a2 || b1 === b2 || b1 === c2) {\n                this.segments[a1 * numPoints + b1] = true;\n                this.segments[b1 * numPoints + a1] = true;\n              } else {\n                this.segments[c1 * numPoints + a1] = true;\n                this.segments[a1 * numPoints + c1] = true;\n              }\n            } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[c1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + c1] = true;\n            }\n          }\n        }\n      }\n      var localPlane = this.tempPlane_Cut;\n      object.updateMatrix();\n      ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);\n      for (var _i2 = 0; _i2 < numFaces; _i2++) {\n        var va = getVertexIndex(_i2, 0);\n        var vb = getVertexIndex(_i2, 1);\n        var vc = getVertexIndex(_i2, 2);\n        for (var segment = 0; segment < 3; segment++) {\n          var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n          var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n          var segmentState = this.segments[i0 * numPoints + i1];\n          if (segmentState) continue;\n          this.segments[i0 * numPoints + i1] = true;\n          this.segments[i1 * numPoints + i0] = true;\n          p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n          p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);\n          var mark0 = 0;\n          var d = localPlane.distanceToPoint(p0);\n          if (d > delta) {\n            mark0 = 2;\n            points2.push(p0.clone());\n          } else if (d < -delta) {\n            mark0 = 1;\n            points1.push(p0.clone());\n          } else {\n            mark0 = 3;\n            points1.push(p0.clone());\n            points2.push(p0.clone());\n          }\n          var mark1 = 0;\n          d = localPlane.distanceToPoint(p1);\n          if (d > delta) {\n            mark1 = 2;\n            points2.push(p1.clone());\n          } else if (d < -delta) {\n            mark1 = 1;\n            points1.push(p1.clone());\n          } else {\n            mark1 = 3;\n            points1.push(p1.clone());\n            points2.push(p1.clone());\n          }\n          if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n            this.tempLine1.start.copy(p0);\n            this.tempLine1.end.copy(p1);\n            var intersection = new Vector3();\n            intersection = localPlane.intersectLine(this.tempLine1, intersection);\n            if (intersection === null) {\n              console.error(\"Internal error: segment does not intersect plane.\");\n              output.segmentedObject1 = null;\n              output.segmentedObject2 = null;\n              return 0;\n            }\n            points1.push(intersection);\n            points2.push(intersection.clone());\n          }\n        }\n      }\n      var newMass = object.userData.mass * 0.5;\n      this.tempCM1.set(0, 0, 0);\n      var radius1 = 0;\n      var numPoints1 = points1.length;\n      if (numPoints1 > 0) {\n        for (var _i3 = 0; _i3 < numPoints1; _i3++) this.tempCM1.add(points1[_i3]);\n        this.tempCM1.divideScalar(numPoints1);\n        for (var _i4 = 0; _i4 < numPoints1; _i4++) {\n          var p = points1[_i4];\n          p.sub(this.tempCM1);\n          radius1 = Math.max(radius1, p.x, p.y, p.z);\n        }\n        this.tempCM1.add(object.position);\n      }\n      this.tempCM2.set(0, 0, 0);\n      var radius2 = 0;\n      var numPoints2 = points2.length;\n      if (numPoints2 > 0) {\n        for (var _i5 = 0; _i5 < numPoints2; _i5++) this.tempCM2.add(points2[_i5]);\n        this.tempCM2.divideScalar(numPoints2);\n        for (var _i6 = 0; _i6 < numPoints2; _i6++) {\n          var _p = points2[_i6];\n          _p.sub(this.tempCM2);\n          radius2 = Math.max(radius2, _p.x, _p.y, _p.z);\n        }\n        this.tempCM2.add(object.position);\n      }\n      var object1 = null;\n      var object2 = null;\n      var numObjects = 0;\n      if (numPoints1 > 4) {\n        object1 = new Mesh(new ConvexGeometry(points1), object.material);\n        object1.position.copy(this.tempCM1);\n        object1.quaternion.copy(object.quaternion);\n        this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n        numObjects++;\n      }\n      if (numPoints2 > 4) {\n        object2 = new Mesh(new ConvexGeometry(points2), object.material);\n        object2.position.copy(this.tempCM2);\n        object2.quaternion.copy(object.quaternion);\n        this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n        numObjects++;\n      }\n      output.object1 = object1;\n      output.object2 = object2;\n      return numObjects;\n    }\n  }], [{\n    key: \"transformFreeVector\",\n    value: function transformFreeVector(v, m) {\n      var x = v.x,\n        y = v.y,\n        z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[4] * y + e[8] * z;\n      v.y = e[1] * x + e[5] * y + e[9] * z;\n      v.z = e[2] * x + e[6] * y + e[10] * z;\n      return v;\n    }\n  }, {\n    key: \"transformFreeVectorInverse\",\n    value: function transformFreeVectorInverse(v, m) {\n      var x = v.x,\n        y = v.y,\n        z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[1] * y + e[2] * z;\n      v.y = e[4] * x + e[5] * y + e[6] * z;\n      v.z = e[8] * x + e[9] * y + e[10] * z;\n      return v;\n    }\n  }, {\n    key: \"transformTiedVectorInverse\",\n    value: function transformTiedVectorInverse(v, m) {\n      var x = v.x,\n        y = v.y,\n        z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n      v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n      v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n      return v;\n    }\n  }, {\n    key: \"transformPlaneToLocalSpace\",\n    value: function transformPlaneToLocalSpace(plane, m, resultPlane) {\n      resultPlane.normal.copy(plane.normal);\n      resultPlane.constant = plane.constant;\n      var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m);\n      ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);\n      resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n    }\n  }]);\n  return ConvexObjectBreaker;\n}();\nexport { ConvexObjectBreaker };\n//# sourceMappingURL=ConvexObjectBreaker.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}