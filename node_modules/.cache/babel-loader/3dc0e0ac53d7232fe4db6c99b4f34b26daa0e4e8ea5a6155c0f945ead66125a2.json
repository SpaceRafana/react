{"ast":null,"code":"import { Material, ShaderMaterial, NoColorSpace, LinearSRGBColorSpace } from 'three';\nimport { getNodeChildren, getCacheKey } from '../core/NodeUtils.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { output, diffuseColor } from '../core/PropertyNode.js';\nimport { materialNormal } from '../accessors/ExtendedMaterialNode.js';\nimport { materialAlphaTest, materialColor, materialOpacity, materialEmissive } from '../accessors/MaterialNode.js';\nimport { modelViewProjection } from '../accessors/ModelViewProjectionNode.js';\nimport { transformedNormalView } from '../accessors/NormalNode.js';\nimport { instance } from '../accessors/InstanceNode.js';\nimport { positionLocal, positionView } from '../accessors/PositionNode.js';\nimport { skinning } from '../accessors/SkinningNode.js';\nimport { morph } from '../accessors/MorphNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { cubeTexture } from '../accessors/CubeTextureNode.js';\nimport { lightsWithoutWrap } from '../lighting/LightsNode.js';\nimport { mix, dFdx, dFdy } from '../math/MathNode.js';\nimport { float, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport AONode from '../lighting/AONode.js';\nimport { lightingContext } from '../lighting/LightingContextNode.js';\nimport EnvironmentNode from '../lighting/EnvironmentNode.js';\nconst NodeMaterials = new Map();\nclass NodeMaterial extends ShaderMaterial {\n  constructor() {\n    super();\n    this.isNodeMaterial = true;\n    this.type = this.constructor.type;\n    this.forceSinglePass = false;\n    this.unlit = this.constructor === NodeMaterial.prototype.constructor; // Extended materials are not unlit by default\n\n    this.fog = true;\n    this.lights = true;\n    this.normals = true;\n    this.colorSpace = true;\n    this.lightsNode = null;\n    this.envNode = null;\n    this.colorNode = null;\n    this.normalNode = null;\n    this.opacityNode = null;\n    this.backdropNode = null;\n    this.backdropAlphaNode = null;\n    this.alphaTestNode = null;\n    this.positionNode = null;\n    this.outputNode = null; // @TODO: Rename to fragmentNode\n    this.vertexNode = null;\n  }\n  customProgramCacheKey() {\n    return this.type + getCacheKey(this);\n  }\n  build(builder) {\n    this.setup(builder);\n  }\n  setup(builder) {\n    // < VERTEX STAGE >\n\n    builder.addStack();\n    builder.stack.outputNode = this.setupPosition(builder);\n    builder.addFlow('vertex', builder.removeStack());\n\n    // < FRAGMENT STAGE >\n\n    builder.addStack();\n    let outputNode;\n    if (this.unlit === false) {\n      if (this.normals === true) this.setupNormal(builder);\n      this.setupDiffuseColor(builder);\n      this.setupVariants(builder);\n      const outgoingLightNode = this.setupLighting(builder);\n      outputNode = this.setupOutput(builder, vec4(outgoingLightNode, diffuseColor.a));\n\n      // OUTPUT NODE\n\n      builder.stack.assign(output, outputNode);\n\n      //\n\n      if (this.outputNode !== null) outputNode = this.outputNode;\n    } else {\n      outputNode = this.setupOutput(builder, this.outputNode || vec4(0, 0, 0, 1));\n    }\n    builder.stack.outputNode = outputNode;\n    builder.addFlow('fragment', builder.removeStack());\n  }\n  setupPosition(builder) {\n    const object = builder.object;\n    const geometry = object.geometry;\n    builder.addStack();\n    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {\n      builder.stack.add(morph(object));\n    }\n    if (object.isSkinnedMesh === true) {\n      builder.stack.add(skinning(object));\n    }\n    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable('instance') === true) {\n      builder.stack.add(instance(object));\n    }\n    if (this.positionNode !== null) {\n      builder.stack.assign(positionLocal, this.positionNode);\n    }\n    builder.context.vertex = builder.removeStack();\n    return this.vertexNode || modelViewProjection();\n  }\n  setupDiffuseColor({\n    stack,\n    geometry\n  }) {\n    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;\n\n    // VERTEX COLORS\n\n    if (this.vertexColors === true && geometry.hasAttribute('color')) {\n      colorNode = vec4(colorNode.xyz.mul(attribute('color')), colorNode.a);\n    }\n\n    // COLOR\n\n    stack.assign(diffuseColor, colorNode);\n\n    // OPACITY\n\n    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;\n    stack.assign(diffuseColor.a, diffuseColor.a.mul(opacityNode));\n\n    // ALPHA TEST\n\n    if (this.alphaTestNode !== null || this.alphaTest > 0) {\n      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;\n      stack.add(diffuseColor.a.lessThanEqual(alphaTestNode).discard());\n    }\n  }\n  setupVariants( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupNormal({\n    stack\n  }) {\n    // NORMAL VIEW\n\n    if (this.flatShading === true) {\n      const fdx = dFdx(positionView);\n      const fdy = dFdy(positionView);\n      const normalNode = fdx.cross(fdy).normalize();\n      stack.assign(transformedNormalView, normalNode);\n    } else {\n      const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;\n      stack.assign(transformedNormalView, normalNode);\n    }\n  }\n  getEnvNode(builder) {\n    let node = null;\n    if (this.envNode) {\n      node = this.envNode;\n    } else if (this.envMap) {\n      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);\n    } else if (builder.environmentNode) {\n      node = builder.environmentNode;\n    }\n    return node;\n  }\n  setupLights(builder) {\n    const envNode = this.getEnvNode(builder);\n\n    //\n\n    const materialLightsNode = [];\n    if (envNode) {\n      materialLightsNode.push(new EnvironmentNode(envNode));\n    }\n    if (builder.material.aoMap) {\n      materialLightsNode.push(new AONode(texture(builder.material.aoMap)));\n    }\n    let lightsNode = this.lightsNode || builder.lightsNode;\n    if (materialLightsNode.length > 0) {\n      lightsNode = lightsWithoutWrap([...lightsNode.lightNodes, ...materialLightsNode]);\n    }\n    return lightsNode;\n  }\n  setupLightingModel( /*builder*/\n  ) {\n\n    // Interface function.\n  }\n  setupLighting(builder) {\n    const {\n      material\n    } = builder;\n    const {\n      backdropNode,\n      backdropAlphaNode,\n      emissiveNode\n    } = this;\n\n    // OUTGOING LIGHT\n\n    const lights = this.lights === true || this.lightsNode !== null;\n    const lightsNode = lights ? this.setupLights(builder) : null;\n    let outgoingLightNode = diffuseColor.rgb;\n    if (lightsNode && lightsNode.hasLight !== false) {\n      const lightingModelNode = this.setupLightingModel(builder);\n      outgoingLightNode = lightingContext(lightsNode, lightingModelNode, backdropNode, backdropAlphaNode);\n    } else if (backdropNode !== null) {\n      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);\n    }\n\n    // EMISSIVE\n\n    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {\n      outgoingLightNode = outgoingLightNode.add(vec3(emissiveNode ? emissiveNode : materialEmissive));\n    }\n    return outgoingLightNode;\n  }\n  setupOutput(builder, outputNode) {\n    const renderer = builder.renderer;\n\n    // TONE MAPPING\n\n    const toneMappingNode = builder.toneMappingNode;\n    if (toneMappingNode) {\n      outputNode = vec4(toneMappingNode.context({\n        color: outputNode.rgb\n      }), outputNode.a);\n    }\n\n    // FOG\n\n    if (this.fog === true) {\n      const fogNode = builder.fogNode;\n      if (fogNode) outputNode = vec4(fogNode.mixAssign(outputNode.rgb), outputNode.a);\n    }\n\n    // ENCODING\n\n    if (this.colorSpace === true) {\n      const renderTarget = renderer.getRenderTarget();\n      let outputColorSpace;\n      if (renderTarget !== null) {\n        if (Array.isArray(renderTarget.texture)) {\n          outputColorSpace = renderTarget.texture[0].colorSpace;\n        } else {\n          outputColorSpace = renderTarget.texture.colorSpace;\n        }\n      } else {\n        outputColorSpace = renderer.outputColorSpace;\n      }\n      if (outputColorSpace !== LinearSRGBColorSpace && outputColorSpace !== NoColorSpace) {\n        outputNode = outputNode.linearToColorSpace(outputColorSpace);\n      }\n    }\n    return outputNode;\n  }\n  setDefaultValues(material) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n\n    for (const property in material) {\n      const value = material[property];\n      if (this[property] === undefined) {\n        this[property] = value;\n        if (value && value.clone) this[property] = value.clone();\n      }\n    }\n    Object.assign(this.defines, material.defines);\n    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);\n    for (const key in descriptors) {\n      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined && descriptors[key].get !== undefined) {\n        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeChildren = getNodeChildren(this);\n    data.inputNodes = {};\n    for (const {\n      property,\n      childNode\n    } of nodeChildren) {\n      data.inputNodes[property] = childNode.toJSON(meta).uuid;\n    }\n\n    // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n    return data;\n  }\n  copy(source) {\n    this.lightsNode = source.lightsNode;\n    this.envNode = source.envNode;\n    this.colorNode = source.colorNode;\n    this.normalNode = source.normalNode;\n    this.opacityNode = source.opacityNode;\n    this.backdropNode = source.backdropNode;\n    this.backdropAlphaNode = source.backdropAlphaNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.positionNode = source.positionNode;\n    this.outputNode = source.outputNode;\n    this.vertexNode = source.vertexNode;\n    return super.copy(source);\n  }\n  static fromMaterial(material) {\n    if (material.isNodeMaterial === true) {\n      // is already a node material\n\n      return material;\n    }\n    const type = material.type.replace('Material', 'NodeMaterial');\n    const nodeMaterial = createNodeMaterialFromType(type);\n    if (nodeMaterial === undefined) {\n      throw new Error(`NodeMaterial: Material \"${material.type}\" is not compatible.`);\n    }\n    for (const key in material) {\n      nodeMaterial[key] = material[key];\n    }\n    return nodeMaterial;\n  }\n}\nexport default NodeMaterial;\nexport function addNodeMaterial(type, nodeMaterial) {\n  if (typeof nodeMaterial !== 'function' || !type) throw new Error(`Node material ${type} is not a class`);\n  if (NodeMaterials.has(type)) throw new Error(`Redefinition of node material ${type}`);\n  NodeMaterials.set(type, nodeMaterial);\n  nodeMaterial.type = type;\n}\nexport function createNodeMaterialFromType(type) {\n  const Material = NodeMaterials.get(type);\n  if (Material !== undefined) {\n    return new Material();\n  }\n}\naddNodeMaterial('NodeMaterial', NodeMaterial);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}