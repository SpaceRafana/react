{"ast":null,"code":"import _toConsumableArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _wrapNativeSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _get from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _assertThisInitialized from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _ref = function () {\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeGlobal$1 = freeGlobal;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal$1 || freeSelf || Function(\"return this\")();\n    var root$1 = root;\n    var Symbol$1 = root$1.Symbol;\n    var Symbol$2 = Symbol$1;\n    var objectProto$j = Object.prototype;\n    var hasOwnProperty$g = objectProto$j.hasOwnProperty;\n    var nativeObjectToString$1 = objectProto$j.toString;\n    var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty$g.call(value, symToStringTag$1),\n        tag = value[symToStringTag$1];\n      try {\n        value[symToStringTag$1] = void 0;\n        var unmasked = true;\n      } catch (e) {}\n      var result = nativeObjectToString$1.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag$1] = tag;\n        } else {\n          delete value[symToStringTag$1];\n        }\n      }\n      return result;\n    }\n    var objectProto$i = Object.prototype;\n    var nativeObjectToString = objectProto$i.toString;\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n    var nullTag = \"[object Null]\",\n      undefinedTag = \"[object Undefined]\";\n    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === void 0 ? undefinedTag : nullTag;\n      }\n      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n    }\n    function isObjectLike(value) {\n      return value != null && typeof value == \"object\";\n    }\n    var symbolTag$3 = \"[object Symbol]\";\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;\n    }\n    function arrayMap(array, iteratee) {\n      var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n      while (++index < length) {\n        result[index] = iteratee(array[index], index, array);\n      }\n      return result;\n    }\n    var isArray = Array.isArray;\n    var isArray$1 = isArray;\n    var INFINITY$3 = 1 / 0;\n    var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0,\n      symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;\n    function baseToString(value) {\n      if (typeof value == \"string\") {\n        return value;\n      }\n      if (isArray$1(value)) {\n        return arrayMap(value, baseToString) + \"\";\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : \"\";\n      }\n      var result = value + \"\";\n      return result == \"0\" && 1 / value == -INFINITY$3 ? \"-0\" : result;\n    }\n    var reWhitespace = /\\s/;\n    function trimmedEndIndex(string) {\n      var index = string.length;\n      while (index-- && reWhitespace.test(string.charAt(index))) {}\n      return index;\n    }\n    var reTrimStart = /^\\s+/;\n    function baseTrim(string) {\n      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == \"object\" || type == \"function\");\n    }\n    var NAN = 0 / 0;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    var INFINITY$2 = 1 / 0,\n      MAX_INTEGER = 17976931348623157e292;\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY$2 || value === -INFINITY$2) {\n        var sign = value < 0 ? -1 : 1;\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n    function toInteger(value) {\n      var result = toFinite(value),\n        remainder = result % 1;\n      return result === result ? remainder ? result - remainder : result : 0;\n    }\n    function identity(value) {\n      return value;\n    }\n    var asyncTag = \"[object AsyncFunction]\",\n      funcTag$2 = \"[object Function]\",\n      genTag$1 = \"[object GeneratorFunction]\",\n      proxyTag = \"[object Proxy]\";\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;\n    }\n    var coreJsData = root$1[\"__core-js_shared__\"];\n    var coreJsData$1 = coreJsData;\n    var maskSrcKey = function () {\n      var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || \"\");\n      return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    }();\n    function isMasked(func) {\n      return !!maskSrcKey && maskSrcKey in func;\n    }\n    var funcProto$1 = Function.prototype;\n    var funcToString$1 = funcProto$1.toString;\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString$1.call(func);\n        } catch (e) {}\n        try {\n          return func + \"\";\n        } catch (e) {}\n      }\n      return \"\";\n    }\n    var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    var funcProto = Function.prototype,\n      objectProto$h = Object.prototype;\n    var funcToString = funcProto.toString;\n    var hasOwnProperty$f = objectProto$h.hasOwnProperty;\n    var reIsNative = RegExp(\"^\" + funcToString.call(hasOwnProperty$f).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n    function getValue(object, key) {\n      return object == null ? void 0 : object[key];\n    }\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : void 0;\n    }\n    var WeakMap = getNative(root$1, \"WeakMap\");\n    var WeakMap$1 = WeakMap;\n    var objectCreate = Object.create;\n    var baseCreate = function () {\n      function object() {}\n      return function (proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object();\n        object.prototype = void 0;\n        return result;\n      };\n    }();\n    var baseCreate$1 = baseCreate;\n    function apply(func, thisArg, args) {\n      switch (args.length) {\n        case 0:\n          return func.call(thisArg);\n        case 1:\n          return func.call(thisArg, args[0]);\n        case 2:\n          return func.call(thisArg, args[0], args[1]);\n        case 3:\n          return func.call(thisArg, args[0], args[1], args[2]);\n      }\n      return func.apply(thisArg, args);\n    }\n    function noop() {}\n    function copyArray(source, array) {\n      var index = -1,\n        length = source.length;\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n    var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n    var nativeNow = Date.now;\n    function shortOut(func) {\n      var count = 0,\n        lastCalled = 0;\n      return function () {\n        var stamp = nativeNow(),\n          remaining = HOT_SPAN - (stamp - lastCalled);\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(void 0, arguments);\n      };\n    }\n    function constant(value) {\n      return function () {\n        return value;\n      };\n    }\n    var defineProperty = function () {\n      try {\n        var func = getNative(Object, \"defineProperty\");\n        func({}, \"\", {});\n        return func;\n      } catch (e) {}\n    }();\n    var defineProperty$1 = defineProperty;\n    var baseSetToString = !defineProperty$1 ? identity : function (func, string) {\n      return defineProperty$1(func, \"toString\", {\n        configurable: true,\n        enumerable: false,\n        value: constant(string),\n        writable: true\n      });\n    };\n    var baseSetToString$1 = baseSetToString;\n    var setToString = shortOut(baseSetToString$1);\n    var setToString$1 = setToString;\n    function arrayEach(array, iteratee) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (iteratee(array[index], index, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n    function baseFindIndex(array, predicate, fromIndex, fromRight) {\n      var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n      while (fromRight ? index-- : ++index < length) {\n        if (predicate(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n    function baseIsNaN(value) {\n      return value !== value;\n    }\n    function strictIndexOf(array, value, fromIndex) {\n      var index = fromIndex - 1,\n        length = array.length;\n      while (++index < length) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n    function baseIndexOf(array, value, fromIndex) {\n      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);\n    }\n    function arrayIncludes(array, value) {\n      var length = array == null ? 0 : array.length;\n      return !!length && baseIndexOf(array, value, 0) > -1;\n    }\n    var MAX_SAFE_INTEGER$1 = 9007199254740991;\n    var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER$1 : length;\n      return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n    }\n    function baseAssignValue(object, key, value) {\n      if (key == \"__proto__\" && defineProperty$1) {\n        defineProperty$1(object, key, {\n          configurable: true,\n          enumerable: true,\n          value: value,\n          writable: true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n    function eq(value, other) {\n      return value === other || value !== value && other !== other;\n    }\n    var objectProto$g = Object.prototype;\n    var hasOwnProperty$e = objectProto$g.hasOwnProperty;\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty$e.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {\n        baseAssignValue(object, key, value);\n      }\n    }\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n      var index = -1,\n        length = props.length;\n      while (++index < length) {\n        var key = props[index];\n        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n        if (newValue === void 0) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n    var nativeMax$3 = Math.max;\n    function overRest(func, start, transform) {\n      start = nativeMax$3(start === void 0 ? func.length - 1 : start, 0);\n      return function () {\n        var args = arguments,\n          index = -1,\n          length = nativeMax$3(args.length - start, 0),\n          array = Array(length);\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n    function baseRest(func, start) {\n      return setToString$1(overRest(func, start, identity), func + \"\");\n    }\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    function isLength(value) {\n      return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == \"number\" ? isArrayLike(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n    function createAssigner(assigner) {\n      return baseRest(function (object, sources) {\n        var index = -1,\n          length = sources.length,\n          customizer = length > 1 ? sources[length - 1] : void 0,\n          guard = length > 2 ? sources[2] : void 0;\n        customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : void 0;\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? void 0 : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n    var objectProto$f = Object.prototype;\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n        proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$f;\n      return value === proto;\n    }\n    function baseTimes(n, iteratee) {\n      var index = -1,\n        result = Array(n);\n      while (++index < n) {\n        result[index] = iteratee(index);\n      }\n      return result;\n    }\n    var argsTag$3 = \"[object Arguments]\";\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag$3;\n    }\n    var objectProto$e = Object.prototype;\n    var hasOwnProperty$d = objectProto$e.hasOwnProperty;\n    var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;\n    var isArguments = baseIsArguments(function () {\n      return arguments;\n    }()) ? baseIsArguments : function (value) {\n      return isObjectLike(value) && hasOwnProperty$d.call(value, \"callee\") && !propertyIsEnumerable$1.call(value, \"callee\");\n    };\n    var isArguments$1 = isArguments;\n    function stubFalse() {\n      return false;\n    }\n    var freeExports$2 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n    var freeModule$2 = freeExports$2 && typeof module == \"object\" && module && !module.nodeType && module;\n    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;\n    var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;\n    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;\n    var isBuffer = nativeIsBuffer || stubFalse;\n    var isBuffer$1 = isBuffer;\n    var argsTag$2 = \"[object Arguments]\",\n      arrayTag$2 = \"[object Array]\",\n      boolTag$3 = \"[object Boolean]\",\n      dateTag$3 = \"[object Date]\",\n      errorTag$2 = \"[object Error]\",\n      funcTag$1 = \"[object Function]\",\n      mapTag$6 = \"[object Map]\",\n      numberTag$3 = \"[object Number]\",\n      objectTag$3 = \"[object Object]\",\n      regexpTag$4 = \"[object RegExp]\",\n      setTag$6 = \"[object Set]\",\n      stringTag$4 = \"[object String]\",\n      weakMapTag$2 = \"[object WeakMap]\";\n    var arrayBufferTag$3 = \"[object ArrayBuffer]\",\n      dataViewTag$4 = \"[object DataView]\",\n      float32Tag$2 = \"[object Float32Array]\",\n      float64Tag$2 = \"[object Float64Array]\",\n      int8Tag$2 = \"[object Int8Array]\",\n      int16Tag$2 = \"[object Int16Array]\",\n      int32Tag$2 = \"[object Int32Array]\",\n      uint8Tag$2 = \"[object Uint8Array]\",\n      uint8ClampedTag$2 = \"[object Uint8ClampedArray]\",\n      uint16Tag$2 = \"[object Uint16Array]\",\n      uint32Tag$2 = \"[object Uint32Array]\";\n    var typedArrayTags = {};\n    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;\n    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$4] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n    function baseUnary(func) {\n      return function (value) {\n        return func(value);\n      };\n    }\n    var freeExports$1 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n    var freeModule$1 = freeExports$1 && typeof module == \"object\" && module && !module.nodeType && module;\n    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n    var freeProcess = moduleExports$1 && freeGlobal$1.process;\n    var nodeUtil = function () {\n      try {\n        var types = freeModule$1 && freeModule$1.require && freeModule$1.require(\"util\").types;\n        if (types) {\n          return types;\n        }\n        return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n      } catch (e) {}\n    }();\n    var nodeUtil$1 = nodeUtil;\n    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n    var isTypedArray$1 = isTypedArray;\n    var objectProto$d = Object.prototype;\n    var hasOwnProperty$c = objectProto$d.hasOwnProperty;\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray$1(value),\n        isArg = !isArr && isArguments$1(value),\n        isBuff = !isArr && !isArg && isBuffer$1(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? baseTimes(value.length, String) : [],\n        length = result.length;\n      for (var key in value) {\n        if ((inherited || hasOwnProperty$c.call(value, key)) && !(skipIndexes && (\n        // Safari 9 has enumerable `arguments.length` in strict mode.\n        key == \"length\" ||\n        // Node.js 0.10 has enumerable non-index properties on buffers.\n        isBuff && (key == \"offset\" || key == \"parent\") ||\n        // PhantomJS 2 has enumerable non-index properties on typed arrays.\n        isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") ||\n        // Skip index properties.\n        isIndex(key, length)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function overArg(func, transform) {\n      return function (arg) {\n        return func(transform(arg));\n      };\n    }\n    var nativeKeys = overArg(Object.keys, Object);\n    var nativeKeys$1 = nativeKeys;\n    var objectProto$c = Object.prototype;\n    var hasOwnProperty$b = objectProto$c.hasOwnProperty;\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys$1(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty$b.call(object, key) && key != \"constructor\") {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n    var objectProto$b = Object.prototype;\n    var hasOwnProperty$a = objectProto$b.hasOwnProperty;\n    var assign = createAssigner(function (object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty$a.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n    var assign$1 = assign;\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    var objectProto$a = Object.prototype;\n    var hasOwnProperty$9 = objectProto$a.hasOwnProperty;\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n        result = [];\n      for (var key in object) {\n        if (!(key == \"constructor\" && (isProto || !hasOwnProperty$9.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n    var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/;\n    function isKey(value, object) {\n      if (isArray$1(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n    }\n    var nativeCreate = getNative(Object, \"create\");\n    var nativeCreate$1 = nativeCreate;\n    function hashClear() {\n      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};\n      this.size = 0;\n    }\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    var HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\";\n    var objectProto$9 = Object.prototype;\n    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate$1) {\n        var result = data[key];\n        return result === HASH_UNDEFINED$2 ? void 0 : result;\n      }\n      return hasOwnProperty$8.call(data, key) ? data[key] : void 0;\n    }\n    var objectProto$8 = Object.prototype;\n    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);\n    }\n    var HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;\n      return this;\n    }\n    function Hash(entries) {\n      var index = -1,\n        length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    Hash.prototype.clear = hashClear;\n    Hash.prototype[\"delete\"] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n    var arrayProto = Array.prototype;\n    var splice = arrayProto.splice;\n    function listCacheDelete(key) {\n      var data = this.__data__,\n        index = assocIndexOf(data, key);\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n    function listCacheGet(key) {\n      var data = this.__data__,\n        index = assocIndexOf(data, key);\n      return index < 0 ? void 0 : data[index][1];\n    }\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n        index = assocIndexOf(data, key);\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n    function ListCache(entries) {\n      var index = -1,\n        length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype[\"delete\"] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n    var Map$1 = getNative(root$1, \"Map\");\n    var Map$2 = Map$1;\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        hash: new Hash(),\n        map: new (Map$2 || ListCache)(),\n        string: new Hash()\n      };\n    }\n    function isKeyable(value) {\n      var type = typeof value;\n      return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n    }\n    function getMapData(map2, key) {\n      var data = map2.__data__;\n      return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n    }\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)[\"delete\"](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n        size = data.size;\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n    function MapCache(entries) {\n      var index = -1,\n        length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype[\"delete\"] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n    var FUNC_ERROR_TEXT$1 = \"Expected a function\";\n    function memoize(func, resolver) {\n      if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT$1);\n      }\n      var memoized = function memoized() {\n        var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache)();\n      return memoized;\n    }\n    memoize.Cache = MapCache;\n    var MAX_MEMOIZE_SIZE = 500;\n    function memoizeCapped(func) {\n      var result = memoize(func, function (key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n      var cache = result.cache;\n      return result;\n    }\n    var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    var reEscapeChar = /\\\\(\\\\)?/g;\n    var stringToPath = memoizeCapped(function (string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46) {\n        result.push(\"\");\n      }\n      string.replace(rePropName, function (match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n      });\n      return result;\n    });\n    var stringToPath$1 = stringToPath;\n    function toString(value) {\n      return value == null ? \"\" : baseToString(value);\n    }\n    function castPath(value, object) {\n      if (isArray$1(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath$1(toString(value));\n    }\n    var INFINITY$1 = 1 / 0;\n    function toKey(value) {\n      if (typeof value == \"string\" || isSymbol(value)) {\n        return value;\n      }\n      var result = value + \"\";\n      return result == \"0\" && 1 / value == -INFINITY$1 ? \"-0\" : result;\n    }\n    function baseGet(object, path) {\n      path = castPath(path, object);\n      var index = 0,\n        length = path.length;\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return index && index == length ? object : void 0;\n    }\n    function get(object, path, defaultValue) {\n      var result = object == null ? void 0 : baseGet(object, path);\n      return result === void 0 ? defaultValue : result;\n    }\n    function arrayPush(array, values2) {\n      var index = -1,\n        length = values2.length,\n        offset = array.length;\n      while (++index < length) {\n        array[offset + index] = values2[index];\n      }\n      return array;\n    }\n    var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;\n    function isFlattenable(value) {\n      return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n        length = array.length;\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n    var getPrototype = overArg(Object.getPrototypeOf, Object);\n    var getPrototype$1 = getPrototype;\n    function baseSlice(array, start, end) {\n      var index = -1,\n        length = array.length;\n      if (start < 0) {\n        start = -start > length ? 0 : length + start;\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : end - start >>> 0;\n      start >>>= 0;\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n    function arrayReduce(array, iteratee, accumulator, initAccum) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      if (initAccum && length) {\n        accumulator = array[++index];\n      }\n      while (++index < length) {\n        accumulator = iteratee(accumulator, array[index], index, array);\n      }\n      return accumulator;\n    }\n    function stackClear() {\n      this.__data__ = new ListCache();\n      this.size = 0;\n    }\n    function stackDelete(key) {\n      var data = this.__data__,\n        result = data[\"delete\"](key);\n      this.size = data.size;\n      return result;\n    }\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n    var LARGE_ARRAY_SIZE$2 = 200;\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n    Stack.prototype.clear = stackClear;\n    Stack.prototype[\"delete\"] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n    var freeExports = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n    var freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    var Buffer = moduleExports ? root$1.Buffer : void 0,\n      allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n      buffer.copy(result);\n      return result;\n    }\n    function arrayFilter(array, predicate) {\n      var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n    function stubArray() {\n      return [];\n    }\n    var objectProto$7 = Object.prototype;\n    var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;\n    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;\n    var getSymbols = !nativeGetSymbols$1 ? stubArray : function (object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols$1(object), function (symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n    var getSymbols$1 = getSymbols;\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols$1(source), object);\n    }\n    var nativeGetSymbols = Object.getOwnPropertySymbols;\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols$1(object));\n        object = getPrototype$1(object);\n      }\n      return result;\n    };\n    var getSymbolsIn$1 = getSymbolsIn;\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn$1(source), object);\n    }\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols$1);\n    }\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn$1);\n    }\n    var DataView = getNative(root$1, \"DataView\");\n    var DataView$1 = DataView;\n    var Promise$1 = getNative(root$1, \"Promise\");\n    var Promise$2 = Promise$1;\n    var Set = getNative(root$1, \"Set\");\n    var Set$1 = Set;\n    var mapTag$5 = \"[object Map]\",\n      objectTag$2 = \"[object Object]\",\n      promiseTag = \"[object Promise]\",\n      setTag$5 = \"[object Set]\",\n      weakMapTag$1 = \"[object WeakMap]\";\n    var dataViewTag$3 = \"[object DataView]\";\n    var dataViewCtorString = toSource(DataView$1),\n      mapCtorString = toSource(Map$2),\n      promiseCtorString = toSource(Promise$2),\n      setCtorString = toSource(Set$1),\n      weakMapCtorString = toSource(WeakMap$1);\n    var getTag = baseGetTag;\n    if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$5 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$5 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {\n      getTag = function getTag(value) {\n        var result = baseGetTag(value),\n          Ctor = result == objectTag$2 ? value.constructor : void 0,\n          ctorString = Ctor ? toSource(Ctor) : \"\";\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString:\n              return dataViewTag$3;\n            case mapCtorString:\n              return mapTag$5;\n            case promiseCtorString:\n              return promiseTag;\n            case setCtorString:\n              return setTag$5;\n            case weakMapCtorString:\n              return weakMapTag$1;\n          }\n        }\n        return result;\n      };\n    }\n    var getTag$1 = getTag;\n    var objectProto$6 = Object.prototype;\n    var hasOwnProperty$6 = objectProto$6.hasOwnProperty;\n    function initCloneArray(array) {\n      var length = array.length,\n        result = new array.constructor(length);\n      if (length && typeof array[0] == \"string\" && hasOwnProperty$6.call(array, \"index\")) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n    var Uint8Array = root$1.Uint8Array;\n    var Uint8Array$1 = Uint8Array;\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));\n      return result;\n    }\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n    var reFlags = /\\w*$/;\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0,\n      symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;\n    function cloneSymbol(symbol) {\n      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};\n    }\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n    var boolTag$2 = \"[object Boolean]\",\n      dateTag$2 = \"[object Date]\",\n      mapTag$4 = \"[object Map]\",\n      numberTag$2 = \"[object Number]\",\n      regexpTag$3 = \"[object RegExp]\",\n      setTag$4 = \"[object Set]\",\n      stringTag$3 = \"[object String]\",\n      symbolTag$2 = \"[object Symbol]\";\n    var arrayBufferTag$2 = \"[object ArrayBuffer]\",\n      dataViewTag$2 = \"[object DataView]\",\n      float32Tag$1 = \"[object Float32Array]\",\n      float64Tag$1 = \"[object Float64Array]\",\n      int8Tag$1 = \"[object Int8Array]\",\n      int16Tag$1 = \"[object Int16Array]\",\n      int32Tag$1 = \"[object Int32Array]\",\n      uint8Tag$1 = \"[object Uint8Array]\",\n      uint8ClampedTag$1 = \"[object Uint8ClampedArray]\",\n      uint16Tag$1 = \"[object Uint16Array]\",\n      uint32Tag$1 = \"[object Uint32Array]\";\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag$2:\n          return cloneArrayBuffer(object);\n        case boolTag$2:\n        case dateTag$2:\n          return new Ctor(+object);\n        case dataViewTag$2:\n          return cloneDataView(object, isDeep);\n        case float32Tag$1:\n        case float64Tag$1:\n        case int8Tag$1:\n        case int16Tag$1:\n        case int32Tag$1:\n        case uint8Tag$1:\n        case uint8ClampedTag$1:\n        case uint16Tag$1:\n        case uint32Tag$1:\n          return cloneTypedArray(object, isDeep);\n        case mapTag$4:\n          return new Ctor();\n        case numberTag$2:\n        case stringTag$3:\n          return new Ctor(object);\n        case regexpTag$3:\n          return cloneRegExp(object);\n        case setTag$4:\n          return new Ctor();\n        case symbolTag$2:\n          return cloneSymbol(object);\n      }\n    }\n    function initCloneObject(object) {\n      return typeof object.constructor == \"function\" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};\n    }\n    var mapTag$3 = \"[object Map]\";\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag$1(value) == mapTag$3;\n    }\n    var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n    var isMap$1 = isMap;\n    var setTag$3 = \"[object Set]\";\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag$1(value) == setTag$3;\n    }\n    var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n    var isSet$1 = isSet;\n    var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG$1 = 4;\n    var argsTag$1 = \"[object Arguments]\",\n      arrayTag$1 = \"[object Array]\",\n      boolTag$1 = \"[object Boolean]\",\n      dateTag$1 = \"[object Date]\",\n      errorTag$1 = \"[object Error]\",\n      funcTag = \"[object Function]\",\n      genTag = \"[object GeneratorFunction]\",\n      mapTag$2 = \"[object Map]\",\n      numberTag$1 = \"[object Number]\",\n      objectTag$1 = \"[object Object]\",\n      regexpTag$2 = \"[object RegExp]\",\n      setTag$2 = \"[object Set]\",\n      stringTag$2 = \"[object String]\",\n      symbolTag$1 = \"[object Symbol]\",\n      weakMapTag = \"[object WeakMap]\";\n    var arrayBufferTag$1 = \"[object ArrayBuffer]\",\n      dataViewTag$1 = \"[object DataView]\",\n      float32Tag = \"[object Float32Array]\",\n      float64Tag = \"[object Float64Array]\",\n      int8Tag = \"[object Int8Array]\",\n      int16Tag = \"[object Int16Array]\",\n      int32Tag = \"[object Int32Array]\",\n      uint8Tag = \"[object Uint8Array]\",\n      uint8ClampedTag = \"[object Uint8ClampedArray]\",\n      uint16Tag = \"[object Uint16Array]\",\n      uint32Tag = \"[object Uint32Array]\";\n    var cloneableTags = {};\n    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$2] = cloneableTags[setTag$2] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n        isDeep = bitmask & CLONE_DEEP_FLAG,\n        isFlat = bitmask & CLONE_FLAT_FLAG,\n        isFull = bitmask & CLONE_SYMBOLS_FLAG$1;\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== void 0) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray$1(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag$1(value),\n          isFunc = tag == funcTag || tag == genTag;\n        if (isBuffer$1(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {\n          result = isFlat || isFunc ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      stack || (stack = new Stack());\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n      if (isSet$1(value)) {\n        value.forEach(function (subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap$1(value)) {\n        value.forEach(function (subValue, key2) {\n          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n        });\n      }\n      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;\n      var props = isArr ? void 0 : keysFunc(value);\n      arrayEach(props || value, function (subValue, key2) {\n        if (props) {\n          key2 = subValue;\n          subValue = value[key2];\n        }\n        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n      });\n      return result;\n    }\n    var CLONE_SYMBOLS_FLAG = 4;\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n    function compact(array) {\n      var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n    var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n    function SetCache(values2) {\n      var index = -1,\n        length = values2 == null ? 0 : values2.length;\n      this.__data__ = new MapCache();\n      while (++index < length) {\n        this.add(values2[index]);\n      }\n    }\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n    function arraySome(array, predicate) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function cacheHas(cache, key) {\n      return cache.has(key);\n    }\n    var COMPARE_PARTIAL_FLAG$5 = 1,\n      COMPARE_UNORDERED_FLAG$3 = 2;\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,\n        arrLength = array.length,\n        othLength = other.length;\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n        result = true,\n        seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;\n      stack.set(array, other);\n      stack.set(other, array);\n      while (++index < arrLength) {\n        var arrValue = array[index],\n          othValue = other[index];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== void 0) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        if (seen) {\n          if (!arraySome(other, function (othValue2, othIndex) {\n            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n            result = false;\n            break;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n          result = false;\n          break;\n        }\n      }\n      stack[\"delete\"](array);\n      stack[\"delete\"](other);\n      return result;\n    }\n    function mapToArray(map2) {\n      var index = -1,\n        result = Array(map2.size);\n      map2.forEach(function (value, key) {\n        result[++index] = [key, value];\n      });\n      return result;\n    }\n    function setToArray(set) {\n      var index = -1,\n        result = Array(set.size);\n      set.forEach(function (value) {\n        result[++index] = value;\n      });\n      return result;\n    }\n    var COMPARE_PARTIAL_FLAG$4 = 1,\n      COMPARE_UNORDERED_FLAG$2 = 2;\n    var boolTag = \"[object Boolean]\",\n      dateTag = \"[object Date]\",\n      errorTag = \"[object Error]\",\n      mapTag$1 = \"[object Map]\",\n      numberTag = \"[object Number]\",\n      regexpTag$1 = \"[object RegExp]\",\n      setTag$1 = \"[object Set]\",\n      stringTag$1 = \"[object String]\",\n      symbolTag = \"[object Symbol]\";\n    var arrayBufferTag = \"[object ArrayBuffer]\",\n      dataViewTag = \"[object DataView]\";\n    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n        case arrayBufferTag:\n          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {\n            return false;\n          }\n          return true;\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          return eq(+object, +other);\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n        case regexpTag$1:\n        case stringTag$1:\n          return object == other + \"\";\n        case mapTag$1:\n          var convert = mapToArray;\n        case setTag$1:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;\n          convert || (convert = setToArray);\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG$2;\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack[\"delete\"](object);\n          return result;\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n    var COMPARE_PARTIAL_FLAG$3 = 1;\n    var objectProto$5 = Object.prototype;\n    var hasOwnProperty$5 = objectProto$5.hasOwnProperty;\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,\n        objProps = getAllKeys(object),\n        objLength = objProps.length,\n        othProps = getAllKeys(other),\n        othLength = othProps.length;\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {\n          return false;\n        }\n      }\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n          othValue = other[key];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        }\n        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n          othCtor = other.constructor;\n        if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack[\"delete\"](object);\n      stack[\"delete\"](other);\n      return result;\n    }\n    var COMPARE_PARTIAL_FLAG$2 = 1;\n    var argsTag = \"[object Arguments]\",\n      arrayTag = \"[object Array]\",\n      objectTag = \"[object Object]\";\n    var objectProto$4 = Object.prototype;\n    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray$1(object),\n        othIsArr = isArray$1(other),\n        objTag = objIsArr ? arrayTag : getTag$1(object),\n        othTag = othIsArr ? arrayTag : getTag$1(other);\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n      var objIsObj = objTag == objectTag,\n        othIsObj = othTag == objectTag,\n        isSameTag = objTag == othTag;\n      if (isSameTag && isBuffer$1(object)) {\n        if (!isBuffer$1(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack());\n        return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n        var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, \"__wrapped__\"),\n          othIsWrapped = othIsObj && hasOwnProperty$4.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n          stack || (stack = new Stack());\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack());\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n    var COMPARE_PARTIAL_FLAG$1 = 1,\n      COMPARE_UNORDERED_FLAG$1 = 2;\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n        if (noCustomizer && data[2]) {\n          if (objValue === void 0 && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack();\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n    function getMatchData(object) {\n      var result = keys(object),\n        length = result.length;\n      while (length--) {\n        var key = result[length],\n          value = object[key];\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n    function matchesStrictComparable(key, srcValue) {\n      return function (object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));\n      };\n    }\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function (object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n      var index = -1,\n        length = path.length,\n        result = false;\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$1(object));\n    }\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n    var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function (object) {\n        var objValue = get(object, path);\n        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n    function baseProperty(key) {\n      return function (object) {\n        return object == null ? void 0 : object[key];\n      };\n    }\n    function basePropertyDeep(path) {\n      return function (object) {\n        return baseGet(object, path);\n      };\n    }\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n    function baseIteratee(value) {\n      if (typeof value == \"function\") {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == \"object\") {\n        return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n      }\n      return property(value);\n    }\n    function arrayAggregator(array, setter, iteratee, accumulator) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        var value = array[index];\n        setter(accumulator, value, iteratee(value), array);\n      }\n      return accumulator;\n    }\n    function createBaseFor(fromRight) {\n      return function (object, iteratee, keysFunc) {\n        var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n    var baseFor = createBaseFor();\n    var baseFor$1 = baseFor;\n    function baseForOwn(object, iteratee) {\n      return object && baseFor$1(object, iteratee, keys);\n    }\n    function createBaseEach(eachFunc, fromRight) {\n      return function (collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n          index = fromRight ? length : -1,\n          iterable = Object(collection);\n        while (fromRight ? index-- : ++index < length) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n    var baseEach = createBaseEach(baseForOwn);\n    var baseEach$1 = baseEach;\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach$1(collection, function (value, key, collection2) {\n        setter(accumulator, value, iteratee(value), collection2);\n      });\n      return accumulator;\n    }\n    function createAggregator(setter, initializer) {\n      return function (collection, iteratee) {\n        var func = isArray$1(collection) ? arrayAggregator : baseAggregator,\n          accumulator = initializer ? initializer() : {};\n        return func(collection, setter, baseIteratee(iteratee), accumulator);\n      };\n    }\n    var objectProto$3 = Object.prototype;\n    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n    var defaults = baseRest(function (object, sources) {\n      object = Object(object);\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : void 0;\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n          if (value === void 0 || eq(value, objectProto$3[key]) && !hasOwnProperty$3.call(object, key)) {\n            object[key] = source[key];\n          }\n        }\n      }\n      return object;\n    });\n    var defaults$1 = defaults;\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n    function arrayIncludesWith(array, value, comparator) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (comparator(value, array[index])) {\n          return true;\n        }\n      }\n      return false;\n    }\n    var LARGE_ARRAY_SIZE$1 = 200;\n    function baseDifference(array, values2, iteratee, comparator) {\n      var index = -1,\n        includes2 = arrayIncludes,\n        isCommon = true,\n        length = array.length,\n        result = [],\n        valuesLength = values2.length;\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values2 = arrayMap(values2, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes2 = arrayIncludesWith;\n        isCommon = false;\n      } else if (values2.length >= LARGE_ARRAY_SIZE$1) {\n        includes2 = cacheHas;\n        isCommon = false;\n        values2 = new SetCache(values2);\n      }\n      outer: while (++index < length) {\n        var value = array[index],\n          computed = iteratee == null ? value : iteratee(value);\n        value = comparator || value !== 0 ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values2[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        } else if (!includes2(values2, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n    var difference = baseRest(function (array, values2) {\n      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];\n    });\n    var difference$1 = difference;\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : void 0;\n    }\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = guard || n === void 0 ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = guard || n === void 0 ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n    function castFunction(value) {\n      return typeof value == \"function\" ? value : identity;\n    }\n    function forEach(collection, iteratee) {\n      var func = isArray$1(collection) ? arrayEach : baseEach$1;\n      return func(collection, castFunction(iteratee));\n    }\n    function arrayEvery(array, predicate) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (!predicate(array[index], index, array)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach$1(collection, function (value, index, collection2) {\n        result = !!predicate(value, index, collection2);\n        return result;\n      });\n      return result;\n    }\n    function every(collection, predicate, guard) {\n      var func = isArray$1(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = void 0;\n      }\n      return func(collection, baseIteratee(predicate));\n    }\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach$1(collection, function (value, index, collection2) {\n        if (predicate(value, index, collection2)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n    function filter(collection, predicate) {\n      var func = isArray$1(collection) ? arrayFilter : baseFilter;\n      return func(collection, baseIteratee(predicate));\n    }\n    function createFind(findIndexFunc) {\n      return function (collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = baseIteratee(predicate);\n          collection = keys(collection);\n          predicate = function predicate(key) {\n            return iteratee(iterable[key], key, iterable);\n          };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;\n      };\n    }\n    var nativeMax$2 = Math.max;\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax$2(length + index, 0);\n      }\n      return baseFindIndex(array, baseIteratee(predicate), index);\n    }\n    var find = createFind(findIndex);\n    var find$1 = find;\n    function head(array) {\n      return array && array.length ? array[0] : void 0;\n    }\n    function baseMap(collection, iteratee) {\n      var index = -1,\n        result = isArrayLike(collection) ? Array(collection.length) : [];\n      baseEach$1(collection, function (value, key, collection2) {\n        result[++index] = iteratee(value, key, collection2);\n      });\n      return result;\n    }\n    function map(collection, iteratee) {\n      var func = isArray$1(collection) ? arrayMap : baseMap;\n      return func(collection, baseIteratee(iteratee));\n    }\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n    var objectProto$2 = Object.prototype;\n    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n    var groupBy = createAggregator(function (result, value, key) {\n      if (hasOwnProperty$2.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n    var groupBy$1 = groupBy;\n    var objectProto$1 = Object.prototype;\n    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty$1.call(object, key);\n    }\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n    var stringTag = \"[object String]\";\n    function isString(value) {\n      return typeof value == \"string\" || !isArray$1(value) && isObjectLike(value) && baseGetTag(value) == stringTag;\n    }\n    function baseValues(object, props) {\n      return arrayMap(props, function (key) {\n        return object[key];\n      });\n    }\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n    var nativeMax$1 = Math.max;\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax$1(length + fromIndex, 0);\n      }\n      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;\n    }\n    var nativeMax = Math.max;\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n    var mapTag = \"[object Map]\",\n      setTag = \"[object Set]\";\n    var objectProto = Object.prototype;\n    var hasOwnProperty = objectProto.hasOwnProperty;\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) && (isArray$1(value) || typeof value == \"string\" || typeof value.splice == \"function\" || isBuffer$1(value) || isTypedArray$1(value) || isArguments$1(value))) {\n        return !value.length;\n      }\n      var tag = getTag$1(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    var regexpTag = \"[object RegExp]\";\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n    var nodeIsRegExp = nodeUtil$1 && nodeUtil$1.isRegExp;\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n    var isRegExp$1 = isRegExp;\n    function isUndefined(value) {\n      return value === void 0;\n    }\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    function negate(predicate) {\n      if (typeof predicate != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function () {\n        var args = arguments;\n        switch (args.length) {\n          case 0:\n            return !predicate.call(this);\n          case 1:\n            return !predicate.call(this, args[0]);\n          case 2:\n            return !predicate.call(this, args[0], args[1]);\n          case 3:\n            return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n      var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        nested = object;\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n          newValue = value;\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n          return object;\n        }\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : void 0;\n          if (newValue === void 0) {\n            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n        length = paths.length,\n        result = {};\n      while (++index < length) {\n        var path = paths[index],\n          value = baseGet(object, path);\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function (prop) {\n        return [prop];\n      });\n      predicate = baseIteratee(predicate);\n      return basePickBy(object, props, function (value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n      eachFunc(collection, function (value, index, collection2) {\n        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);\n      });\n      return accumulator;\n    }\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray$1(collection) ? arrayReduce : baseReduce,\n        initAccum = arguments.length < 3;\n      return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach$1);\n    }\n    function reject(collection, predicate) {\n      var func = isArray$1(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(baseIteratee(predicate)));\n    }\n    function baseSome(collection, predicate) {\n      var result;\n      baseEach$1(collection, function (value, index, collection2) {\n        result = predicate(value, index, collection2);\n        return !result;\n      });\n      return !!result;\n    }\n    function some(collection, predicate, guard) {\n      var func = isArray$1(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = void 0;\n      }\n      return func(collection, baseIteratee(predicate));\n    }\n    var INFINITY = 1 / 0;\n    var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop : function (values2) {\n      return new Set$1(values2);\n    };\n    var createSet$1 = createSet;\n    var LARGE_ARRAY_SIZE = 200;\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n        includes2 = arrayIncludes,\n        length = array.length,\n        isCommon = true,\n        result = [],\n        seen = result;\n      if (comparator) {\n        isCommon = false;\n        includes2 = arrayIncludesWith;\n      } else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet$1(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes2 = cacheHas;\n        seen = new SetCache();\n      } else {\n        seen = iteratee ? [] : result;\n      }\n      outer: while (++index < length) {\n        var value = array[index],\n          computed = iteratee ? iteratee(value) : value;\n        value = comparator || value !== 0 ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        } else if (!includes2(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n    function uniq(array) {\n      return array && array.length ? baseUniq(array) : [];\n    }\n    function PRINT_ERROR(msg) {\n      if (console && console.error) {\n        console.error(\"Error: \".concat(msg));\n      }\n    }\n    function PRINT_WARNING(msg) {\n      if (console && console.warn) {\n        console.warn(\"Warning: \".concat(msg));\n      }\n    }\n    function timer(func) {\n      var start = /* @__PURE__ */new Date().getTime();\n      var val = func();\n      var end = /* @__PURE__ */new Date().getTime();\n      var total = end - start;\n      return {\n        time: total,\n        value: val\n      };\n    }\n    function toFastProperties(toBecomeFast) {\n      function FakeConstructor() {}\n      FakeConstructor.prototype = toBecomeFast;\n      var fakeInstance = new FakeConstructor();\n      function fakeAccess() {\n        return typeof fakeInstance.bar;\n      }\n      fakeAccess();\n      fakeAccess();\n      return toBecomeFast;\n    }\n    function tokenLabel$1(tokType) {\n      if (hasTokenLabel$1(tokType)) {\n        return tokType.LABEL;\n      } else {\n        return tokType.name;\n      }\n    }\n    function hasTokenLabel$1(obj) {\n      return isString(obj.LABEL) && obj.LABEL !== \"\";\n    }\n    var AbstractProduction = /*#__PURE__*/function () {\n      function AbstractProduction(_definition) {\n        _classCallCheck(this, AbstractProduction);\n        this._definition = _definition;\n      }\n      _createClass(AbstractProduction, [{\n        key: \"definition\",\n        get: function get() {\n          return this._definition;\n        },\n        set: function set(value) {\n          this._definition = value;\n        }\n      }, {\n        key: \"accept\",\n        value: function accept(visitor) {\n          visitor.visit(this);\n          forEach(this.definition, function (prod) {\n            prod.accept(visitor);\n          });\n        }\n      }]);\n      return AbstractProduction;\n    }();\n    var NonTerminal = /*#__PURE__*/function (_AbstractProduction) {\n      _inherits(NonTerminal, _AbstractProduction);\n      var _super = _createSuper(NonTerminal);\n      function NonTerminal(options) {\n        var _this;\n        _classCallCheck(this, NonTerminal);\n        _this = _super.call(this, []);\n        _this.idx = 1;\n        assign$1(_assertThisInitialized(_this), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this;\n      }\n      _createClass(NonTerminal, [{\n        key: \"definition\",\n        get: function get() {\n          if (this.referencedRule !== void 0) {\n            return this.referencedRule.definition;\n          }\n          return [];\n        },\n        set: function set(definition) {}\n      }, {\n        key: \"accept\",\n        value: function accept(visitor) {\n          visitor.visit(this);\n        }\n      }]);\n      return NonTerminal;\n    }(AbstractProduction);\n    var Rule = /*#__PURE__*/function (_AbstractProduction2) {\n      _inherits(Rule, _AbstractProduction2);\n      var _super2 = _createSuper(Rule);\n      function Rule(options) {\n        var _this2;\n        _classCallCheck(this, Rule);\n        _this2 = _super2.call(this, options.definition);\n        _this2.orgText = \"\";\n        assign$1(_assertThisInitialized(_this2), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this2;\n      }\n      return _createClass(Rule);\n    }(AbstractProduction);\n    var Alternative = /*#__PURE__*/function (_AbstractProduction3) {\n      _inherits(Alternative, _AbstractProduction3);\n      var _super3 = _createSuper(Alternative);\n      function Alternative(options) {\n        var _this3;\n        _classCallCheck(this, Alternative);\n        _this3 = _super3.call(this, options.definition);\n        _this3.ignoreAmbiguities = false;\n        assign$1(_assertThisInitialized(_this3), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this3;\n      }\n      return _createClass(Alternative);\n    }(AbstractProduction);\n    var Option = /*#__PURE__*/function (_AbstractProduction4) {\n      _inherits(Option, _AbstractProduction4);\n      var _super4 = _createSuper(Option);\n      function Option(options) {\n        var _this4;\n        _classCallCheck(this, Option);\n        _this4 = _super4.call(this, options.definition);\n        _this4.idx = 1;\n        assign$1(_assertThisInitialized(_this4), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this4;\n      }\n      return _createClass(Option);\n    }(AbstractProduction);\n    var RepetitionMandatory = /*#__PURE__*/function (_AbstractProduction5) {\n      _inherits(RepetitionMandatory, _AbstractProduction5);\n      var _super5 = _createSuper(RepetitionMandatory);\n      function RepetitionMandatory(options) {\n        var _this5;\n        _classCallCheck(this, RepetitionMandatory);\n        _this5 = _super5.call(this, options.definition);\n        _this5.idx = 1;\n        assign$1(_assertThisInitialized(_this5), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this5;\n      }\n      return _createClass(RepetitionMandatory);\n    }(AbstractProduction);\n    var RepetitionMandatoryWithSeparator = /*#__PURE__*/function (_AbstractProduction6) {\n      _inherits(RepetitionMandatoryWithSeparator, _AbstractProduction6);\n      var _super6 = _createSuper(RepetitionMandatoryWithSeparator);\n      function RepetitionMandatoryWithSeparator(options) {\n        var _this6;\n        _classCallCheck(this, RepetitionMandatoryWithSeparator);\n        _this6 = _super6.call(this, options.definition);\n        _this6.idx = 1;\n        assign$1(_assertThisInitialized(_this6), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this6;\n      }\n      return _createClass(RepetitionMandatoryWithSeparator);\n    }(AbstractProduction);\n    var Repetition = /*#__PURE__*/function (_AbstractProduction7) {\n      _inherits(Repetition, _AbstractProduction7);\n      var _super7 = _createSuper(Repetition);\n      function Repetition(options) {\n        var _this7;\n        _classCallCheck(this, Repetition);\n        _this7 = _super7.call(this, options.definition);\n        _this7.idx = 1;\n        assign$1(_assertThisInitialized(_this7), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this7;\n      }\n      return _createClass(Repetition);\n    }(AbstractProduction);\n    var RepetitionWithSeparator = /*#__PURE__*/function (_AbstractProduction8) {\n      _inherits(RepetitionWithSeparator, _AbstractProduction8);\n      var _super8 = _createSuper(RepetitionWithSeparator);\n      function RepetitionWithSeparator(options) {\n        var _this8;\n        _classCallCheck(this, RepetitionWithSeparator);\n        _this8 = _super8.call(this, options.definition);\n        _this8.idx = 1;\n        assign$1(_assertThisInitialized(_this8), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this8;\n      }\n      return _createClass(RepetitionWithSeparator);\n    }(AbstractProduction);\n    var Alternation = /*#__PURE__*/function (_AbstractProduction9) {\n      _inherits(Alternation, _AbstractProduction9);\n      var _super9 = _createSuper(Alternation);\n      function Alternation(options) {\n        var _this9;\n        _classCallCheck(this, Alternation);\n        _this9 = _super9.call(this, options.definition);\n        _this9.idx = 1;\n        _this9.ignoreAmbiguities = false;\n        _this9.hasPredicates = false;\n        assign$1(_assertThisInitialized(_this9), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this9;\n      }\n      _createClass(Alternation, [{\n        key: \"definition\",\n        get: function get() {\n          return this._definition;\n        },\n        set: function set(value) {\n          this._definition = value;\n        }\n      }]);\n      return Alternation;\n    }(AbstractProduction);\n    var Terminal = /*#__PURE__*/function () {\n      function Terminal(options) {\n        _classCallCheck(this, Terminal);\n        this.idx = 1;\n        assign$1(this, pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n      }\n      _createClass(Terminal, [{\n        key: \"accept\",\n        value: function accept(visitor) {\n          visitor.visit(this);\n        }\n      }]);\n      return Terminal;\n    }();\n    function serializeGrammar(topRules) {\n      return map(topRules, serializeProduction);\n    }\n    function serializeProduction(node) {\n      function convertDefinition(definition) {\n        return map(definition, serializeProduction);\n      }\n      if (node instanceof NonTerminal) {\n        var serializedNonTerminal = {\n          type: \"NonTerminal\",\n          name: node.nonTerminalName,\n          idx: node.idx\n        };\n        if (isString(node.label)) {\n          serializedNonTerminal.label = node.label;\n        }\n        return serializedNonTerminal;\n      } else if (node instanceof Alternative) {\n        return {\n          type: \"Alternative\",\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof Option) {\n        return {\n          type: \"Option\",\n          idx: node.idx,\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof RepetitionMandatory) {\n        return {\n          type: \"RepetitionMandatory\",\n          idx: node.idx,\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n          type: \"RepetitionMandatoryWithSeparator\",\n          idx: node.idx,\n          separator: serializeProduction(new Terminal({\n            terminalType: node.separator\n          })),\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof RepetitionWithSeparator) {\n        return {\n          type: \"RepetitionWithSeparator\",\n          idx: node.idx,\n          separator: serializeProduction(new Terminal({\n            terminalType: node.separator\n          })),\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof Repetition) {\n        return {\n          type: \"Repetition\",\n          idx: node.idx,\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof Alternation) {\n        return {\n          type: \"Alternation\",\n          idx: node.idx,\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof Terminal) {\n        var serializedTerminal = {\n          type: \"Terminal\",\n          name: node.terminalType.name,\n          label: tokenLabel$1(node.terminalType),\n          idx: node.idx\n        };\n        if (isString(node.label)) {\n          serializedTerminal.terminalLabel = node.label;\n        }\n        var pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n          serializedTerminal.pattern = isRegExp$1(pattern) ? pattern.source : pattern;\n        }\n        return serializedTerminal;\n      } else if (node instanceof Rule) {\n        return {\n          type: \"Rule\",\n          name: node.name,\n          orgText: node.orgText,\n          definition: convertDefinition(node.definition)\n        };\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    var GAstVisitor = /*#__PURE__*/function () {\n      function GAstVisitor() {\n        _classCallCheck(this, GAstVisitor);\n      }\n      _createClass(GAstVisitor, [{\n        key: \"visit\",\n        value: function visit(node) {\n          var nodeAny = node;\n          switch (nodeAny.constructor) {\n            case NonTerminal:\n              return this.visitNonTerminal(nodeAny);\n            case Alternative:\n              return this.visitAlternative(nodeAny);\n            case Option:\n              return this.visitOption(nodeAny);\n            case RepetitionMandatory:\n              return this.visitRepetitionMandatory(nodeAny);\n            case RepetitionMandatoryWithSeparator:\n              return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case RepetitionWithSeparator:\n              return this.visitRepetitionWithSeparator(nodeAny);\n            case Repetition:\n              return this.visitRepetition(nodeAny);\n            case Alternation:\n              return this.visitAlternation(nodeAny);\n            case Terminal:\n              return this.visitTerminal(nodeAny);\n            case Rule:\n              return this.visitRule(nodeAny);\n            default:\n              throw Error(\"non exhaustive match\");\n          }\n        }\n        /* c8 ignore next */\n      }, {\n        key: \"visitNonTerminal\",\n        value: function visitNonTerminal(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitAlternative\",\n        value: function visitAlternative(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitOption\",\n        value: function visitOption(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(node) {}\n        /* c8 ignore next 3 */\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitAlternation\",\n        value: function visitAlternation(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitTerminal\",\n        value: function visitTerminal(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitRule\",\n        value: function visitRule(node) {}\n      }]);\n      return GAstVisitor;\n    }();\n    function isSequenceProd(prod) {\n      return prod instanceof Alternative || prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionMandatory || prod instanceof RepetitionMandatoryWithSeparator || prod instanceof RepetitionWithSeparator || prod instanceof Terminal || prod instanceof Rule;\n    }\n    function isOptionalProd(prod) {\n      var alreadyVisited = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var isDirectlyOptional = prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionWithSeparator;\n      if (isDirectlyOptional) {\n        return true;\n      }\n      if (prod instanceof Alternation) {\n        return some(prod.definition, function (subProd) {\n          return isOptionalProd(subProd, alreadyVisited);\n        });\n      } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n        return false;\n      } else if (prod instanceof AbstractProduction) {\n        if (prod instanceof NonTerminal) {\n          alreadyVisited.push(prod);\n        }\n        return every(prod.definition, function (subProd) {\n          return isOptionalProd(subProd, alreadyVisited);\n        });\n      } else {\n        return false;\n      }\n    }\n    function isBranchingProd(prod) {\n      return prod instanceof Alternation;\n    }\n    function getProductionDslName(prod) {\n      if (prod instanceof NonTerminal) {\n        return \"SUBRULE\";\n      } else if (prod instanceof Option) {\n        return \"OPTION\";\n      } else if (prod instanceof Alternation) {\n        return \"OR\";\n      } else if (prod instanceof RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n      } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n      } else if (prod instanceof RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n      } else if (prod instanceof Repetition) {\n        return \"MANY\";\n      } else if (prod instanceof Terminal) {\n        return \"CONSUME\";\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    var RestWalker = /*#__PURE__*/function () {\n      function RestWalker() {\n        _classCallCheck(this, RestWalker);\n      }\n      _createClass(RestWalker, [{\n        key: \"walk\",\n        value: function walk(prod) {\n          var _this10 = this;\n          var prevRest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n          forEach(prod.definition, function (subProd, index) {\n            var currRest = drop(prod.definition, index + 1);\n            if (subProd instanceof NonTerminal) {\n              _this10.walkProdRef(subProd, currRest, prevRest);\n            } else if (subProd instanceof Terminal) {\n              _this10.walkTerminal(subProd, currRest, prevRest);\n            } else if (subProd instanceof Alternative) {\n              _this10.walkFlat(subProd, currRest, prevRest);\n            } else if (subProd instanceof Option) {\n              _this10.walkOption(subProd, currRest, prevRest);\n            } else if (subProd instanceof RepetitionMandatory) {\n              _this10.walkAtLeastOne(subProd, currRest, prevRest);\n            } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n              _this10.walkAtLeastOneSep(subProd, currRest, prevRest);\n            } else if (subProd instanceof RepetitionWithSeparator) {\n              _this10.walkManySep(subProd, currRest, prevRest);\n            } else if (subProd instanceof Repetition) {\n              _this10.walkMany(subProd, currRest, prevRest);\n            } else if (subProd instanceof Alternation) {\n              _this10.walkOr(subProd, currRest, prevRest);\n            } else {\n              throw Error(\"non exhaustive match\");\n            }\n          });\n        }\n      }, {\n        key: \"walkTerminal\",\n        value: function walkTerminal(terminal, currRest, prevRest) {}\n      }, {\n        key: \"walkProdRef\",\n        value: function walkProdRef(refProd, currRest, prevRest) {}\n      }, {\n        key: \"walkFlat\",\n        value: function walkFlat(flatProd, currRest, prevRest) {\n          var fullOrRest = currRest.concat(prevRest);\n          this.walk(flatProd, fullOrRest);\n        }\n      }, {\n        key: \"walkOption\",\n        value: function walkOption(optionProd, currRest, prevRest) {\n          var fullOrRest = currRest.concat(prevRest);\n          this.walk(optionProd, fullOrRest);\n        }\n      }, {\n        key: \"walkAtLeastOne\",\n        value: function walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n          var fullAtLeastOneRest = [new Option({\n            definition: atLeastOneProd.definition\n          })].concat(currRest, prevRest);\n          this.walk(atLeastOneProd, fullAtLeastOneRest);\n        }\n      }, {\n        key: \"walkAtLeastOneSep\",\n        value: function walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n          var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n          this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n        }\n      }, {\n        key: \"walkMany\",\n        value: function walkMany(manyProd, currRest, prevRest) {\n          var fullManyRest = [new Option({\n            definition: manyProd.definition\n          })].concat(currRest, prevRest);\n          this.walk(manyProd, fullManyRest);\n        }\n      }, {\n        key: \"walkManySep\",\n        value: function walkManySep(manySepProd, currRest, prevRest) {\n          var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n          this.walk(manySepProd, fullManySepRest);\n        }\n      }, {\n        key: \"walkOr\",\n        value: function walkOr(orProd, currRest, prevRest) {\n          var _this11 = this;\n          var fullOrRest = currRest.concat(prevRest);\n          forEach(orProd.definition, function (alt) {\n            var prodWrapper = new Alternative({\n              definition: [alt]\n            });\n            _this11.walk(prodWrapper, fullOrRest);\n          });\n        }\n      }]);\n      return RestWalker;\n    }();\n    function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n      var repSepRest = [new Option({\n        definition: [new Terminal({\n          terminalType: repSepProd.separator\n        })].concat(repSepProd.definition)\n      })];\n      var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n      return fullRepSepRest;\n    }\n    function first(prod) {\n      if (prod instanceof NonTerminal) {\n        return first(prod.referencedRule);\n      } else if (prod instanceof Terminal) {\n        return firstForTerminal(prod);\n      } else if (isSequenceProd(prod)) {\n        return firstForSequence(prod);\n      } else if (isBranchingProd(prod)) {\n        return firstForBranching(prod);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function firstForSequence(prod) {\n      var firstSet = [];\n      var seq = prod.definition;\n      var nextSubProdIdx = 0;\n      var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n      var currSubProd;\n      var isLastInnerProdOptional = true;\n      while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = isOptionalProd(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n      }\n      return uniq(firstSet);\n    }\n    function firstForBranching(prod) {\n      var allAlternativesFirsts = map(prod.definition, function (innerProd) {\n        return first(innerProd);\n      });\n      return uniq(flatten(allAlternativesFirsts));\n    }\n    function firstForTerminal(terminal) {\n      return [terminal.terminalType];\n    }\n    var IN = \"_~IN~_\";\n    var ResyncFollowsWalker = /*#__PURE__*/function (_RestWalker) {\n      _inherits(ResyncFollowsWalker, _RestWalker);\n      var _super10 = _createSuper(ResyncFollowsWalker);\n      function ResyncFollowsWalker(topProd) {\n        var _this12;\n        _classCallCheck(this, ResyncFollowsWalker);\n        _this12 = _super10.call(this);\n        _this12.topProd = topProd;\n        _this12.follows = {};\n        return _this12;\n      }\n      _createClass(ResyncFollowsWalker, [{\n        key: \"startWalking\",\n        value: function startWalking() {\n          this.walk(this.topProd);\n          return this.follows;\n        }\n      }, {\n        key: \"walkTerminal\",\n        value: function walkTerminal(terminal, currRest, prevRest) {}\n      }, {\n        key: \"walkProdRef\",\n        value: function walkProdRef(refProd, currRest, prevRest) {\n          var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;\n          var fullRest = currRest.concat(prevRest);\n          var restProd = new Alternative({\n            definition: fullRest\n          });\n          var t_in_topProd_follows = first(restProd);\n          this.follows[followName] = t_in_topProd_follows;\n        }\n      }]);\n      return ResyncFollowsWalker;\n    }(RestWalker);\n    function computeAllProdsFollows(topProductions) {\n      var reSyncFollows = {};\n      forEach(topProductions, function (topProd) {\n        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        assign$1(reSyncFollows, currRefsFollow);\n      });\n      return reSyncFollows;\n    }\n    function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n      return inner.name + occurenceInParent + IN;\n    }\n    function cc(char) {\n      return char.charCodeAt(0);\n    }\n    function insertToSet(item, set) {\n      if (Array.isArray(item)) {\n        item.forEach(function (subItem) {\n          set.push(subItem);\n        });\n      } else {\n        set.push(item);\n      }\n    }\n    function addFlag(flagObj, flagKey) {\n      if (flagObj[flagKey] === true) {\n        throw \"duplicate flag \" + flagKey;\n      }\n      flagObj[flagKey];\n      flagObj[flagKey] = true;\n    }\n    function ASSERT_EXISTS(obj) {\n      if (obj === void 0) {\n        throw Error(\"Internal Error - Should never get here!\");\n      }\n      return true;\n    }\n    function ASSERT_NEVER_REACH_HERE() {\n      throw Error(\"Internal Error - Should never get here!\");\n    }\n    function isCharacter(obj) {\n      return obj[\"type\"] === \"Character\";\n    }\n    var digitsCharCodes = [];\n    for (var i = cc(\"0\"); i <= cc(\"9\"); i++) {\n      digitsCharCodes.push(i);\n    }\n    var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\n    for (var _i = cc(\"a\"); _i <= cc(\"z\"); _i++) {\n      wordCharCodes.push(_i);\n    }\n    for (var _i2 = cc(\"A\"); _i2 <= cc(\"Z\"); _i2++) {\n      wordCharCodes.push(_i2);\n    }\n    var whitespaceCodes = [cc(\" \"), cc(\"\\f\"), cc(\"\\n\"), cc(\"\\r\"), cc(\"\t\"), cc(\"\\v\"), cc(\"\t\"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\" \"), cc(\"\\u2028\"), cc(\"\\u2029\"), cc(\" \"), cc(\" \"), cc(\"　\"), cc(\"\\uFEFF\")];\n    var hexDigitPattern = /[0-9a-fA-F]/;\n    var decimalPattern = /[0-9]/;\n    var decimalPatternNoZero = /[1-9]/;\n    var RegExpParser = /*#__PURE__*/function () {\n      function RegExpParser() {\n        _classCallCheck(this, RegExpParser);\n        this.idx = 0;\n        this.input = \"\";\n        this.groupIdx = 0;\n      }\n      _createClass(RegExpParser, [{\n        key: \"saveState\",\n        value: function saveState() {\n          return {\n            idx: this.idx,\n            input: this.input,\n            groupIdx: this.groupIdx\n          };\n        }\n      }, {\n        key: \"restoreState\",\n        value: function restoreState(newState) {\n          this.idx = newState.idx;\n          this.input = newState.input;\n          this.groupIdx = newState.groupIdx;\n        }\n      }, {\n        key: \"pattern\",\n        value: function pattern(input) {\n          this.idx = 0;\n          this.input = input;\n          this.groupIdx = 0;\n          this.consumeChar(\"/\");\n          var value = this.disjunction();\n          this.consumeChar(\"/\");\n          var flags = {\n            type: \"Flags\",\n            loc: {\n              begin: this.idx,\n              end: input.length\n            },\n            global: false,\n            ignoreCase: false,\n            multiLine: false,\n            unicode: false,\n            sticky: false\n          };\n          while (this.isRegExpFlag()) {\n            switch (this.popChar()) {\n              case \"g\":\n                addFlag(flags, \"global\");\n                break;\n              case \"i\":\n                addFlag(flags, \"ignoreCase\");\n                break;\n              case \"m\":\n                addFlag(flags, \"multiLine\");\n                break;\n              case \"u\":\n                addFlag(flags, \"unicode\");\n                break;\n              case \"y\":\n                addFlag(flags, \"sticky\");\n                break;\n            }\n          }\n          if (this.idx !== this.input.length) {\n            throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n          }\n          return {\n            type: \"Pattern\",\n            flags: flags,\n            value: value,\n            loc: this.loc(0)\n          };\n        }\n      }, {\n        key: \"disjunction\",\n        value: function disjunction() {\n          var alts = [];\n          var begin = this.idx;\n          alts.push(this.alternative());\n          while (this.peekChar() === \"|\") {\n            this.consumeChar(\"|\");\n            alts.push(this.alternative());\n          }\n          return {\n            type: \"Disjunction\",\n            value: alts,\n            loc: this.loc(begin)\n          };\n        }\n      }, {\n        key: \"alternative\",\n        value: function alternative() {\n          var terms = [];\n          var begin = this.idx;\n          while (this.isTerm()) {\n            terms.push(this.term());\n          }\n          return {\n            type: \"Alternative\",\n            value: terms,\n            loc: this.loc(begin)\n          };\n        }\n      }, {\n        key: \"term\",\n        value: function term() {\n          if (this.isAssertion()) {\n            return this.assertion();\n          } else {\n            return this.atom();\n          }\n        }\n      }, {\n        key: \"assertion\",\n        value: function assertion() {\n          var begin = this.idx;\n          switch (this.popChar()) {\n            case \"^\":\n              return {\n                type: \"StartAnchor\",\n                loc: this.loc(begin)\n              };\n            case \"$\":\n              return {\n                type: \"EndAnchor\",\n                loc: this.loc(begin)\n              };\n            case \"\\\\\":\n              switch (this.popChar()) {\n                case \"b\":\n                  return {\n                    type: \"WordBoundary\",\n                    loc: this.loc(begin)\n                  };\n                case \"B\":\n                  return {\n                    type: \"NonWordBoundary\",\n                    loc: this.loc(begin)\n                  };\n              }\n              throw Error(\"Invalid Assertion Escape\");\n            case \"(\":\n              this.consumeChar(\"?\");\n              var type;\n              switch (this.popChar()) {\n                case \"=\":\n                  type = \"Lookahead\";\n                  break;\n                case \"!\":\n                  type = \"NegativeLookahead\";\n                  break;\n              }\n              ASSERT_EXISTS(type);\n              var disjunction = this.disjunction();\n              this.consumeChar(\")\");\n              return {\n                type: type,\n                value: disjunction,\n                loc: this.loc(begin)\n              };\n          }\n          return ASSERT_NEVER_REACH_HERE();\n        }\n      }, {\n        key: \"quantifier\",\n        value: function quantifier() {\n          var isBacktracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n          var range = void 0;\n          var begin = this.idx;\n          switch (this.popChar()) {\n            case \"*\":\n              range = {\n                atLeast: 0,\n                atMost: Infinity\n              };\n              break;\n            case \"+\":\n              range = {\n                atLeast: 1,\n                atMost: Infinity\n              };\n              break;\n            case \"?\":\n              range = {\n                atLeast: 0,\n                atMost: 1\n              };\n              break;\n            case \"{\":\n              var atLeast = this.integerIncludingZero();\n              switch (this.popChar()) {\n                case \"}\":\n                  range = {\n                    atLeast: atLeast,\n                    atMost: atLeast\n                  };\n                  break;\n                case \",\":\n                  var atMost;\n                  if (this.isDigit()) {\n                    atMost = this.integerIncludingZero();\n                    range = {\n                      atLeast: atLeast,\n                      atMost: atMost\n                    };\n                  } else {\n                    range = {\n                      atLeast: atLeast,\n                      atMost: Infinity\n                    };\n                  }\n                  this.consumeChar(\"}\");\n                  break;\n              }\n              if (isBacktracking === true && range === void 0) {\n                return void 0;\n              }\n              ASSERT_EXISTS(range);\n              break;\n          }\n          if (isBacktracking === true && range === void 0) {\n            return void 0;\n          }\n          if (ASSERT_EXISTS(range)) {\n            if (this.peekChar(0) === \"?\") {\n              this.consumeChar(\"?\");\n              range.greedy = false;\n            } else {\n              range.greedy = true;\n            }\n            range.type = \"Quantifier\";\n            range.loc = this.loc(begin);\n            return range;\n          }\n        }\n      }, {\n        key: \"atom\",\n        value: function atom() {\n          var atom;\n          var begin = this.idx;\n          switch (this.peekChar()) {\n            case \".\":\n              atom = this.dotAll();\n              break;\n            case \"\\\\\":\n              atom = this.atomEscape();\n              break;\n            case \"[\":\n              atom = this.characterClass();\n              break;\n            case \"(\":\n              atom = this.group();\n              break;\n          }\n          if (atom === void 0 && this.isPatternCharacter()) {\n            atom = this.patternCharacter();\n          }\n          if (ASSERT_EXISTS(atom)) {\n            atom.loc = this.loc(begin);\n            if (this.isQuantifier()) {\n              atom.quantifier = this.quantifier();\n            }\n            return atom;\n          }\n        }\n      }, {\n        key: \"dotAll\",\n        value: function dotAll() {\n          this.consumeChar(\".\");\n          return {\n            type: \"Set\",\n            complement: true,\n            value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n          };\n        }\n      }, {\n        key: \"atomEscape\",\n        value: function atomEscape() {\n          this.consumeChar(\"\\\\\");\n          switch (this.peekChar()) {\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n              return this.decimalEscapeAtom();\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n              return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n              return this.controlEscapeAtom();\n            case \"c\":\n              return this.controlLetterEscapeAtom();\n            case \"0\":\n              return this.nulCharacterAtom();\n            case \"x\":\n              return this.hexEscapeSequenceAtom();\n            case \"u\":\n              return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n              return this.identityEscapeAtom();\n          }\n        }\n      }, {\n        key: \"decimalEscapeAtom\",\n        value: function decimalEscapeAtom() {\n          var value = this.positiveInteger();\n          return {\n            type: \"GroupBackReference\",\n            value: value\n          };\n        }\n      }, {\n        key: \"characterClassEscape\",\n        value: function characterClassEscape() {\n          var set;\n          var complement = false;\n          switch (this.popChar()) {\n            case \"d\":\n              set = digitsCharCodes;\n              break;\n            case \"D\":\n              set = digitsCharCodes;\n              complement = true;\n              break;\n            case \"s\":\n              set = whitespaceCodes;\n              break;\n            case \"S\":\n              set = whitespaceCodes;\n              complement = true;\n              break;\n            case \"w\":\n              set = wordCharCodes;\n              break;\n            case \"W\":\n              set = wordCharCodes;\n              complement = true;\n              break;\n          }\n          if (ASSERT_EXISTS(set)) {\n            return {\n              type: \"Set\",\n              value: set,\n              complement: complement\n            };\n          }\n        }\n      }, {\n        key: \"controlEscapeAtom\",\n        value: function controlEscapeAtom() {\n          var escapeCode;\n          switch (this.popChar()) {\n            case \"f\":\n              escapeCode = cc(\"\\f\");\n              break;\n            case \"n\":\n              escapeCode = cc(\"\\n\");\n              break;\n            case \"r\":\n              escapeCode = cc(\"\\r\");\n              break;\n            case \"t\":\n              escapeCode = cc(\"\t\");\n              break;\n            case \"v\":\n              escapeCode = cc(\"\\v\");\n              break;\n          }\n          if (ASSERT_EXISTS(escapeCode)) {\n            return {\n              type: \"Character\",\n              value: escapeCode\n            };\n          }\n        }\n      }, {\n        key: \"controlLetterEscapeAtom\",\n        value: function controlLetterEscapeAtom() {\n          this.consumeChar(\"c\");\n          var letter = this.popChar();\n          if (/[a-zA-Z]/.test(letter) === false) {\n            throw Error(\"Invalid \");\n          }\n          var letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n          return {\n            type: \"Character\",\n            value: letterCode\n          };\n        }\n      }, {\n        key: \"nulCharacterAtom\",\n        value: function nulCharacterAtom() {\n          this.consumeChar(\"0\");\n          return {\n            type: \"Character\",\n            value: cc(\"\\0\")\n          };\n        }\n      }, {\n        key: \"hexEscapeSequenceAtom\",\n        value: function hexEscapeSequenceAtom() {\n          this.consumeChar(\"x\");\n          return this.parseHexDigits(2);\n        }\n      }, {\n        key: \"regExpUnicodeEscapeSequenceAtom\",\n        value: function regExpUnicodeEscapeSequenceAtom() {\n          this.consumeChar(\"u\");\n          return this.parseHexDigits(4);\n        }\n      }, {\n        key: \"identityEscapeAtom\",\n        value: function identityEscapeAtom() {\n          var escapedChar = this.popChar();\n          return {\n            type: \"Character\",\n            value: cc(escapedChar)\n          };\n        }\n      }, {\n        key: \"classPatternCharacterAtom\",\n        value: function classPatternCharacterAtom() {\n          switch (this.peekChar()) {\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n            case \"\\\\\":\n            case \"]\":\n              throw Error(\"TBD\");\n            default:\n              var nextChar = this.popChar();\n              return {\n                type: \"Character\",\n                value: cc(nextChar)\n              };\n          }\n        }\n      }, {\n        key: \"characterClass\",\n        value: function characterClass() {\n          var set = [];\n          var complement = false;\n          this.consumeChar(\"[\");\n          if (this.peekChar(0) === \"^\") {\n            this.consumeChar(\"^\");\n            complement = true;\n          }\n          while (this.isClassAtom()) {\n            var from = this.classAtom();\n            from.type === \"Character\";\n            if (isCharacter(from) && this.isRangeDash()) {\n              this.consumeChar(\"-\");\n              var to = this.classAtom();\n              to.type === \"Character\";\n              if (isCharacter(to)) {\n                if (to.value < from.value) {\n                  throw Error(\"Range out of order in character class\");\n                }\n                set.push({\n                  from: from.value,\n                  to: to.value\n                });\n              } else {\n                insertToSet(from.value, set);\n                set.push(cc(\"-\"));\n                insertToSet(to.value, set);\n              }\n            } else {\n              insertToSet(from.value, set);\n            }\n          }\n          this.consumeChar(\"]\");\n          return {\n            type: \"Set\",\n            complement: complement,\n            value: set\n          };\n        }\n      }, {\n        key: \"classAtom\",\n        value: function classAtom() {\n          switch (this.peekChar()) {\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n              throw Error(\"TBD\");\n            case \"\\\\\":\n              return this.classEscape();\n            default:\n              return this.classPatternCharacterAtom();\n          }\n        }\n      }, {\n        key: \"classEscape\",\n        value: function classEscape() {\n          this.consumeChar(\"\\\\\");\n          switch (this.peekChar()) {\n            case \"b\":\n              this.consumeChar(\"b\");\n              return {\n                type: \"Character\",\n                value: cc(\"\\b\")\n              };\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n              return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n              return this.controlEscapeAtom();\n            case \"c\":\n              return this.controlLetterEscapeAtom();\n            case \"0\":\n              return this.nulCharacterAtom();\n            case \"x\":\n              return this.hexEscapeSequenceAtom();\n            case \"u\":\n              return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n              return this.identityEscapeAtom();\n          }\n        }\n      }, {\n        key: \"group\",\n        value: function group() {\n          var capturing = true;\n          this.consumeChar(\"(\");\n          switch (this.peekChar(0)) {\n            case \"?\":\n              this.consumeChar(\"?\");\n              this.consumeChar(\":\");\n              capturing = false;\n              break;\n            default:\n              this.groupIdx++;\n              break;\n          }\n          var value = this.disjunction();\n          this.consumeChar(\")\");\n          var groupAst = {\n            type: \"Group\",\n            capturing: capturing,\n            value: value\n          };\n          if (capturing) {\n            groupAst[\"idx\"] = this.groupIdx;\n          }\n          return groupAst;\n        }\n      }, {\n        key: \"positiveInteger\",\n        value: function positiveInteger() {\n          var number = this.popChar();\n          if (decimalPatternNoZero.test(number) === false) {\n            throw Error(\"Expecting a positive integer\");\n          }\n          while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n          }\n          return parseInt(number, 10);\n        }\n      }, {\n        key: \"integerIncludingZero\",\n        value: function integerIncludingZero() {\n          var number = this.popChar();\n          if (decimalPattern.test(number) === false) {\n            throw Error(\"Expecting an integer\");\n          }\n          while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n          }\n          return parseInt(number, 10);\n        }\n      }, {\n        key: \"patternCharacter\",\n        value: function patternCharacter() {\n          var nextChar = this.popChar();\n          switch (nextChar) {\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n              throw Error(\"TBD\");\n            default:\n              return {\n                type: \"Character\",\n                value: cc(nextChar)\n              };\n          }\n        }\n      }, {\n        key: \"isRegExpFlag\",\n        value: function isRegExpFlag() {\n          switch (this.peekChar(0)) {\n            case \"g\":\n            case \"i\":\n            case \"m\":\n            case \"u\":\n            case \"y\":\n              return true;\n            default:\n              return false;\n          }\n        }\n      }, {\n        key: \"isRangeDash\",\n        value: function isRangeDash() {\n          return this.peekChar() === \"-\" && this.isClassAtom(1);\n        }\n      }, {\n        key: \"isDigit\",\n        value: function isDigit() {\n          return decimalPattern.test(this.peekChar(0));\n        }\n      }, {\n        key: \"isClassAtom\",\n        value: function isClassAtom() {\n          var howMuch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          switch (this.peekChar(howMuch)) {\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n              return false;\n            default:\n              return true;\n          }\n        }\n      }, {\n        key: \"isTerm\",\n        value: function isTerm() {\n          return this.isAtom() || this.isAssertion();\n        }\n      }, {\n        key: \"isAtom\",\n        value: function isAtom() {\n          if (this.isPatternCharacter()) {\n            return true;\n          }\n          switch (this.peekChar(0)) {\n            case \".\":\n            case \"\\\\\":\n            case \"[\":\n            case \"(\":\n              return true;\n            default:\n              return false;\n          }\n        }\n      }, {\n        key: \"isAssertion\",\n        value: function isAssertion() {\n          switch (this.peekChar(0)) {\n            case \"^\":\n            case \"$\":\n              return true;\n            case \"\\\\\":\n              switch (this.peekChar(1)) {\n                case \"b\":\n                case \"B\":\n                  return true;\n                default:\n                  return false;\n              }\n            case \"(\":\n              return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n            default:\n              return false;\n          }\n        }\n      }, {\n        key: \"isQuantifier\",\n        value: function isQuantifier() {\n          var prevState = this.saveState();\n          try {\n            return this.quantifier(true) !== void 0;\n          } catch (e) {\n            return false;\n          } finally {\n            this.restoreState(prevState);\n          }\n        }\n      }, {\n        key: \"isPatternCharacter\",\n        value: function isPatternCharacter() {\n          switch (this.peekChar()) {\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n            case \"/\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n              return false;\n            default:\n              return true;\n          }\n        }\n      }, {\n        key: \"parseHexDigits\",\n        value: function parseHexDigits(howMany) {\n          var hexString = \"\";\n          for (var _i3 = 0; _i3 < howMany; _i3++) {\n            var hexChar = this.popChar();\n            if (hexDigitPattern.test(hexChar) === false) {\n              throw Error(\"Expecting a HexDecimal digits\");\n            }\n            hexString += hexChar;\n          }\n          var charCode = parseInt(hexString, 16);\n          return {\n            type: \"Character\",\n            value: charCode\n          };\n        }\n      }, {\n        key: \"peekChar\",\n        value: function peekChar() {\n          var howMuch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          return this.input[this.idx + howMuch];\n        }\n      }, {\n        key: \"popChar\",\n        value: function popChar() {\n          var nextChar = this.peekChar(0);\n          this.consumeChar(void 0);\n          return nextChar;\n        }\n      }, {\n        key: \"consumeChar\",\n        value: function consumeChar(char) {\n          if (char !== void 0 && this.input[this.idx] !== char) {\n            throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n          }\n          if (this.idx >= this.input.length) {\n            throw Error(\"Unexpected end of input\");\n          }\n          this.idx++;\n        }\n      }, {\n        key: \"loc\",\n        value: function loc(begin) {\n          return {\n            begin: begin,\n            end: this.idx\n          };\n        }\n      }]);\n      return RegExpParser;\n    }();\n    var BaseRegExpVisitor = /*#__PURE__*/function () {\n      function BaseRegExpVisitor() {\n        _classCallCheck(this, BaseRegExpVisitor);\n      }\n      _createClass(BaseRegExpVisitor, [{\n        key: \"visitChildren\",\n        value: function visitChildren(node) {\n          var _this13 = this;\n          for (var key in node) {\n            var child = node[key];\n            if (node.hasOwnProperty(key)) {\n              if (child.type !== void 0) {\n                this.visit(child);\n              } else if (Array.isArray(child)) {\n                child.forEach(function (subChild) {\n                  _this13.visit(subChild);\n                }, this);\n              }\n            }\n          }\n        }\n      }, {\n        key: \"visit\",\n        value: function visit(node) {\n          switch (node.type) {\n            case \"Pattern\":\n              this.visitPattern(node);\n              break;\n            case \"Flags\":\n              this.visitFlags(node);\n              break;\n            case \"Disjunction\":\n              this.visitDisjunction(node);\n              break;\n            case \"Alternative\":\n              this.visitAlternative(node);\n              break;\n            case \"StartAnchor\":\n              this.visitStartAnchor(node);\n              break;\n            case \"EndAnchor\":\n              this.visitEndAnchor(node);\n              break;\n            case \"WordBoundary\":\n              this.visitWordBoundary(node);\n              break;\n            case \"NonWordBoundary\":\n              this.visitNonWordBoundary(node);\n              break;\n            case \"Lookahead\":\n              this.visitLookahead(node);\n              break;\n            case \"NegativeLookahead\":\n              this.visitNegativeLookahead(node);\n              break;\n            case \"Character\":\n              this.visitCharacter(node);\n              break;\n            case \"Set\":\n              this.visitSet(node);\n              break;\n            case \"Group\":\n              this.visitGroup(node);\n              break;\n            case \"GroupBackReference\":\n              this.visitGroupBackReference(node);\n              break;\n            case \"Quantifier\":\n              this.visitQuantifier(node);\n              break;\n          }\n          this.visitChildren(node);\n        }\n      }, {\n        key: \"visitPattern\",\n        value: function visitPattern(node) {}\n      }, {\n        key: \"visitFlags\",\n        value: function visitFlags(node) {}\n      }, {\n        key: \"visitDisjunction\",\n        value: function visitDisjunction(node) {}\n      }, {\n        key: \"visitAlternative\",\n        value: function visitAlternative(node) {}\n        // Assertion\n      }, {\n        key: \"visitStartAnchor\",\n        value: function visitStartAnchor(node) {}\n      }, {\n        key: \"visitEndAnchor\",\n        value: function visitEndAnchor(node) {}\n      }, {\n        key: \"visitWordBoundary\",\n        value: function visitWordBoundary(node) {}\n      }, {\n        key: \"visitNonWordBoundary\",\n        value: function visitNonWordBoundary(node) {}\n      }, {\n        key: \"visitLookahead\",\n        value: function visitLookahead(node) {}\n      }, {\n        key: \"visitNegativeLookahead\",\n        value: function visitNegativeLookahead(node) {}\n        // atoms\n      }, {\n        key: \"visitCharacter\",\n        value: function visitCharacter(node) {}\n      }, {\n        key: \"visitSet\",\n        value: function visitSet(node) {}\n      }, {\n        key: \"visitGroup\",\n        value: function visitGroup(node) {}\n      }, {\n        key: \"visitGroupBackReference\",\n        value: function visitGroupBackReference(node) {}\n      }, {\n        key: \"visitQuantifier\",\n        value: function visitQuantifier(node) {}\n      }]);\n      return BaseRegExpVisitor;\n    }();\n    var regExpAstCache = {};\n    var regExpParser = new RegExpParser();\n    function getRegExpAst(regExp) {\n      var regExpStr = regExp.toString();\n      if (regExpAstCache.hasOwnProperty(regExpStr)) {\n        return regExpAstCache[regExpStr];\n      } else {\n        var regExpAst = regExpParser.pattern(regExpStr);\n        regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n      }\n    }\n    function clearRegExpParserCache() {\n      regExpAstCache = {};\n    }\n    var complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\n    var failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\n    function getOptimizedStartCodesIndices(regExp) {\n      var ensureOptimizations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      try {\n        var ast = getRegExpAst(regExp);\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n      } catch (e) {\n        if (e.message === complementErrorMessage) {\n          if (ensureOptimizations) {\n            PRINT_WARNING(\"\".concat(failedOptimizationPrefixMsg, \"\\tUnable to optimize: < \").concat(regExp.toString(), \" >\\n\\tComplement Sets cannot be automatically optimized.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\"));\n          }\n        } else {\n          var msgSuffix = \"\";\n          if (ensureOptimizations) {\n            msgSuffix = \"\\n\tThis will disable the lexer's first char optimizations.\\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n          }\n          PRINT_ERROR(\"\".concat(failedOptimizationPrefixMsg, \"\\n\\tFailed parsing: < \").concat(regExp.toString(), \" >\\n\\tUsing the @chevrotain/regexp-to-ast library\\n\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues\") + msgSuffix);\n        }\n      }\n      return [];\n    }\n    function firstCharOptimizedIndices(ast, result, ignoreCase) {\n      switch (ast.type) {\n        case \"Disjunction\":\n          for (var _i4 = 0; _i4 < ast.value.length; _i4++) {\n            firstCharOptimizedIndices(ast.value[_i4], result, ignoreCase);\n          }\n          break;\n        case \"Alternative\":\n          var terms = ast.value;\n          for (var _i5 = 0; _i5 < terms.length; _i5++) {\n            var term = terms[_i5];\n            switch (term.type) {\n              case \"EndAnchor\":\n              case \"GroupBackReference\":\n              case \"Lookahead\":\n              case \"NegativeLookahead\":\n              case \"StartAnchor\":\n              case \"WordBoundary\":\n              case \"NonWordBoundary\":\n                continue;\n            }\n            var atom = term;\n            switch (atom.type) {\n              case \"Character\":\n                addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                break;\n              case \"Set\":\n                if (atom.complement === true) {\n                  throw Error(complementErrorMessage);\n                }\n                forEach(atom.value, function (code) {\n                  if (typeof code === \"number\") {\n                    addOptimizedIdxToResult(code, result, ignoreCase);\n                  } else {\n                    var range = code;\n                    if (ignoreCase === true) {\n                      for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                      }\n                    } else {\n                      for (var _rangeCode = range.from; _rangeCode <= range.to && _rangeCode < minOptimizationVal; _rangeCode++) {\n                        addOptimizedIdxToResult(_rangeCode, result, ignoreCase);\n                      }\n                      if (range.to >= minOptimizationVal) {\n                        var minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                        var maxUnOptVal = range.to;\n                        var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                        var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                          result[currOptIdx] = currOptIdx;\n                        }\n                      }\n                    }\n                  }\n                });\n                break;\n              case \"Group\":\n                firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                break;\n              default:\n                throw Error(\"Non Exhaustive Match\");\n            }\n            var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;\n            if (\n            // A group may be optional due to empty contents /(?:)/\n            // or if everything inside it is optional /((a)?)/\n            atom.type === \"Group\" && isWholeOptional(atom) === false ||\n            // If this term is not a group it may only be optional if it has an optional quantifier\n            atom.type !== \"Group\" && isOptionalQuantifier === false) {\n              break;\n            }\n          }\n          break;\n        default:\n          throw Error(\"non exhaustive match!\");\n      }\n      return values(result);\n    }\n    function addOptimizedIdxToResult(code, result, ignoreCase) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(code);\n      result[optimizedCharIdx] = optimizedCharIdx;\n      if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n      }\n    }\n    function handleIgnoreCase(code, result) {\n      var char = String.fromCharCode(code);\n      var upperChar = char.toUpperCase();\n      if (upperChar !== char) {\n        var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n      } else {\n        var lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n          var _optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n          result[_optimizedCharIdx] = _optimizedCharIdx;\n        }\n      }\n    }\n    function findCode(setNode, targetCharCodes) {\n      return find$1(setNode.value, function (codeOrRange) {\n        if (typeof codeOrRange === \"number\") {\n          return includes(targetCharCodes, codeOrRange);\n        } else {\n          var range = codeOrRange;\n          return find$1(targetCharCodes, function (targetCode) {\n            return range.from <= targetCode && targetCode <= range.to;\n          }) !== void 0;\n        }\n      });\n    }\n    function isWholeOptional(ast) {\n      var quantifier = ast.quantifier;\n      if (quantifier && quantifier.atLeast === 0) {\n        return true;\n      }\n      if (!ast.value) {\n        return false;\n      }\n      return isArray$1(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n    }\n    var CharCodeFinder = /*#__PURE__*/function (_BaseRegExpVisitor) {\n      _inherits(CharCodeFinder, _BaseRegExpVisitor);\n      var _super11 = _createSuper(CharCodeFinder);\n      function CharCodeFinder(targetCharCodes) {\n        var _this14;\n        _classCallCheck(this, CharCodeFinder);\n        _this14 = _super11.call(this);\n        _this14.targetCharCodes = targetCharCodes;\n        _this14.found = false;\n        return _this14;\n      }\n      _createClass(CharCodeFinder, [{\n        key: \"visitChildren\",\n        value: function visitChildren(node) {\n          if (this.found === true) {\n            return;\n          }\n          switch (node.type) {\n            case \"Lookahead\":\n              this.visitLookahead(node);\n              return;\n            case \"NegativeLookahead\":\n              this.visitNegativeLookahead(node);\n              return;\n          }\n          _get(_getPrototypeOf(CharCodeFinder.prototype), \"visitChildren\", this).call(this, node);\n        }\n      }, {\n        key: \"visitCharacter\",\n        value: function visitCharacter(node) {\n          if (includes(this.targetCharCodes, node.value)) {\n            this.found = true;\n          }\n        }\n      }, {\n        key: \"visitSet\",\n        value: function visitSet(node) {\n          if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === void 0) {\n              this.found = true;\n            }\n          } else {\n            if (findCode(node, this.targetCharCodes) !== void 0) {\n              this.found = true;\n            }\n          }\n        }\n      }]);\n      return CharCodeFinder;\n    }(BaseRegExpVisitor);\n    function canMatchCharCode(charCodes, pattern) {\n      if (pattern instanceof RegExp) {\n        var ast = getRegExpAst(pattern);\n        var charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n      } else {\n        return find$1(pattern, function (char) {\n          return includes(charCodes, char.charCodeAt(0));\n        }) !== void 0;\n      }\n    }\n    var PATTERN = \"PATTERN\";\n    var DEFAULT_MODE = \"defaultMode\";\n    var MODES = \"modes\";\n    var SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\n    function analyzeTokenTypes(tokenTypes, options) {\n      options = defaults$1(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: function tracer(msg, action) {\n          return action();\n        }\n      });\n      var tracer = options.tracer;\n      tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n        initCharCodeToOptimizedIndexMap();\n      });\n      var onlyRelevantTypes;\n      tracer(\"Reject Lexer.NA\", function () {\n        onlyRelevantTypes = reject(tokenTypes, function (currType) {\n          return currType[PATTERN] === Lexer2.NA;\n        });\n      });\n      var hasCustom = false;\n      var allTransformedPatterns;\n      tracer(\"Transform Patterns\", function () {\n        hasCustom = false;\n        allTransformedPatterns = map(onlyRelevantTypes, function (currType) {\n          var currPattern = currType[PATTERN];\n          if (isRegExp$1(currPattern)) {\n            var regExpSource = currPattern.source;\n            if (regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) {\n              return regExpSource;\n            } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" &&\n            // not a meta character\n            !includes([\"d\", \"D\", \"s\", \"S\", \"t\", \"r\", \"n\", \"t\", \"0\", \"c\", \"b\", \"B\", \"f\", \"v\", \"w\", \"W\"], regExpSource[1])) {\n              return regExpSource[1];\n            } else {\n              return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n            }\n          } else if (isFunction(currPattern)) {\n            hasCustom = true;\n            return {\n              exec: currPattern\n            };\n          } else if (typeof currPattern === \"object\") {\n            hasCustom = true;\n            return currPattern;\n          } else if (typeof currPattern === \"string\") {\n            if (currPattern.length === 1) {\n              return currPattern;\n            } else {\n              var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n              var wrappedRegExp = new RegExp(escapedRegExpString);\n              return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n            }\n          } else {\n            throw Error(\"non exhaustive match\");\n          }\n        });\n      });\n      var patternIdxToType;\n      var patternIdxToGroup;\n      var patternIdxToLongerAltIdxArr;\n      var patternIdxToPushMode;\n      var patternIdxToPopMode;\n      tracer(\"misc mapping\", function () {\n        patternIdxToType = map(onlyRelevantTypes, function (currType) {\n          return currType.tokenTypeIdx;\n        });\n        patternIdxToGroup = map(onlyRelevantTypes, function (clazz) {\n          var groupName = clazz.GROUP;\n          if (groupName === Lexer2.SKIPPED) {\n            return void 0;\n          } else if (isString(groupName)) {\n            return groupName;\n          } else if (isUndefined(groupName)) {\n            return false;\n          } else {\n            throw Error(\"non exhaustive match\");\n          }\n        });\n        patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, function (clazz) {\n          var longerAltType = clazz.LONGER_ALT;\n          if (longerAltType) {\n            var longerAltIdxArr = isArray$1(longerAltType) ? map(longerAltType, function (type) {\n              return indexOf(onlyRelevantTypes, type);\n            }) : [indexOf(onlyRelevantTypes, longerAltType)];\n            return longerAltIdxArr;\n          }\n        });\n        patternIdxToPushMode = map(onlyRelevantTypes, function (clazz) {\n          return clazz.PUSH_MODE;\n        });\n        patternIdxToPopMode = map(onlyRelevantTypes, function (clazz) {\n          return has(clazz, \"POP_MODE\");\n        });\n      });\n      var patternIdxToCanLineTerminator;\n      tracer(\"Line Terminator Handling\", function () {\n        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n          return false;\n        });\n        if (options.positionTracking !== \"onlyOffset\") {\n          patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n            if (has(tokType, \"LINE_BREAKS\")) {\n              return !!tokType.LINE_BREAKS;\n            } else {\n              return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n          });\n        }\n      });\n      var patternIdxToIsCustom;\n      var patternIdxToShort;\n      var emptyGroups;\n      var patternIdxToConfig;\n      tracer(\"Misc Mapping #2\", function () {\n        patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n        emptyGroups = reduce(onlyRelevantTypes, function (acc, clazz) {\n          var groupName = clazz.GROUP;\n          if (isString(groupName) && !(groupName === Lexer2.SKIPPED)) {\n            acc[groupName] = [];\n          }\n          return acc;\n        }, {});\n        patternIdxToConfig = map(allTransformedPatterns, function (x, idx) {\n          return {\n            pattern: allTransformedPatterns[idx],\n            longerAlt: patternIdxToLongerAltIdxArr[idx],\n            canLineTerminator: patternIdxToCanLineTerminator[idx],\n            isCustom: patternIdxToIsCustom[idx],\n            short: patternIdxToShort[idx],\n            group: patternIdxToGroup[idx],\n            push: patternIdxToPushMode[idx],\n            pop: patternIdxToPopMode[idx],\n            tokenTypeIdx: patternIdxToType[idx],\n            tokenType: onlyRelevantTypes[idx]\n          };\n        });\n      });\n      var canBeOptimized = true;\n      var charCodeToPatternIdxToConfig = [];\n      if (!options.safeMode) {\n        tracer(\"First Char Optimization\", function () {\n          charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, function (result, currTokType, idx) {\n            if (typeof currTokType.PATTERN === \"string\") {\n              var charCode = currTokType.PATTERN.charCodeAt(0);\n              var optimizedIdx = charCodeToOptimizedIndex(charCode);\n              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n            } else if (isArray$1(currTokType.START_CHARS_HINT)) {\n              var lastOptimizedIdx;\n              forEach(currTokType.START_CHARS_HINT, function (charOrInt) {\n                var charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n                var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                if (lastOptimizedIdx !== currOptimizedIdx) {\n                  lastOptimizedIdx = currOptimizedIdx;\n                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                }\n              });\n            } else if (isRegExp$1(currTokType.PATTERN)) {\n              if (currTokType.PATTERN.unicode) {\n                canBeOptimized = false;\n                if (options.ensureOptimizations) {\n                  PRINT_ERROR(\"\".concat(failedOptimizationPrefixMsg, \"\\tUnable to analyze < \").concat(currTokType.PATTERN.toString(), \" > pattern.\\n\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\"));\n                }\n              } else {\n                var optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n                if (isEmpty(optimizedCodes)) {\n                  canBeOptimized = false;\n                }\n                forEach(optimizedCodes, function (code) {\n                  addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                });\n              }\n            } else {\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\"\".concat(failedOptimizationPrefixMsg, \"\\tTokenType: <\").concat(currTokType.name, \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\"));\n              }\n              canBeOptimized = false;\n            }\n            return result;\n          }, []);\n        });\n      }\n      return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized\n      };\n    }\n    function validatePatterns(tokenTypes, validModesNames) {\n      var errors = [];\n      var missingResult = findMissingPatterns(tokenTypes);\n      errors = errors.concat(missingResult.errors);\n      var invalidResult = findInvalidPatterns(missingResult.valid);\n      var validTokenTypes = invalidResult.valid;\n      errors = errors.concat(invalidResult.errors);\n      errors = errors.concat(validateRegExpPattern(validTokenTypes));\n      errors = errors.concat(findInvalidGroupType(validTokenTypes));\n      errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n      errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n      return errors;\n    }\n    function validateRegExpPattern(tokenTypes) {\n      var errors = [];\n      var withRegExpPatterns = filter(tokenTypes, function (currTokType) {\n        return isRegExp$1(currTokType[PATTERN]);\n      });\n      errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n      errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n      errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n      errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n      errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n      return errors;\n    }\n    function findMissingPatterns(tokenTypes) {\n      var tokenTypesWithMissingPattern = filter(tokenTypes, function (currType) {\n        return !has(currType, PATTERN);\n      });\n      var errors = map(tokenTypesWithMissingPattern, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n          type: LexerDefinitionErrorType.MISSING_PATTERN,\n          tokenTypes: [currType]\n        };\n      });\n      var valid = difference$1(tokenTypes, tokenTypesWithMissingPattern);\n      return {\n        errors: errors,\n        valid: valid\n      };\n    }\n    function findInvalidPatterns(tokenTypes) {\n      var tokenTypesWithInvalidPattern = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return !isRegExp$1(pattern) && !isFunction(pattern) && !has(pattern, \"exec\") && !isString(pattern);\n      });\n      var errors = map(tokenTypesWithInvalidPattern, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n          type: LexerDefinitionErrorType.INVALID_PATTERN,\n          tokenTypes: [currType]\n        };\n      });\n      var valid = difference$1(tokenTypes, tokenTypesWithInvalidPattern);\n      return {\n        errors: errors,\n        valid: valid\n      };\n    }\n    var end_of_input = /[^\\\\][$]/;\n    function findEndOfInputAnchor(tokenTypes) {\n      var EndAnchorFinder = /*#__PURE__*/function (_BaseRegExpVisitor2) {\n        _inherits(EndAnchorFinder, _BaseRegExpVisitor2);\n        var _super12 = _createSuper(EndAnchorFinder);\n        function EndAnchorFinder() {\n          var _this15;\n          _classCallCheck(this, EndAnchorFinder);\n          _this15 = _super12.apply(this, arguments);\n          _this15.found = false;\n          return _this15;\n        }\n        _createClass(EndAnchorFinder, [{\n          key: \"visitEndAnchor\",\n          value: function visitEndAnchor(node) {\n            this.found = true;\n          }\n        }]);\n        return EndAnchorFinder;\n      }(BaseRegExpVisitor);\n      var invalidRegex = filter(tokenTypes, function (currType) {\n        var pattern = currType.PATTERN;\n        try {\n          var regexpAst = getRegExpAst(pattern);\n          var endAnchorVisitor = new EndAnchorFinder();\n          endAnchorVisitor.visit(regexpAst);\n          return endAnchorVisitor.found;\n        } catch (e) {\n          return end_of_input.test(pattern.source);\n        }\n      });\n      var errors = map(invalidRegex, function (currType) {\n        return {\n          message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n          type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    function findEmptyMatchRegExps(tokenTypes) {\n      var matchesEmptyString = filter(tokenTypes, function (currType) {\n        var pattern = currType.PATTERN;\n        return pattern.test(\"\");\n      });\n      var errors = map(matchesEmptyString, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n          type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    var start_of_input = /[^\\\\[][\\^]|^\\^/;\n    function findStartOfInputAnchor(tokenTypes) {\n      var StartAnchorFinder = /*#__PURE__*/function (_BaseRegExpVisitor3) {\n        _inherits(StartAnchorFinder, _BaseRegExpVisitor3);\n        var _super13 = _createSuper(StartAnchorFinder);\n        function StartAnchorFinder() {\n          var _this16;\n          _classCallCheck(this, StartAnchorFinder);\n          _this16 = _super13.apply(this, arguments);\n          _this16.found = false;\n          return _this16;\n        }\n        _createClass(StartAnchorFinder, [{\n          key: \"visitStartAnchor\",\n          value: function visitStartAnchor(node) {\n            this.found = true;\n          }\n        }]);\n        return StartAnchorFinder;\n      }(BaseRegExpVisitor);\n      var invalidRegex = filter(tokenTypes, function (currType) {\n        var pattern = currType.PATTERN;\n        try {\n          var regexpAst = getRegExpAst(pattern);\n          var startAnchorVisitor = new StartAnchorFinder();\n          startAnchorVisitor.visit(regexpAst);\n          return startAnchorVisitor.found;\n        } catch (e) {\n          return start_of_input.test(pattern.source);\n        }\n      });\n      var errors = map(invalidRegex, function (currType) {\n        return {\n          message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n          type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    function findUnsupportedFlags(tokenTypes) {\n      var invalidFlags = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n      });\n      var errors = map(invalidFlags, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n          type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    function findDuplicatePatterns(tokenTypes) {\n      var found = [];\n      var identicalPatterns = map(tokenTypes, function (outerType) {\n        return reduce(tokenTypes, function (result, innerType) {\n          if (outerType.PATTERN.source === innerType.PATTERN.source && !includes(found, innerType) && innerType.PATTERN !== Lexer2.NA) {\n            found.push(innerType);\n            result.push(innerType);\n            return result;\n          }\n          return result;\n        }, []);\n      });\n      identicalPatterns = compact(identicalPatterns);\n      var duplicatePatterns = filter(identicalPatterns, function (currIdenticalSet) {\n        return currIdenticalSet.length > 1;\n      });\n      var errors = map(duplicatePatterns, function (setOfIdentical) {\n        var tokenTypeNames = map(setOfIdentical, function (currType) {\n          return currType.name;\n        });\n        var dupPatternSrc = head(setOfIdentical).PATTERN;\n        return {\n          message: \"The same RegExp pattern ->\".concat(dupPatternSrc, \"<-has been used in all of the following Token Types: \").concat(tokenTypeNames.join(\", \"), \" <-\"),\n          type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n          tokenTypes: setOfIdentical\n        };\n      });\n      return errors;\n    }\n    function findInvalidGroupType(tokenTypes) {\n      var invalidTypes = filter(tokenTypes, function (clazz) {\n        if (!has(clazz, \"GROUP\")) {\n          return false;\n        }\n        var group = clazz.GROUP;\n        return group !== Lexer2.SKIPPED && group !== Lexer2.NA && !isString(group);\n      });\n      var errors = map(invalidTypes, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n          type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    function findModesThatDoNotExist(tokenTypes, validModes) {\n      var invalidModes = filter(tokenTypes, function (clazz) {\n        return clazz.PUSH_MODE !== void 0 && !includes(validModes, clazz.PUSH_MODE);\n      });\n      var errors = map(invalidModes, function (tokType) {\n        var msg = \"Token Type: ->\".concat(tokType.name, \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\").concat(tokType.PUSH_MODE, \"<-which does not exist\");\n        return {\n          message: msg,\n          type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n          tokenTypes: [tokType]\n        };\n      });\n      return errors;\n    }\n    function findUnreachablePatterns(tokenTypes) {\n      var errors = [];\n      var canBeTested = reduce(tokenTypes, function (result, tokType, idx) {\n        var pattern = tokType.PATTERN;\n        if (pattern === Lexer2.NA) {\n          return result;\n        }\n        if (isString(pattern)) {\n          result.push({\n            str: pattern,\n            idx: idx,\n            tokenType: tokType\n          });\n        } else if (isRegExp$1(pattern) && noMetaChar(pattern)) {\n          result.push({\n            str: pattern.source,\n            idx: idx,\n            tokenType: tokType\n          });\n        }\n        return result;\n      }, []);\n      forEach(tokenTypes, function (tokType, testIdx) {\n        forEach(canBeTested, function (_ref2) {\n          var str = _ref2.str,\n            idx = _ref2.idx,\n            tokenType = _ref2.tokenType;\n          if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n            var msg = \"Token: ->\".concat(tokenType.name, \"<- can never be matched.\\nBecause it appears AFTER the Token Type ->\").concat(tokType.name, \"<-in the lexer's definition.\\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE\");\n            errors.push({\n              message: msg,\n              type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n              tokenTypes: [tokType, tokenType]\n            });\n          }\n        });\n      });\n      return errors;\n    }\n    function testTokenType(str, pattern) {\n      if (isRegExp$1(pattern)) {\n        var regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n      } else if (isFunction(pattern)) {\n        return pattern(str, 0, [], {});\n      } else if (has(pattern, \"exec\")) {\n        return pattern.exec(str, 0, [], {});\n      } else if (typeof pattern === \"string\") {\n        return pattern === str;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function noMetaChar(regExp) {\n      var metaChars = [\".\", \"\\\\\", \"[\", \"]\", \"|\", \"^\", \"$\", \"(\", \")\", \"?\", \"*\", \"+\", \"{\"];\n      return find$1(metaChars, function (char) {\n        return regExp.source.indexOf(char) !== -1;\n      }) === void 0;\n    }\n    function addStartOfInput(pattern) {\n      var flags = pattern.ignoreCase ? \"i\" : \"\";\n      return new RegExp(\"^(?:\".concat(pattern.source, \")\"), flags);\n    }\n    function addStickyFlag(pattern) {\n      var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n      return new RegExp(\"\".concat(pattern.source), flags);\n    }\n    function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n      var errors = [];\n      if (!has(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n          message: \"A MultiMode Lexer cannot be initialized without a <\" + DEFAULT_MODE + \"> property in its definition\\n\",\n          type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n        });\n      }\n      if (!has(lexerDefinition, MODES)) {\n        errors.push({\n          message: \"A MultiMode Lexer cannot be initialized without a <\" + MODES + \"> property in its definition\\n\",\n          type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n        });\n      }\n      if (has(lexerDefinition, MODES) && has(lexerDefinition, DEFAULT_MODE) && !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n          message: \"A MultiMode Lexer cannot be initialized with a \".concat(DEFAULT_MODE, \": <\").concat(lexerDefinition.defaultMode, \">which does not exist\\n\"),\n          type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n        });\n      }\n      if (has(lexerDefinition, MODES)) {\n        forEach(lexerDefinition.modes, function (currModeValue, currModeName) {\n          forEach(currModeValue, function (currTokType, currIdx) {\n            if (isUndefined(currTokType)) {\n              errors.push({\n                message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:<\".concat(currModeName, \"> at index: <\").concat(currIdx, \">\\n\"),\n                type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n              });\n            } else if (has(currTokType, \"LONGER_ALT\")) {\n              var longerAlt = isArray$1(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];\n              forEach(longerAlt, function (currLongerAlt) {\n                if (!isUndefined(currLongerAlt) && !includes(currModeValue, currLongerAlt)) {\n                  errors.push({\n                    message: \"A MultiMode Lexer cannot be initialized with a longer_alt <\".concat(currLongerAlt.name, \"> on token <\").concat(currTokType.name, \"> outside of mode <\").concat(currModeName, \">\\n\"),\n                    type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n                  });\n                }\n              });\n            }\n          });\n        });\n      }\n      return errors;\n    }\n    function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n      var warnings = [];\n      var hasAnyLineBreak = false;\n      var allTokenTypes = compact(flatten(values(lexerDefinition.modes)));\n      var concreteTokenTypes = reject(allTokenTypes, function (currType) {\n        return currType[PATTERN] === Lexer2.NA;\n      });\n      var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n      if (trackLines) {\n        forEach(concreteTokenTypes, function (tokType) {\n          var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n          if (currIssue !== false) {\n            var message = buildLineBreakIssueMessage(tokType, currIssue);\n            var warningDescriptor = {\n              message: message,\n              type: currIssue.issue,\n              tokenType: tokType\n            };\n            warnings.push(warningDescriptor);\n          } else {\n            if (has(tokType, \"LINE_BREAKS\")) {\n              if (tokType.LINE_BREAKS === true) {\n                hasAnyLineBreak = true;\n              }\n            } else {\n              if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n                hasAnyLineBreak = true;\n              }\n            }\n          }\n        });\n      }\n      if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n          message: \"Warning: No LINE_BREAKS Found.\\n\tThis Lexer has been defined to track line and column information,\\n\tBut none of the Token Types can be identified as matching a line terminator.\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\tfor details.\",\n          type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n        });\n      }\n      return warnings;\n    }\n    function cloneEmptyGroups(emptyGroups) {\n      var clonedResult = {};\n      var groupKeys = keys(emptyGroups);\n      forEach(groupKeys, function (currKey) {\n        var currGroupValue = emptyGroups[currKey];\n        if (isArray$1(currGroupValue)) {\n          clonedResult[currKey] = [];\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n      });\n      return clonedResult;\n    }\n    function isCustomPattern(tokenType) {\n      var pattern = tokenType.PATTERN;\n      if (isRegExp$1(pattern)) {\n        return false;\n      } else if (isFunction(pattern)) {\n        return true;\n      } else if (has(pattern, \"exec\")) {\n        return true;\n      } else if (isString(pattern)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function isShortPattern(pattern) {\n      if (isString(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n      } else {\n        return false;\n      }\n    }\n    var LineTerminatorOptimizedTester = {\n      // implements /\\n|\\r\\n?/g.test\n      test: function test(text) {\n        var len = text.length;\n        for (var _i6 = this.lastIndex; _i6 < len; _i6++) {\n          var c = text.charCodeAt(_i6);\n          if (c === 10) {\n            this.lastIndex = _i6 + 1;\n            return true;\n          } else if (c === 13) {\n            if (text.charCodeAt(_i6 + 1) === 10) {\n              this.lastIndex = _i6 + 2;\n            } else {\n              this.lastIndex = _i6 + 1;\n            }\n            return true;\n          }\n        }\n        return false;\n      },\n      lastIndex: 0\n    };\n    function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n      if (has(tokType, \"LINE_BREAKS\")) {\n        return false;\n      } else {\n        if (isRegExp$1(tokType.PATTERN)) {\n          try {\n            canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n          } catch (e) {\n            return {\n              issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n              errMsg: e.message\n            };\n          }\n          return false;\n        } else if (isString(tokType.PATTERN)) {\n          return false;\n        } else if (isCustomPattern(tokType)) {\n          return {\n            issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n          };\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n      }\n    }\n    function buildLineBreakIssueMessage(tokType, details) {\n      if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return \"Warning: unable to identify line terminator usage in pattern.\\n\\tThe problem is in the <\".concat(tokType.name, \"> Token Type\\n\\t Root cause: \").concat(details.errMsg, \".\\n\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n      } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\\tThe problem is in the <\".concat(tokType.name, \"> Token Type\\n\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function getCharCodes(charsOrCodes) {\n      var charCodes = map(charsOrCodes, function (numOrString) {\n        if (isString(numOrString)) {\n          return numOrString.charCodeAt(0);\n        } else {\n          return numOrString;\n        }\n      });\n      return charCodes;\n    }\n    function addToMapOfArrays(map2, key, value) {\n      if (map2[key] === void 0) {\n        map2[key] = [value];\n      } else {\n        map2[key].push(value);\n      }\n    }\n    var minOptimizationVal = 256;\n    var charCodeToOptimizedIdxMap = [];\n    function charCodeToOptimizedIndex(charCode) {\n      return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n    }\n    function initCharCodeToOptimizedIndexMap() {\n      if (isEmpty(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (var _i7 = 0; _i7 < 65536; _i7++) {\n          charCodeToOptimizedIdxMap[_i7] = _i7 > 255 ? 255 + ~~(_i7 / 255) : _i7;\n        }\n      }\n    }\n    function tokenStructuredMatcher(tokInstance, tokConstructor) {\n      var instanceType = tokInstance.tokenTypeIdx;\n      if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n      } else {\n        return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n      }\n    }\n    function tokenStructuredMatcherNoCategories(token, tokType) {\n      return token.tokenTypeIdx === tokType.tokenTypeIdx;\n    }\n    var tokenShortNameIdx = 1;\n    var tokenIdxToClass = {};\n    function augmentTokenTypes(tokenTypes) {\n      var tokenTypesAndParents = expandCategories(tokenTypes);\n      assignTokenDefaultProps(tokenTypesAndParents);\n      assignCategoriesMapProp(tokenTypesAndParents);\n      assignCategoriesTokensProp(tokenTypesAndParents);\n      forEach(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n      });\n    }\n    function expandCategories(tokenTypes) {\n      var result = clone(tokenTypes);\n      var categories = tokenTypes;\n      var searching = true;\n      while (searching) {\n        categories = compact(flatten(map(categories, function (currTokType) {\n          return currTokType.CATEGORIES;\n        })));\n        var newCategories = difference$1(categories, result);\n        result = result.concat(newCategories);\n        if (isEmpty(newCategories)) {\n          searching = false;\n        } else {\n          categories = newCategories;\n        }\n      }\n      return result;\n    }\n    function assignTokenDefaultProps(tokenTypes) {\n      forEach(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n          tokenIdxToClass[tokenShortNameIdx] = currTokType;\n          currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        if (hasCategoriesProperty(currTokType) && !isArray$1(currTokType.CATEGORIES)) {\n          currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n          currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n          currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n          currTokType.categoryMatchesMap = {};\n        }\n      });\n    }\n    function assignCategoriesTokensProp(tokenTypes) {\n      forEach(tokenTypes, function (currTokType) {\n        currTokType.categoryMatches = [];\n        forEach(currTokType.categoryMatchesMap, function (val, key) {\n          currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n      });\n    }\n    function assignCategoriesMapProp(tokenTypes) {\n      forEach(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n      });\n    }\n    function singleAssignCategoriesToksMap(path, nextNode) {\n      forEach(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n      });\n      forEach(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        if (!includes(newPath, nextCategory)) {\n          singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n      });\n    }\n    function hasShortKeyProperty(tokType) {\n      return has(tokType, \"tokenTypeIdx\");\n    }\n    function hasCategoriesProperty(tokType) {\n      return has(tokType, \"CATEGORIES\");\n    }\n    function hasExtendingTokensTypesProperty(tokType) {\n      return has(tokType, \"categoryMatches\");\n    }\n    function hasExtendingTokensTypesMapProperty(tokType) {\n      return has(tokType, \"categoryMatchesMap\");\n    }\n    function isTokenType(tokType) {\n      return has(tokType, \"tokenTypeIdx\");\n    }\n    var defaultLexerErrorProvider = {\n      buildUnableToPopLexerModeMessage: function buildUnableToPopLexerModeMessage(token) {\n        return \"Unable to pop Lexer Mode after encountering Token ->\".concat(token.image, \"<- The Mode Stack is empty\");\n      },\n      buildUnexpectedCharactersMessage: function buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return \"unexpected character: ->\".concat(fullText.charAt(startOffset), \"<- at offset: \").concat(startOffset, \", skipped \").concat(length, \" characters.\");\n      }\n    };\n    var LexerDefinitionErrorType;\n    (function (LexerDefinitionErrorType2) {\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n    })(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\n    var DEFAULT_LEXER_CONFIG = {\n      deferDefinitionErrorsHandling: false,\n      positionTracking: \"full\",\n      lineTerminatorsPattern: /\\n|\\r\\n?/g,\n      lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n      ensureOptimizations: false,\n      safeMode: false,\n      errorMessageProvider: defaultLexerErrorProvider,\n      traceInitPerf: false,\n      skipValidations: false,\n      recoveryEnabled: true\n    };\n    Object.freeze(DEFAULT_LEXER_CONFIG);\n    var Lexer2 = /*#__PURE__*/function () {\n      function Lexer2(lexerDefinition) {\n        var _this17 = this;\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LEXER_CONFIG;\n        _classCallCheck(this, Lexer2);\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        this.TRACE_INIT = function (phaseDesc, phaseImpl) {\n          if (_this17.traceInitPerf === true) {\n            _this17.traceInitIndent++;\n            var indent = new Array(_this17.traceInitIndent + 1).join(\"\t\");\n            if (_this17.traceInitIndent < _this17.traceInitMaxIdent) {\n              console.log(\"\".concat(indent, \"--> <\").concat(phaseDesc, \">\"));\n            }\n            var _timer = timer(phaseImpl),\n              time = _timer.time,\n              value = _timer.value;\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (_this17.traceInitIndent < _this17.traceInitMaxIdent) {\n              traceMethod(\"\".concat(indent, \"<-- <\").concat(phaseDesc, \"> time: \").concat(time, \"ms\"));\n            }\n            _this17.traceInitIndent--;\n            return value;\n          } else {\n            return phaseImpl();\n          }\n        };\n        if (typeof config === \"boolean\") {\n          throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\na boolean 2nd argument is no longer supported\");\n        }\n        this.config = assign$1({}, DEFAULT_LEXER_CONFIG, config);\n        var traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n          this.traceInitMaxIdent = Infinity;\n          this.traceInitPerf = true;\n        } else if (typeof traceInitVal === \"number\") {\n          this.traceInitMaxIdent = traceInitVal;\n          this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", function () {\n          var actualDefinition;\n          var hasOnlySingleMode = true;\n          _this17.TRACE_INIT(\"Lexer Config handling\", function () {\n            if (_this17.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n              _this17.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n            } else {\n              if (_this17.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n              }\n            }\n            if (config.safeMode && config.ensureOptimizations) {\n              throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n            }\n            _this17.trackStartLines = /full|onlyStart/i.test(_this17.config.positionTracking);\n            _this17.trackEndLines = /full/i.test(_this17.config.positionTracking);\n            if (isArray$1(lexerDefinition)) {\n              actualDefinition = {\n                modes: {\n                  defaultMode: clone(lexerDefinition)\n                },\n                defaultMode: DEFAULT_MODE\n              };\n            } else {\n              hasOnlySingleMode = false;\n              actualDefinition = clone(lexerDefinition);\n            }\n          });\n          if (_this17.config.skipValidations === false) {\n            _this17.TRACE_INIT(\"performRuntimeChecks\", function () {\n              _this17.lexerDefinitionErrors = _this17.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this17.trackStartLines, _this17.config.lineTerminatorCharacters));\n            });\n            _this17.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n              _this17.lexerDefinitionWarning = _this17.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this17.trackStartLines, _this17.config.lineTerminatorCharacters));\n            });\n          }\n          actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n          forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n            actualDefinition.modes[currModeName] = reject(currModeValue, function (currTokType) {\n              return isUndefined(currTokType);\n            });\n          });\n          var allModeNames = keys(actualDefinition.modes);\n          forEach(actualDefinition.modes, function (currModDef, currModName) {\n            _this17.TRACE_INIT(\"Mode: <\".concat(currModName, \"> processing\"), function () {\n              _this17.modes.push(currModName);\n              if (_this17.config.skipValidations === false) {\n                _this17.TRACE_INIT(\"validatePatterns\", function () {\n                  _this17.lexerDefinitionErrors = _this17.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n                });\n              }\n              if (isEmpty(_this17.lexerDefinitionErrors)) {\n                augmentTokenTypes(currModDef);\n                var currAnalyzeResult;\n                _this17.TRACE_INIT(\"analyzeTokenTypes\", function () {\n                  currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                    lineTerminatorCharacters: _this17.config.lineTerminatorCharacters,\n                    positionTracking: config.positionTracking,\n                    ensureOptimizations: config.ensureOptimizations,\n                    safeMode: config.safeMode,\n                    tracer: _this17.TRACE_INIT\n                  });\n                });\n                _this17.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig;\n                _this17.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig;\n                _this17.emptyGroups = assign$1({}, _this17.emptyGroups, currAnalyzeResult.emptyGroups);\n                _this17.hasCustom = currAnalyzeResult.hasCustom || _this17.hasCustom;\n                _this17.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized;\n              }\n            });\n          });\n          _this17.defaultMode = actualDefinition.defaultMode;\n          if (!isEmpty(_this17.lexerDefinitionErrors) && !_this17.config.deferDefinitionErrorsHandling) {\n            var allErrMessages = map(_this17.lexerDefinitionErrors, function (error) {\n              return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n          }\n          forEach(_this17.lexerDefinitionWarning, function (warningDescriptor) {\n            PRINT_WARNING(warningDescriptor.message);\n          });\n          _this17.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n            if (SUPPORT_STICKY) {\n              _this17.chopInput = identity;\n              _this17.match = _this17.matchWithTest;\n            } else {\n              _this17.updateLastIndex = noop;\n              _this17.match = _this17.matchWithExec;\n            }\n            if (hasOnlySingleMode) {\n              _this17.handleModes = noop;\n            }\n            if (_this17.trackStartLines === false) {\n              _this17.computeNewColumn = identity;\n            }\n            if (_this17.trackEndLines === false) {\n              _this17.updateTokenEndLineColumnLocation = noop;\n            }\n            if (/full/i.test(_this17.config.positionTracking)) {\n              _this17.createTokenInstance = _this17.createFullToken;\n            } else if (/onlyStart/i.test(_this17.config.positionTracking)) {\n              _this17.createTokenInstance = _this17.createStartOnlyToken;\n            } else if (/onlyOffset/i.test(_this17.config.positionTracking)) {\n              _this17.createTokenInstance = _this17.createOffsetOnlyToken;\n            } else {\n              throw Error(\"Invalid <positionTracking> config option: \\\"\".concat(_this17.config.positionTracking, \"\\\"\"));\n            }\n            if (_this17.hasCustom) {\n              _this17.addToken = _this17.addTokenUsingPush;\n              _this17.handlePayload = _this17.handlePayloadWithCustom;\n            } else {\n              _this17.addToken = _this17.addTokenUsingMemberAccess;\n              _this17.handlePayload = _this17.handlePayloadNoCustom;\n            }\n          });\n          _this17.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n            var unOptimizedModes = reduce(_this17.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n              if (canBeOptimized === false) {\n                cannotBeOptimized.push(modeName);\n              }\n              return cannotBeOptimized;\n            }, []);\n            if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n              throw Error(\"Lexer Modes: < \".concat(unOptimizedModes.join(\", \"), \" > cannot be optimized.\\n\\t Disable the \\\"ensureOptimizations\\\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n\\t Or inspect the console log for details on how to resolve these issues.\"));\n            }\n          });\n          _this17.TRACE_INIT(\"clearRegExpParserCache\", function () {\n            clearRegExpParserCache();\n          });\n          _this17.TRACE_INIT(\"toFastProperties\", function () {\n            toFastProperties(_this17);\n          });\n        });\n      }\n      _createClass(Lexer2, [{\n        key: \"tokenize\",\n        value: function tokenize(text) {\n          var initialMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultMode;\n          if (!isEmpty(this.lexerDefinitionErrors)) {\n            var allErrMessages = map(this.lexerDefinitionErrors, function (error) {\n              return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n          }\n          return this.tokenizeInternal(text, initialMode);\n        }\n        // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n        // This is intentional due to performance considerations.\n        // this method also used quite a bit of `!` none null assertions because it is too optimized\n        // for `tsc` to always understand it is \"safe\"\n      }, {\n        key: \"tokenizeInternal\",\n        value: function tokenizeInternal(text, initialMode) {\n          var _this18 = this;\n          var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, msg, match;\n          var orgText = text;\n          var orgLength = orgText.length;\n          var offset = 0;\n          var matchedTokensIndex = 0;\n          var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);\n          var matchedTokens = new Array(guessedNumberOfTokens);\n          var errors = [];\n          var line = this.trackStartLines ? 1 : void 0;\n          var column = this.trackStartLines ? 1 : void 0;\n          var groups = cloneEmptyGroups(this.emptyGroups);\n          var trackLines = this.trackStartLines;\n          var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n          var currModePatternsLength = 0;\n          var patternIdxToConfig = [];\n          var currCharCodeToPatternIdxToConfig = [];\n          var modeStack = [];\n          var emptyArray = [];\n          Object.freeze(emptyArray);\n          var getPossiblePatterns;\n          function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n          }\n          function getPossiblePatternsOptimized(charCode) {\n            var optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === void 0) {\n              return emptyArray;\n            } else {\n              return possiblePatterns;\n            }\n          }\n          var pop_mode = function pop_mode(popToken) {\n            if (modeStack.length === 1 &&\n            // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n            // So no error should occur.\n            popToken.tokenType.PUSH_MODE === void 0) {\n              var msg2 = _this18.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n              errors.push({\n                offset: popToken.startOffset,\n                line: popToken.startLine,\n                column: popToken.startColumn,\n                length: popToken.image.length,\n                message: msg2\n              });\n            } else {\n              modeStack.pop();\n              var newMode = last(modeStack);\n              patternIdxToConfig = _this18.patternIdxToConfig[newMode];\n              currCharCodeToPatternIdxToConfig = _this18.charCodeToPatternIdxToConfig[newMode];\n              currModePatternsLength = patternIdxToConfig.length;\n              var modeCanBeOptimized = _this18.canModeBeOptimized[newMode] && _this18.config.safeMode === false;\n              if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n              } else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n              }\n            }\n          };\n          function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n              getPossiblePatterns = getPossiblePatternsOptimized;\n            } else {\n              getPossiblePatterns = getPossiblePatternsSlow;\n            }\n          }\n          push_mode.call(this, initialMode);\n          var currConfig;\n          var recoveryEnabled = this.config.recoveryEnabled;\n          while (offset < orgLength) {\n            matchedImage = null;\n            var nextCharCode = orgText.charCodeAt(offset);\n            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            var chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n              currConfig = chosenPatternIdxToConfig[i];\n              var currPattern = currConfig.pattern;\n              payload = null;\n              var singleCharCode = currConfig.short;\n              if (singleCharCode !== false) {\n                if (nextCharCode === singleCharCode) {\n                  matchedImage = currPattern;\n                }\n              } else if (currConfig.isCustom === true) {\n                match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                if (match !== null) {\n                  matchedImage = match[0];\n                  if (match.payload !== void 0) {\n                    payload = match.payload;\n                  }\n                } else {\n                  matchedImage = null;\n                }\n              } else {\n                this.updateLastIndex(currPattern, offset);\n                matchedImage = this.match(currPattern, text, offset);\n              }\n              if (matchedImage !== null) {\n                longerAlt = currConfig.longerAlt;\n                if (longerAlt !== void 0) {\n                  var longerAltLength = longerAlt.length;\n                  for (k = 0; k < longerAltLength; k++) {\n                    var longerAltConfig = patternIdxToConfig[longerAlt[k]];\n                    var longerAltPattern = longerAltConfig.pattern;\n                    altPayload = null;\n                    if (longerAltConfig.isCustom === true) {\n                      match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                      if (match !== null) {\n                        matchAltImage = match[0];\n                        if (match.payload !== void 0) {\n                          altPayload = match.payload;\n                        }\n                      } else {\n                        matchAltImage = null;\n                      }\n                    } else {\n                      this.updateLastIndex(longerAltPattern, offset);\n                      matchAltImage = this.match(longerAltPattern, text, offset);\n                    }\n                    if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                      matchedImage = matchAltImage;\n                      payload = altPayload;\n                      currConfig = longerAltConfig;\n                      break;\n                    }\n                  }\n                }\n                break;\n              }\n            }\n            if (matchedImage !== null) {\n              imageLength = matchedImage.length;\n              group = currConfig.group;\n              if (group !== void 0) {\n                tokType = currConfig.tokenTypeIdx;\n                newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                this.handlePayload(newToken, payload);\n                if (group === false) {\n                  matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                } else {\n                  groups[group].push(newToken);\n                }\n              }\n              text = this.chopInput(text, imageLength);\n              offset = offset + imageLength;\n              column = this.computeNewColumn(column, imageLength);\n              if (trackLines === true && currConfig.canLineTerminator === true) {\n                var numOfLTsInMatch = 0;\n                var foundTerminator = void 0;\n                var lastLTEndOffset = void 0;\n                lineTerminatorPattern.lastIndex = 0;\n                do {\n                  foundTerminator = lineTerminatorPattern.test(matchedImage);\n                  if (foundTerminator === true) {\n                    lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                    numOfLTsInMatch++;\n                  }\n                } while (foundTerminator === true);\n                if (numOfLTsInMatch !== 0) {\n                  line = line + numOfLTsInMatch;\n                  column = imageLength - lastLTEndOffset;\n                  this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                }\n              }\n              this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            } else {\n              var errorStartOffset = offset;\n              var errorLine = line;\n              var errorColumn = column;\n              var foundResyncPoint = recoveryEnabled === false;\n              while (foundResyncPoint === false && offset < orgLength) {\n                text = this.chopInput(text, 1);\n                offset++;\n                for (j = 0; j < currModePatternsLength; j++) {\n                  var currConfig2 = patternIdxToConfig[j];\n                  var _currPattern = currConfig2.pattern;\n                  var _singleCharCode = currConfig2.short;\n                  if (_singleCharCode !== false) {\n                    if (orgText.charCodeAt(offset) === _singleCharCode) {\n                      foundResyncPoint = true;\n                    }\n                  } else if (currConfig2.isCustom === true) {\n                    foundResyncPoint = _currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                  } else {\n                    this.updateLastIndex(_currPattern, offset);\n                    foundResyncPoint = _currPattern.exec(text) !== null;\n                  }\n                  if (foundResyncPoint === true) {\n                    break;\n                  }\n                }\n              }\n              errLength = offset - errorStartOffset;\n              column = this.computeNewColumn(column, errLength);\n              msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n              errors.push({\n                offset: errorStartOffset,\n                line: errorLine,\n                column: errorColumn,\n                length: errLength,\n                message: msg\n              });\n              if (recoveryEnabled === false) {\n                break;\n              }\n            }\n          }\n          if (!this.hasCustom) {\n            matchedTokens.length = matchedTokensIndex;\n          }\n          return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n          };\n        }\n      }, {\n        key: \"handleModes\",\n        value: function handleModes(config, pop_mode, push_mode, newToken) {\n          if (config.pop === true) {\n            var pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== void 0) {\n              push_mode.call(this, pushMode);\n            }\n          } else if (config.push !== void 0) {\n            push_mode.call(this, config.push);\n          }\n        }\n      }, {\n        key: \"chopInput\",\n        value: function chopInput(text, length) {\n          return text.substring(length);\n        }\n      }, {\n        key: \"updateLastIndex\",\n        value: function updateLastIndex(regExp, newLastIndex) {\n          regExp.lastIndex = newLastIndex;\n        }\n        // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n      }, {\n        key: \"updateTokenEndLineColumnLocation\",\n        value: function updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n          var lastCharIsLT, fixForEndingInLT;\n          if (group !== void 0) {\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n              newToken.endLine = line + fixForEndingInLT;\n              newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n          }\n        }\n      }, {\n        key: \"computeNewColumn\",\n        value: function computeNewColumn(oldColumn, imageLength) {\n          return oldColumn + imageLength;\n        }\n      }, {\n        key: \"createOffsetOnlyToken\",\n        value: function createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n          return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n          };\n        }\n      }, {\n        key: \"createStartOnlyToken\",\n        value: function createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n          return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n          };\n        }\n      }, {\n        key: \"createFullToken\",\n        value: function createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n          return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n          };\n        }\n      }, {\n        key: \"addTokenUsingPush\",\n        value: function addTokenUsingPush(tokenVector, index, tokenToAdd) {\n          tokenVector.push(tokenToAdd);\n          return index;\n        }\n      }, {\n        key: \"addTokenUsingMemberAccess\",\n        value: function addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n          tokenVector[index] = tokenToAdd;\n          index++;\n          return index;\n        }\n      }, {\n        key: \"handlePayloadNoCustom\",\n        value: function handlePayloadNoCustom(token, payload) {}\n      }, {\n        key: \"handlePayloadWithCustom\",\n        value: function handlePayloadWithCustom(token, payload) {\n          if (payload !== null) {\n            token.payload = payload;\n          }\n        }\n      }, {\n        key: \"matchWithTest\",\n        value: function matchWithTest(pattern, text, offset) {\n          var found = pattern.test(text);\n          if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n          }\n          return null;\n        }\n      }, {\n        key: \"matchWithExec\",\n        value: function matchWithExec(pattern, text) {\n          var regExpArray = pattern.exec(text);\n          return regExpArray !== null ? regExpArray[0] : null;\n        }\n      }]);\n      return Lexer2;\n    }();\n    Lexer2.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n    Lexer2.NA = /NOT_APPLICABLE/;\n    function tokenLabel(tokType) {\n      if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n      } else {\n        return tokType.name;\n      }\n    }\n    function hasTokenLabel(obj) {\n      return isString(obj.LABEL) && obj.LABEL !== \"\";\n    }\n    var PARENT = \"parent\";\n    var CATEGORIES = \"categories\";\n    var LABEL = \"label\";\n    var GROUP = \"group\";\n    var PUSH_MODE = \"push_mode\";\n    var POP_MODE = \"pop_mode\";\n    var LONGER_ALT = \"longer_alt\";\n    var LINE_BREAKS = \"line_breaks\";\n    var START_CHARS_HINT = \"start_chars_hint\";\n    function createToken2(config) {\n      return createTokenInternal(config);\n    }\n    function createTokenInternal(config) {\n      var pattern = config.pattern;\n      var tokenType = {};\n      tokenType.name = config.name;\n      if (!isUndefined(pattern)) {\n        tokenType.PATTERN = pattern;\n      }\n      if (has(config, PARENT)) {\n        throw \"The parent property is no longer supported.\\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\";\n      }\n      if (has(config, CATEGORIES)) {\n        tokenType.CATEGORIES = config[CATEGORIES];\n      }\n      augmentTokenTypes([tokenType]);\n      if (has(config, LABEL)) {\n        tokenType.LABEL = config[LABEL];\n      }\n      if (has(config, GROUP)) {\n        tokenType.GROUP = config[GROUP];\n      }\n      if (has(config, POP_MODE)) {\n        tokenType.POP_MODE = config[POP_MODE];\n      }\n      if (has(config, PUSH_MODE)) {\n        tokenType.PUSH_MODE = config[PUSH_MODE];\n      }\n      if (has(config, LONGER_ALT)) {\n        tokenType.LONGER_ALT = config[LONGER_ALT];\n      }\n      if (has(config, LINE_BREAKS)) {\n        tokenType.LINE_BREAKS = config[LINE_BREAKS];\n      }\n      if (has(config, START_CHARS_HINT)) {\n        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n      }\n      return tokenType;\n    }\n    var EOF = createToken2({\n      name: \"EOF\",\n      pattern: Lexer2.NA\n    });\n    augmentTokenTypes([EOF]);\n    function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n      return {\n        image: image,\n        startOffset: startOffset,\n        endOffset: endOffset,\n        startLine: startLine,\n        endLine: endLine,\n        startColumn: startColumn,\n        endColumn: endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType\n      };\n    }\n    function tokenMatcher(token, tokType) {\n      return tokenStructuredMatcher(token, tokType);\n    }\n    var defaultParserErrorProvider = {\n      buildMismatchTokenMessage: function buildMismatchTokenMessage(_ref3) {\n        var expected = _ref3.expected,\n          actual = _ref3.actual,\n          previous = _ref3.previous,\n          ruleName = _ref3.ruleName;\n        var hasLabel = hasTokenLabel(expected);\n        var expectedMsg = hasLabel ? \"--> \".concat(tokenLabel(expected), \" <--\") : \"token of type --> \".concat(expected.name, \" <--\");\n        var msg = \"Expecting \".concat(expectedMsg, \" but found --> '\").concat(actual.image, \"' <--\");\n        return msg;\n      },\n      buildNotAllInputParsedMessage: function buildNotAllInputParsedMessage(_ref4) {\n        var firstRedundant = _ref4.firstRedundant,\n          ruleName = _ref4.ruleName;\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n      },\n      buildNoViableAltMessage: function buildNoViableAltMessage(_ref5) {\n        var expectedPathsPerAlt = _ref5.expectedPathsPerAlt,\n          actual = _ref5.actual,\n          previous = _ref5.previous,\n          customUserDescription = _ref5.customUserDescription,\n          ruleName = _ref5.ruleName;\n        var errPrefix = \"Expecting: \";\n        var actualText = head(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n          return errPrefix + customUserDescription + errSuffix;\n        } else {\n          var allLookAheadPaths = reduce(expectedPathsPerAlt, function (result, currAltPaths) {\n            return result.concat(currAltPaths);\n          }, []);\n          var nextValidTokenSequences = map(allLookAheadPaths, function (currPath) {\n            return \"[\".concat(map(currPath, function (currTokenType) {\n              return tokenLabel(currTokenType);\n            }).join(\", \"), \"]\");\n          });\n          var nextValidSequenceItems = map(nextValidTokenSequences, function (itemMsg, idx) {\n            return \"  \".concat(idx + 1, \". \").concat(itemMsg);\n          });\n          var calculatedDescription = \"one of these possible Token sequences:\\n\".concat(nextValidSequenceItems.join(\"\\n\"));\n          return errPrefix + calculatedDescription + errSuffix;\n        }\n      },\n      buildEarlyExitMessage: function buildEarlyExitMessage(_ref6) {\n        var expectedIterationPaths = _ref6.expectedIterationPaths,\n          actual = _ref6.actual,\n          customUserDescription = _ref6.customUserDescription,\n          ruleName = _ref6.ruleName;\n        var errPrefix = \"Expecting: \";\n        var actualText = head(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n          return errPrefix + customUserDescription + errSuffix;\n        } else {\n          var nextValidTokenSequences = map(expectedIterationPaths, function (currPath) {\n            return \"[\".concat(map(currPath, function (currTokenType) {\n              return tokenLabel(currTokenType);\n            }).join(\",\"), \"]\");\n          });\n          var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  <\".concat(nextValidTokenSequences.join(\" ,\"), \">\");\n          return errPrefix + calculatedDescription + errSuffix;\n        }\n      }\n    };\n    Object.freeze(defaultParserErrorProvider);\n    var defaultGrammarResolverErrorProvider = {\n      buildRuleNotFoundError: function buildRuleNotFoundError(topLevelRule, undefinedRule) {\n        var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\ninside top level rule: ->\" + topLevelRule.name + \"<-\";\n        return msg;\n      }\n    };\n    var defaultGrammarValidatorErrorProvider = {\n      buildDuplicateFoundError: function buildDuplicateFoundError(topLevelRule, duplicateProds) {\n        function getExtraProductionArgument2(prod) {\n          if (prod instanceof Terminal) {\n            return prod.terminalType.name;\n          } else if (prod instanceof NonTerminal) {\n            return prod.nonTerminalName;\n          } else {\n            return \"\";\n          }\n        }\n        var topLevelName = topLevelRule.name;\n        var duplicateProd = head(duplicateProds);\n        var index = duplicateProd.idx;\n        var dslName = getProductionDslName(duplicateProd);\n        var extraArgument = getExtraProductionArgument2(duplicateProd);\n        var hasExplicitIndex = index > 0;\n        var msg = \"->\".concat(dslName).concat(hasExplicitIndex ? index : \"\", \"<- \").concat(extraArgument ? \"with argument: ->\".concat(extraArgument, \"<-\") : \"\", \"\\n                  appears more than once (\").concat(duplicateProds.length, \" times) in the top level rule: ->\").concat(topLevelName, \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \");\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n      },\n      buildNamespaceConflictError: function buildNamespaceConflictError(rule) {\n        var errMsg = \"Namespace conflict found in grammar.\\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\".concat(rule.name, \">.\\nTo resolve this make sure each Terminal and Non-Terminal names are unique\\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\nand Non-Terminal names start with a lower case letter.\");\n        return errMsg;\n      },\n      buildAlternationPrefixAmbiguityError: function buildAlternationPrefixAmbiguityError(options) {\n        var pathMsg = map(options.prefixPath, function (currTok) {\n          return tokenLabel(currTok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var errMsg = \"Ambiguous alternatives: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> due to common lookahead prefix\\nin <OR\").concat(occurrence, \"> inside <\").concat(options.topLevelRule.name, \"> Rule,\\n<\").concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\nSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\nFor Further details.\");\n        return errMsg;\n      },\n      buildAlternationAmbiguityError: function buildAlternationAmbiguityError(options) {\n        var pathMsg = map(options.prefixPath, function (currtok) {\n          return tokenLabel(currtok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var currMessage = \"Ambiguous Alternatives Detected: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> in <OR\").concat(occurrence, \"> inside <\").concat(options.topLevelRule.name, \"> Rule,\\n<\").concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\");\n        currMessage = currMessage + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\nFor Further details.\";\n        return currMessage;\n      },\n      buildEmptyRepetitionError: function buildEmptyRepetitionError(options) {\n        var dslName = getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) {\n          dslName += options.repetition.idx;\n        }\n        var errMsg = \"The repetition <\".concat(dslName, \"> within Rule <\").concat(options.topLevelRule.name, \"> can never consume any tokens.\\nThis could lead to an infinite loop.\");\n        return errMsg;\n      },\n      // TODO: remove - `errors_public` from nyc.config.js exclude\n      //       once this method is fully removed from this file\n      buildTokenNameError: function buildTokenNameError(options) {\n        return \"deprecated\";\n      },\n      buildEmptyAlternationError: function buildEmptyAlternationError(options) {\n        var errMsg = \"Ambiguous empty alternative: <\".concat(options.emptyChoiceIdx + 1, \"> in <OR\").concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\nOnly the last alternative may be an empty alternative.\");\n        return errMsg;\n      },\n      buildTooManyAlternativesError: function buildTooManyAlternativesError(options) {\n        var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n<OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n has \").concat(options.alternation.definition.length + 1, \" alternatives.\");\n        return errMsg;\n      },\n      buildLeftRecursionError: function buildLeftRecursionError(options) {\n        var ruleName = options.topLevelRule.name;\n        var pathNames = map(options.leftRecursionPath, function (currRule) {\n          return currRule.name;\n        });\n        var leftRecursivePath = \"\".concat(ruleName, \" --> \").concat(pathNames.concat([ruleName]).join(\" --> \"));\n        var errMsg = \"Left Recursion found in grammar.\\nrule: <\".concat(ruleName, \"> can be invoked from itself (directly or indirectly)\\nwithout consuming any Tokens. The grammar path that causes this is: \\n \").concat(leftRecursivePath, \"\\n To fix this refactor your grammar to remove the left recursion.\\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.\");\n        return errMsg;\n      },\n      // TODO: remove - `errors_public` from nyc.config.js exclude\n      //       once this method is fully removed from this file\n      buildInvalidRuleNameError: function buildInvalidRuleNameError(options) {\n        return \"deprecated\";\n      },\n      buildDuplicateRuleNameError: function buildDuplicateRuleNameError(options) {\n        var ruleName;\n        if (options.topLevelRule instanceof Rule) {\n          ruleName = options.topLevelRule.name;\n        } else {\n          ruleName = options.topLevelRule;\n        }\n        var errMsg = \"Duplicate definition, rule: ->\".concat(ruleName, \"<- is already defined in the grammar: ->\").concat(options.grammarName, \"<-\");\n        return errMsg;\n      }\n    };\n    function resolveGrammar$1(topLevels, errMsgProvider) {\n      var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n      refResolver.resolveRefs();\n      return refResolver.errors;\n    }\n    var GastRefResolverVisitor = /*#__PURE__*/function (_GAstVisitor) {\n      _inherits(GastRefResolverVisitor, _GAstVisitor);\n      var _super14 = _createSuper(GastRefResolverVisitor);\n      function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {\n        var _this19;\n        _classCallCheck(this, GastRefResolverVisitor);\n        _this19 = _super14.call(this);\n        _this19.nameToTopRule = nameToTopRule;\n        _this19.errMsgProvider = errMsgProvider;\n        _this19.errors = [];\n        return _this19;\n      }\n      _createClass(GastRefResolverVisitor, [{\n        key: \"resolveRefs\",\n        value: function resolveRefs() {\n          var _this20 = this;\n          forEach(values(this.nameToTopRule), function (prod) {\n            _this20.currTopLevel = prod;\n            prod.accept(_this20);\n          });\n        }\n      }, {\n        key: \"visitNonTerminal\",\n        value: function visitNonTerminal(node) {\n          var ref = this.nameToTopRule[node.nonTerminalName];\n          if (!ref) {\n            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n              message: msg,\n              type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n              ruleName: this.currTopLevel.name,\n              unresolvedRefName: node.nonTerminalName\n            });\n          } else {\n            node.referencedRule = ref;\n          }\n        }\n      }]);\n      return GastRefResolverVisitor;\n    }(GAstVisitor);\n    var AbstractNextPossibleTokensWalker = /*#__PURE__*/function (_RestWalker2) {\n      _inherits(AbstractNextPossibleTokensWalker, _RestWalker2);\n      var _super15 = _createSuper(AbstractNextPossibleTokensWalker);\n      function AbstractNextPossibleTokensWalker(topProd, path) {\n        var _this21;\n        _classCallCheck(this, AbstractNextPossibleTokensWalker);\n        _this21 = _super15.call(this);\n        _this21.topProd = topProd;\n        _this21.path = path;\n        _this21.possibleTokTypes = [];\n        _this21.nextProductionName = \"\";\n        _this21.nextProductionOccurrence = 0;\n        _this21.found = false;\n        _this21.isAtEndOfPath = false;\n        return _this21;\n      }\n      _createClass(AbstractNextPossibleTokensWalker, [{\n        key: \"startWalking\",\n        value: function startWalking() {\n          this.found = false;\n          if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n          }\n          this.ruleStack = clone(this.path.ruleStack).reverse();\n          this.occurrenceStack = clone(this.path.occurrenceStack).reverse();\n          this.ruleStack.pop();\n          this.occurrenceStack.pop();\n          this.updateExpectedNext();\n          this.walk(this.topProd);\n          return this.possibleTokTypes;\n        }\n      }, {\n        key: \"walk\",\n        value: function walk(prod) {\n          var prevRest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n          if (!this.found) {\n            _get(_getPrototypeOf(AbstractNextPossibleTokensWalker.prototype), \"walk\", this).call(this, prod, prevRest);\n          }\n        }\n      }, {\n        key: \"walkProdRef\",\n        value: function walkProdRef(refProd, currRest, prevRest) {\n          if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n            var fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n          }\n        }\n      }, {\n        key: \"updateExpectedNext\",\n        value: function updateExpectedNext() {\n          if (isEmpty(this.ruleStack)) {\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n          } else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n          }\n        }\n      }]);\n      return AbstractNextPossibleTokensWalker;\n    }(RestWalker);\n    var NextAfterTokenWalker = /*#__PURE__*/function (_AbstractNextPossible) {\n      _inherits(NextAfterTokenWalker, _AbstractNextPossible);\n      var _super16 = _createSuper(NextAfterTokenWalker);\n      function NextAfterTokenWalker(topProd, path) {\n        var _this22;\n        _classCallCheck(this, NextAfterTokenWalker);\n        _this22 = _super16.call(this, topProd, path);\n        _this22.path = path;\n        _this22.nextTerminalName = \"\";\n        _this22.nextTerminalOccurrence = 0;\n        _this22.nextTerminalName = _this22.path.lastTok.name;\n        _this22.nextTerminalOccurrence = _this22.path.lastTokOccurrence;\n        return _this22;\n      }\n      _createClass(NextAfterTokenWalker, [{\n        key: \"walkTerminal\",\n        value: function walkTerminal(terminal, currRest, prevRest) {\n          if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n            var fullRest = currRest.concat(prevRest);\n            var restProd = new Alternative({\n              definition: fullRest\n            });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n          }\n        }\n      }]);\n      return NextAfterTokenWalker;\n    }(AbstractNextPossibleTokensWalker);\n    var AbstractNextTerminalAfterProductionWalker = /*#__PURE__*/function (_RestWalker3) {\n      _inherits(AbstractNextTerminalAfterProductionWalker, _RestWalker3);\n      var _super17 = _createSuper(AbstractNextTerminalAfterProductionWalker);\n      function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n        var _this23;\n        _classCallCheck(this, AbstractNextTerminalAfterProductionWalker);\n        _this23 = _super17.call(this);\n        _this23.topRule = topRule;\n        _this23.occurrence = occurrence;\n        _this23.result = {\n          token: void 0,\n          occurrence: void 0,\n          isEndOfRule: void 0\n        };\n        return _this23;\n      }\n      _createClass(AbstractNextTerminalAfterProductionWalker, [{\n        key: \"startWalking\",\n        value: function startWalking() {\n          this.walk(this.topRule);\n          return this.result;\n        }\n      }]);\n      return AbstractNextTerminalAfterProductionWalker;\n    }(RestWalker);\n    var NextTerminalAfterManyWalker = /*#__PURE__*/function (_AbstractNextTerminal) {\n      _inherits(NextTerminalAfterManyWalker, _AbstractNextTerminal);\n      var _super18 = _createSuper(NextTerminalAfterManyWalker);\n      function NextTerminalAfterManyWalker() {\n        _classCallCheck(this, NextTerminalAfterManyWalker);\n        return _super18.apply(this, arguments);\n      }\n      _createClass(NextTerminalAfterManyWalker, [{\n        key: \"walkMany\",\n        value: function walkMany(manyProd, currRest, prevRest) {\n          if (manyProd.idx === this.occurrence) {\n            var firstAfterMany = head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === void 0;\n            if (firstAfterMany instanceof Terminal) {\n              this.result.token = firstAfterMany.terminalType;\n              this.result.occurrence = firstAfterMany.idx;\n            }\n          } else {\n            _get(_getPrototypeOf(NextTerminalAfterManyWalker.prototype), \"walkMany\", this).call(this, manyProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return NextTerminalAfterManyWalker;\n    }(AbstractNextTerminalAfterProductionWalker);\n    var NextTerminalAfterManySepWalker = /*#__PURE__*/function (_AbstractNextTerminal2) {\n      _inherits(NextTerminalAfterManySepWalker, _AbstractNextTerminal2);\n      var _super19 = _createSuper(NextTerminalAfterManySepWalker);\n      function NextTerminalAfterManySepWalker() {\n        _classCallCheck(this, NextTerminalAfterManySepWalker);\n        return _super19.apply(this, arguments);\n      }\n      _createClass(NextTerminalAfterManySepWalker, [{\n        key: \"walkManySep\",\n        value: function walkManySep(manySepProd, currRest, prevRest) {\n          if (manySepProd.idx === this.occurrence) {\n            var firstAfterManySep = head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === void 0;\n            if (firstAfterManySep instanceof Terminal) {\n              this.result.token = firstAfterManySep.terminalType;\n              this.result.occurrence = firstAfterManySep.idx;\n            }\n          } else {\n            _get(_getPrototypeOf(NextTerminalAfterManySepWalker.prototype), \"walkManySep\", this).call(this, manySepProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return NextTerminalAfterManySepWalker;\n    }(AbstractNextTerminalAfterProductionWalker);\n    var NextTerminalAfterAtLeastOneWalker = /*#__PURE__*/function (_AbstractNextTerminal3) {\n      _inherits(NextTerminalAfterAtLeastOneWalker, _AbstractNextTerminal3);\n      var _super20 = _createSuper(NextTerminalAfterAtLeastOneWalker);\n      function NextTerminalAfterAtLeastOneWalker() {\n        _classCallCheck(this, NextTerminalAfterAtLeastOneWalker);\n        return _super20.apply(this, arguments);\n      }\n      _createClass(NextTerminalAfterAtLeastOneWalker, [{\n        key: \"walkAtLeastOne\",\n        value: function walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n          if (atLeastOneProd.idx === this.occurrence) {\n            var firstAfterAtLeastOne = head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === void 0;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n              this.result.token = firstAfterAtLeastOne.terminalType;\n              this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n          } else {\n            _get(_getPrototypeOf(NextTerminalAfterAtLeastOneWalker.prototype), \"walkAtLeastOne\", this).call(this, atLeastOneProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return NextTerminalAfterAtLeastOneWalker;\n    }(AbstractNextTerminalAfterProductionWalker);\n    var NextTerminalAfterAtLeastOneSepWalker = /*#__PURE__*/function (_AbstractNextTerminal4) {\n      _inherits(NextTerminalAfterAtLeastOneSepWalker, _AbstractNextTerminal4);\n      var _super21 = _createSuper(NextTerminalAfterAtLeastOneSepWalker);\n      function NextTerminalAfterAtLeastOneSepWalker() {\n        _classCallCheck(this, NextTerminalAfterAtLeastOneSepWalker);\n        return _super21.apply(this, arguments);\n      }\n      _createClass(NextTerminalAfterAtLeastOneSepWalker, [{\n        key: \"walkAtLeastOneSep\",\n        value: function walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n          if (atleastOneSepProd.idx === this.occurrence) {\n            var firstAfterfirstAfterAtLeastOneSep = head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n              this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n              this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n          } else {\n            _get(_getPrototypeOf(NextTerminalAfterAtLeastOneSepWalker.prototype), \"walkAtLeastOneSep\", this).call(this, atleastOneSepProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return NextTerminalAfterAtLeastOneSepWalker;\n    }(AbstractNextTerminalAfterProductionWalker);\n    function possiblePathsFrom(targetDef, maxLength) {\n      var currPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      currPath = clone(currPath);\n      var result = [];\n      var i = 0;\n      function remainingPathWith(nextDef) {\n        return nextDef.concat(drop(targetDef, i + 1));\n      }\n      function getAlternativesForProd(definition) {\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n      }\n      while (currPath.length < maxLength && i < targetDef.length) {\n        var prod = targetDef[i];\n        if (prod instanceof Alternative) {\n          return getAlternativesForProd(prod.definition);\n        } else if (prod instanceof NonTerminal) {\n          return getAlternativesForProd(prod.definition);\n        } else if (prod instanceof Option) {\n          result = getAlternativesForProd(prod.definition);\n        } else if (prod instanceof RepetitionMandatory) {\n          var newDef = prod.definition.concat([new Repetition({\n            definition: prod.definition\n          })]);\n          return getAlternativesForProd(newDef);\n        } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n          var _newDef = [new Alternative({\n            definition: prod.definition\n          }), new Repetition({\n            definition: [new Terminal({\n              terminalType: prod.separator\n            })].concat(prod.definition)\n          })];\n          return getAlternativesForProd(_newDef);\n        } else if (prod instanceof RepetitionWithSeparator) {\n          var _newDef2 = prod.definition.concat([new Repetition({\n            definition: [new Terminal({\n              terminalType: prod.separator\n            })].concat(prod.definition)\n          })]);\n          result = getAlternativesForProd(_newDef2);\n        } else if (prod instanceof Repetition) {\n          var _newDef3 = prod.definition.concat([new Repetition({\n            definition: prod.definition\n          })]);\n          result = getAlternativesForProd(_newDef3);\n        } else if (prod instanceof Alternation) {\n          forEach(prod.definition, function (currAlt) {\n            if (isEmpty(currAlt.definition) === false) {\n              result = getAlternativesForProd(currAlt.definition);\n            }\n          });\n          return result;\n        } else if (prod instanceof Terminal) {\n          currPath.push(prod.terminalType);\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n        i++;\n      }\n      result.push({\n        partialPath: currPath,\n        suffixDef: drop(targetDef, i)\n      });\n      return result;\n    }\n    function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n      var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n      var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n      var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n      var foundCompletePath = false;\n      var tokenVectorLength = tokenVector.length;\n      var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n      var result = [];\n      var possiblePaths = [];\n      possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n      });\n      while (!isEmpty(possiblePaths)) {\n        var currPath = possiblePaths.pop();\n        if (currPath === EXIT_ALTERNATIVE) {\n          if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n            possiblePaths.pop();\n          }\n          continue;\n        }\n        var currDef = currPath.def;\n        var currIdx = currPath.idx;\n        var currRuleStack = currPath.ruleStack;\n        var currOccurrenceStack = currPath.occurrenceStack;\n        if (isEmpty(currDef)) {\n          continue;\n        }\n        var prod = currDef[0];\n        if (prod === EXIT_NON_TERMINAL) {\n          var nextPath = {\n            idx: currIdx,\n            def: drop(currDef),\n            ruleStack: dropRight(currRuleStack),\n            occurrenceStack: dropRight(currOccurrenceStack)\n          };\n          possiblePaths.push(nextPath);\n        } else if (prod instanceof Terminal) {\n          if (currIdx < tokenVectorLength - 1) {\n            var nextIdx = currIdx + 1;\n            var actualToken = tokenVector[nextIdx];\n            if (tokMatcher(actualToken, prod.terminalType)) {\n              var _nextPath = {\n                idx: nextIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n              };\n              possiblePaths.push(_nextPath);\n            }\n          } else if (currIdx === tokenVectorLength - 1) {\n            result.push({\n              nextTokenType: prod.terminalType,\n              nextTokenOccurrence: prod.idx,\n              ruleStack: currRuleStack,\n              occurrenceStack: currOccurrenceStack\n            });\n            foundCompletePath = true;\n          } else {\n            throw Error(\"non exhaustive match\");\n          }\n        } else if (prod instanceof NonTerminal) {\n          var newRuleStack = clone(currRuleStack);\n          newRuleStack.push(prod.nonTerminalName);\n          var newOccurrenceStack = clone(currOccurrenceStack);\n          newOccurrenceStack.push(prod.idx);\n          var _nextPath2 = {\n            idx: currIdx,\n            def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n            ruleStack: newRuleStack,\n            occurrenceStack: newOccurrenceStack\n          };\n          possiblePaths.push(_nextPath2);\n        } else if (prod instanceof Option) {\n          var nextPathWithout = {\n            idx: currIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPathWithout);\n          possiblePaths.push(EXIT_ALTERNATIVE);\n          var nextPathWith = {\n            idx: currIdx,\n            def: prod.definition.concat(drop(currDef)),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPathWith);\n        } else if (prod instanceof RepetitionMandatory) {\n          var secondIteration = new Repetition({\n            definition: prod.definition,\n            idx: prod.idx\n          });\n          var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n          var _nextPath3 = {\n            idx: currIdx,\n            def: nextDef,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPath3);\n        } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n          var separatorGast = new Terminal({\n            terminalType: prod.separator\n          });\n          var _secondIteration = new Repetition({\n            definition: [separatorGast].concat(prod.definition),\n            idx: prod.idx\n          });\n          var _nextDef = prod.definition.concat([_secondIteration], drop(currDef));\n          var _nextPath4 = {\n            idx: currIdx,\n            def: _nextDef,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPath4);\n        } else if (prod instanceof RepetitionWithSeparator) {\n          var _nextPathWithout = {\n            idx: currIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPathWithout);\n          possiblePaths.push(EXIT_ALTERNATIVE);\n          var _separatorGast = new Terminal({\n            terminalType: prod.separator\n          });\n          var nthRepetition = new Repetition({\n            definition: [_separatorGast].concat(prod.definition),\n            idx: prod.idx\n          });\n          var _nextDef2 = prod.definition.concat([nthRepetition], drop(currDef));\n          var _nextPathWith = {\n            idx: currIdx,\n            def: _nextDef2,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPathWith);\n        } else if (prod instanceof Repetition) {\n          var _nextPathWithout2 = {\n            idx: currIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPathWithout2);\n          possiblePaths.push(EXIT_ALTERNATIVE);\n          var _nthRepetition = new Repetition({\n            definition: prod.definition,\n            idx: prod.idx\n          });\n          var _nextDef3 = prod.definition.concat([_nthRepetition], drop(currDef));\n          var _nextPathWith2 = {\n            idx: currIdx,\n            def: _nextDef3,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPathWith2);\n        } else if (prod instanceof Alternation) {\n          for (var _i8 = prod.definition.length - 1; _i8 >= 0; _i8--) {\n            var currAlt = prod.definition[_i8];\n            var currAltPath = {\n              idx: currIdx,\n              def: currAlt.definition.concat(drop(currDef)),\n              ruleStack: currRuleStack,\n              occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(currAltPath);\n            possiblePaths.push(EXIT_ALTERNATIVE);\n          }\n        } else if (prod instanceof Alternative) {\n          possiblePaths.push({\n            idx: currIdx,\n            def: prod.definition.concat(drop(currDef)),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          });\n        } else if (prod instanceof Rule) {\n          possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n      }\n      return result;\n    }\n    function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n      var newRuleStack = clone(currRuleStack);\n      newRuleStack.push(topRule.name);\n      var newCurrOccurrenceStack = clone(currOccurrenceStack);\n      newCurrOccurrenceStack.push(1);\n      return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n      };\n    }\n    var PROD_TYPE;\n    (function (PROD_TYPE2) {\n      PROD_TYPE2[PROD_TYPE2[\"OPTION\"] = 0] = \"OPTION\";\n      PROD_TYPE2[PROD_TYPE2[\"REPETITION\"] = 1] = \"REPETITION\";\n      PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n      PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n      PROD_TYPE2[PROD_TYPE2[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n      PROD_TYPE2[PROD_TYPE2[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n    })(PROD_TYPE || (PROD_TYPE = {}));\n    function getProdType(prod) {\n      if (prod instanceof Option || prod === \"Option\") {\n        return PROD_TYPE.OPTION;\n      } else if (prod instanceof Repetition || prod === \"Repetition\") {\n        return PROD_TYPE.REPETITION;\n      } else if (prod instanceof RepetitionMandatory || prod === \"RepetitionMandatory\") {\n        return PROD_TYPE.REPETITION_MANDATORY;\n      } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === \"RepetitionMandatoryWithSeparator\") {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n      } else if (prod instanceof RepetitionWithSeparator || prod === \"RepetitionWithSeparator\") {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n      } else if (prod instanceof Alternation || prod === \"Alternation\") {\n        return PROD_TYPE.ALTERNATION;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n      var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n      return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);\n    }\n    function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n      var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n      return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);\n    }\n    function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {\n      var numOfAlts = alts.length;\n      var areAllOneTokenLookahead = every(alts, function (currAlt) {\n        return every(currAlt, function (currPath) {\n          return currPath.length === 1;\n        });\n      });\n      if (hasPredicates) {\n        return function (orAlts) {\n          var predicates = map(orAlts, function (currAlt) {\n            return currAlt.GATE;\n          });\n          for (var t = 0; t < numOfAlts; t++) {\n            var currAlt = alts[t];\n            var currNumOfPaths = currAlt.length;\n            var currPredicate = predicates[t];\n            if (currPredicate !== void 0 && currPredicate.call(this) === false) {\n              continue;\n            }\n            nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n              var currPath = currAlt[j];\n              var currPathLength = currPath.length;\n              for (var _i9 = 0; _i9 < currPathLength; _i9++) {\n                var nextToken = this.LA(_i9 + 1);\n                if (tokenMatcher2(nextToken, currPath[_i9]) === false) {\n                  continue nextPath;\n                }\n              }\n              return t;\n            }\n          }\n          return void 0;\n        };\n      } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokenAlts = map(alts, function (currAlt) {\n          return flatten(currAlt);\n        });\n        var choiceToAlt = reduce(singleTokenAlts, function (result, currAlt, idx) {\n          forEach(currAlt, function (currTokType) {\n            if (!has(result, currTokType.tokenTypeIdx)) {\n              result[currTokType.tokenTypeIdx] = idx;\n            }\n            forEach(currTokType.categoryMatches, function (currExtendingType) {\n              if (!has(result, currExtendingType)) {\n                result[currExtendingType] = idx;\n              }\n            });\n          });\n          return result;\n        }, {});\n        return function () {\n          var nextToken = this.LA(1);\n          return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n      } else {\n        return function () {\n          for (var t = 0; t < numOfAlts; t++) {\n            var currAlt = alts[t];\n            var currNumOfPaths = currAlt.length;\n            nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n              var currPath = currAlt[j];\n              var currPathLength = currPath.length;\n              for (var _i10 = 0; _i10 < currPathLength; _i10++) {\n                var nextToken = this.LA(_i10 + 1);\n                if (tokenMatcher2(nextToken, currPath[_i10]) === false) {\n                  continue nextPath;\n                }\n              }\n              return t;\n            }\n          }\n          return void 0;\n        };\n      }\n    }\n    function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {\n      var areAllOneTokenLookahead = every(alt, function (currPath) {\n        return currPath.length === 1;\n      });\n      var numOfPaths = alt.length;\n      if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = flatten(alt);\n        if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n          var expectedTokenType = singleTokensTypes[0];\n          var expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n          return function () {\n            return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n          };\n        } else {\n          var choiceToAlt = reduce(singleTokensTypes, function (result, currTokType, idx) {\n            result[currTokType.tokenTypeIdx] = true;\n            forEach(currTokType.categoryMatches, function (currExtendingType) {\n              result[currExtendingType] = true;\n            });\n            return result;\n          }, []);\n          return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt[nextToken.tokenTypeIdx] === true;\n          };\n        }\n      } else {\n        return function () {\n          nextPath: for (var j = 0; j < numOfPaths; j++) {\n            var currPath = alt[j];\n            var currPathLength = currPath.length;\n            for (var _i11 = 0; _i11 < currPathLength; _i11++) {\n              var nextToken = this.LA(_i11 + 1);\n              if (tokenMatcher2(nextToken, currPath[_i11]) === false) {\n                continue nextPath;\n              }\n            }\n            return true;\n          }\n          return false;\n        };\n      }\n    }\n    var RestDefinitionFinderWalker = /*#__PURE__*/function (_RestWalker4) {\n      _inherits(RestDefinitionFinderWalker, _RestWalker4);\n      var _super22 = _createSuper(RestDefinitionFinderWalker);\n      function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this24;\n        _classCallCheck(this, RestDefinitionFinderWalker);\n        _this24 = _super22.call(this);\n        _this24.topProd = topProd;\n        _this24.targetOccurrence = targetOccurrence;\n        _this24.targetProdType = targetProdType;\n        return _this24;\n      }\n      _createClass(RestDefinitionFinderWalker, [{\n        key: \"startWalking\",\n        value: function startWalking() {\n          this.walk(this.topProd);\n          return this.restDef;\n        }\n      }, {\n        key: \"checkIsTarget\",\n        value: function checkIsTarget(node, expectedProdType, currRest, prevRest) {\n          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n          }\n          return false;\n        }\n      }, {\n        key: \"walkOption\",\n        value: function walkOption(optionProd, currRest, prevRest) {\n          if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, optionProd, currRest, prevRest);\n          }\n        }\n      }, {\n        key: \"walkAtLeastOne\",\n        value: function walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n          if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, atLeastOneProd, currRest, prevRest);\n          }\n        }\n      }, {\n        key: \"walkAtLeastOneSep\",\n        value: function walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n          if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, atLeastOneSepProd, currRest, prevRest);\n          }\n        }\n      }, {\n        key: \"walkMany\",\n        value: function walkMany(manyProd, currRest, prevRest) {\n          if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, manyProd, currRest, prevRest);\n          }\n        }\n      }, {\n        key: \"walkManySep\",\n        value: function walkManySep(manySepProd, currRest, prevRest) {\n          if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, manySepProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return RestDefinitionFinderWalker;\n    }(RestWalker);\n    var InsideDefinitionFinderVisitor = /*#__PURE__*/function (_GAstVisitor2) {\n      _inherits(InsideDefinitionFinderVisitor, _GAstVisitor2);\n      var _super23 = _createSuper(InsideDefinitionFinderVisitor);\n      function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this25;\n        _classCallCheck(this, InsideDefinitionFinderVisitor);\n        _this25 = _super23.call(this);\n        _this25.targetOccurrence = targetOccurrence;\n        _this25.targetProdType = targetProdType;\n        _this25.targetRef = targetRef;\n        _this25.result = [];\n        return _this25;\n      }\n      _createClass(InsideDefinitionFinderVisitor, [{\n        key: \"checkIsTarget\",\n        value: function checkIsTarget(node, expectedProdName) {\n          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {\n            this.result = node.definition;\n          }\n        }\n      }, {\n        key: \"visitOption\",\n        value: function visitOption(node) {\n          this.checkIsTarget(node, PROD_TYPE.OPTION);\n        }\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(node) {\n          this.checkIsTarget(node, PROD_TYPE.REPETITION);\n        }\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(node) {\n          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n        }\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(node) {\n          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n        }\n      }, {\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(node) {\n          this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n        }\n      }, {\n        key: \"visitAlternation\",\n        value: function visitAlternation(node) {\n          this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n        }\n      }]);\n      return InsideDefinitionFinderVisitor;\n    }(GAstVisitor);\n    function initializeArrayOfArrays(size) {\n      var result = new Array(size);\n      for (var _i12 = 0; _i12 < size; _i12++) {\n        result[_i12] = [];\n      }\n      return result;\n    }\n    function pathToHashKeys(path) {\n      var keys2 = [\"\"];\n      for (var _i13 = 0; _i13 < path.length; _i13++) {\n        var tokType = path[_i13];\n        var longerKeys = [];\n        for (var j = 0; j < keys2.length; j++) {\n          var currShorterKey = keys2[j];\n          longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n          for (var t = 0; t < tokType.categoryMatches.length; t++) {\n            var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n            longerKeys.push(currShorterKey + categoriesKeySuffix);\n          }\n        }\n        keys2 = longerKeys;\n      }\n      return keys2;\n    }\n    function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n      for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        if (currAltIdx === idx) {\n          continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n          var searchKey = searchPathKeys[searchIdx];\n          if (otherAltKnownPathsKeys[searchKey] === true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    function lookAheadSequenceFromAlternatives(altsDefs, k) {\n      var partialAlts = map(altsDefs, function (currAlt) {\n        return possiblePathsFrom([currAlt], 1);\n      });\n      var finalResult = initializeArrayOfArrays(partialAlts.length);\n      var altsHashes = map(partialAlts, function (currAltPaths) {\n        var dict = {};\n        forEach(currAltPaths, function (item) {\n          var keys2 = pathToHashKeys(item.partialPath);\n          forEach(keys2, function (currKey) {\n            dict[currKey] = true;\n          });\n        });\n        return dict;\n      });\n      var newData = partialAlts;\n      for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop = function _loop(altIdx) {\n          var currAltPathsAndSuffixes = currDataset[altIdx];\n          for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n            var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n            var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n            var prefixKeys = pathToHashKeys(currPathPrefix);\n            var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n            if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n              var currAltResult = finalResult[altIdx];\n              if (containsPath(currAltResult, currPathPrefix) === false) {\n                currAltResult.push(currPathPrefix);\n                for (var j = 0; j < prefixKeys.length; j++) {\n                  var currKey = prefixKeys[j];\n                  altsHashes[altIdx][currKey] = true;\n                }\n              }\n            } else {\n              var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n              newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n              forEach(newPartialPathsAndSuffixes, function (item) {\n                var prefixKeys2 = pathToHashKeys(item.partialPath);\n                forEach(prefixKeys2, function (key) {\n                  altsHashes[altIdx][key] = true;\n                });\n              });\n            }\n          }\n        };\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n          _loop(altIdx);\n        }\n      }\n      return finalResult;\n    }\n    function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n      var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n      ruleGrammar.accept(visitor);\n      return lookAheadSequenceFromAlternatives(visitor.result, k);\n    }\n    function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n      var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n      ruleGrammar.accept(insideDefVisitor);\n      var insideDef = insideDefVisitor.result;\n      var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n      var afterDef = afterDefWalker.startWalking();\n      var insideFlat = new Alternative({\n        definition: insideDef\n      });\n      var afterFlat = new Alternative({\n        definition: afterDef\n      });\n      return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n    }\n    function containsPath(alternative, searchPath) {\n      compareOtherPath: for (var _i14 = 0; _i14 < alternative.length; _i14++) {\n        var otherPath = alternative[_i14];\n        if (otherPath.length !== searchPath.length) {\n          continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n          var searchTok = searchPath[j];\n          var otherTok = otherPath[j];\n          var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;\n          if (matchingTokens === false) {\n            continue compareOtherPath;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n    function isStrictPrefixOfPath(prefix, other) {\n      return prefix.length < other.length && every(prefix, function (tokType, idx) {\n        var otherTokType = other[idx];\n        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n      });\n    }\n    function areTokenCategoriesNotUsed(lookAheadPaths) {\n      return every(lookAheadPaths, function (singleAltPaths) {\n        return every(singleAltPaths, function (singlePath) {\n          return every(singlePath, function (token) {\n            return isEmpty(token.categoryMatches);\n          });\n        });\n      });\n    }\n    function validateLookahead(options) {\n      var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n        rules: options.rules,\n        tokenTypes: options.tokenTypes,\n        grammarName: options.grammarName\n      });\n      return map(lookaheadValidationErrorMessages, function (errorMessage) {\n        return Object.assign({\n          type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION\n        }, errorMessage);\n      });\n    }\n    function validateGrammar$1(topLevels, tokenTypes, errMsgProvider, grammarName) {\n      var duplicateErrors = flatMap(topLevels, function (currTopLevel) {\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\n      });\n      var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n      var tooManyAltsErrors = flatMap(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n      });\n      var duplicateRulesError = flatMap(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n      });\n      return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n    }\n    function validateDuplicateProductions(topLevelRule, errMsgProvider) {\n      var collectorVisitor2 = new OccurrenceValidationCollector();\n      topLevelRule.accept(collectorVisitor2);\n      var allRuleProductions = collectorVisitor2.allProductions;\n      var productionGroups = groupBy$1(allRuleProductions, identifyProductionForDuplicates);\n      var duplicates = pickBy(productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n      });\n      var errors = map(values(duplicates), function (currDuplicates) {\n        var firstProd = head(currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = getProductionDslName(firstProd);\n        var defError = {\n          message: msg,\n          type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n          ruleName: topLevelRule.name,\n          dslName: dslName,\n          occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n          defError.parameter = param;\n        }\n        return defError;\n      });\n      return errors;\n    }\n    function identifyProductionForDuplicates(prod) {\n      return \"\".concat(getProductionDslName(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n    }\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    var OccurrenceValidationCollector = /*#__PURE__*/function (_GAstVisitor3) {\n      _inherits(OccurrenceValidationCollector, _GAstVisitor3);\n      var _super24 = _createSuper(OccurrenceValidationCollector);\n      function OccurrenceValidationCollector() {\n        var _this26;\n        _classCallCheck(this, OccurrenceValidationCollector);\n        _this26 = _super24.apply(this, arguments);\n        _this26.allProductions = [];\n        return _this26;\n      }\n      _createClass(OccurrenceValidationCollector, [{\n        key: \"visitNonTerminal\",\n        value: function visitNonTerminal(subrule) {\n          this.allProductions.push(subrule);\n        }\n      }, {\n        key: \"visitOption\",\n        value: function visitOption(option) {\n          this.allProductions.push(option);\n        }\n      }, {\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(manySep) {\n          this.allProductions.push(manySep);\n        }\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(atLeastOne) {\n          this.allProductions.push(atLeastOne);\n        }\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n          this.allProductions.push(atLeastOneSep);\n        }\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(many) {\n          this.allProductions.push(many);\n        }\n      }, {\n        key: \"visitAlternation\",\n        value: function visitAlternation(or) {\n          this.allProductions.push(or);\n        }\n      }, {\n        key: \"visitTerminal\",\n        value: function visitTerminal(terminal) {\n          this.allProductions.push(terminal);\n        }\n      }]);\n      return OccurrenceValidationCollector;\n    }(GAstVisitor);\n    function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n      var errors = [];\n      var occurrences = reduce(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n          return result + 1;\n        }\n        return result;\n      }, 0);\n      if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n          topLevelRule: rule,\n          grammarName: className\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n          ruleName: rule.name\n        });\n      }\n      return errors;\n    }\n    function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n      var errors = [];\n      var errMsg;\n      if (!includes(definedRulesNames, ruleName)) {\n        errMsg = \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-as it is not defined in any of the super grammars \");\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n          ruleName: ruleName\n        });\n      }\n      return errors;\n    }\n    function _validateNoLeftRecursion(topRule, currRule, errMsgProvider) {\n      var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var errors = [];\n      var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n      if (isEmpty(nextNonTerminals)) {\n        return [];\n      } else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = includes(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n          errors.push({\n            message: errMsgProvider.buildLeftRecursionError({\n              topLevelRule: topRule,\n              leftRecursionPath: path\n            }),\n            type: ParserDefinitionErrorType.LEFT_RECURSION,\n            ruleName: ruleName\n          });\n        }\n        var validNextSteps = difference$1(nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = flatMap(validNextSteps, function (currRefRule) {\n          var newPath = clone(path);\n          newPath.push(currRefRule);\n          return _validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n      }\n    }\n    function getFirstNoneTerminal(definition) {\n      var result = [];\n      if (isEmpty(definition)) {\n        return result;\n      }\n      var firstProd = head(definition);\n      if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n      } else if (firstProd instanceof Alternative || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n      } else if (firstProd instanceof Alternation) {\n        result = flatten(map(firstProd.definition, function (currSubDef) {\n          return getFirstNoneTerminal(currSubDef.definition);\n        }));\n      } else if (firstProd instanceof Terminal) ;else {\n        throw Error(\"non exhaustive match\");\n      }\n      var isFirstOptional = isOptionalProd(firstProd);\n      var hasMore = definition.length > 1;\n      if (isFirstOptional && hasMore) {\n        var rest = drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n      } else {\n        return result;\n      }\n    }\n    var OrCollector = /*#__PURE__*/function (_GAstVisitor4) {\n      _inherits(OrCollector, _GAstVisitor4);\n      var _super25 = _createSuper(OrCollector);\n      function OrCollector() {\n        var _this27;\n        _classCallCheck(this, OrCollector);\n        _this27 = _super25.apply(this, arguments);\n        _this27.alternations = [];\n        return _this27;\n      }\n      _createClass(OrCollector, [{\n        key: \"visitAlternation\",\n        value: function visitAlternation(node) {\n          this.alternations.push(node);\n        }\n      }]);\n      return OrCollector;\n    }(GAstVisitor);\n    function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n      var orCollector = new OrCollector();\n      topLevelRule.accept(orCollector);\n      var ors = orCollector.alternations;\n      var errors = flatMap(ors, function (currOr) {\n        var exceptLast = dropRight(currOr.definition);\n        return flatMap(exceptLast, function (currAlternative, currAltIdx) {\n          var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n          if (isEmpty(possibleFirstInAlt)) {\n            return [{\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }];\n          } else {\n            return [];\n          }\n        });\n      });\n      return errors;\n    }\n    function _validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n      var orCollector = new OrCollector();\n      topLevelRule.accept(orCollector);\n      var ors = orCollector.alternations;\n      ors = reject(ors, function (currOr) {\n        return currOr.ignoreAmbiguities === true;\n      });\n      var errors = flatMap(ors, function (currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n      });\n      return errors;\n    }\n    var RepetitionCollector = /*#__PURE__*/function (_GAstVisitor5) {\n      _inherits(RepetitionCollector, _GAstVisitor5);\n      var _super26 = _createSuper(RepetitionCollector);\n      function RepetitionCollector() {\n        var _this28;\n        _classCallCheck(this, RepetitionCollector);\n        _this28 = _super26.apply(this, arguments);\n        _this28.allProductions = [];\n        return _this28;\n      }\n      _createClass(RepetitionCollector, [{\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(manySep) {\n          this.allProductions.push(manySep);\n        }\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(atLeastOne) {\n          this.allProductions.push(atLeastOne);\n        }\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n          this.allProductions.push(atLeastOneSep);\n        }\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(many) {\n          this.allProductions.push(many);\n        }\n      }]);\n      return RepetitionCollector;\n    }(GAstVisitor);\n    function validateTooManyAlts(topLevelRule, errMsgProvider) {\n      var orCollector = new OrCollector();\n      topLevelRule.accept(orCollector);\n      var ors = orCollector.alternations;\n      var errors = flatMap(ors, function (currOr) {\n        if (currOr.definition.length > 255) {\n          return [{\n            message: errMsgProvider.buildTooManyAlternativesError({\n              topLevelRule: topLevelRule,\n              alternation: currOr\n            }),\n            type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n            ruleName: topLevelRule.name,\n            occurrence: currOr.idx\n          }];\n        } else {\n          return [];\n        }\n      });\n      return errors;\n    }\n    function _validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n      var errors = [];\n      forEach(topLevelRules, function (currTopRule) {\n        var collectorVisitor2 = new RepetitionCollector();\n        currTopRule.accept(collectorVisitor2);\n        var allRuleProductions = collectorVisitor2.allProductions;\n        forEach(allRuleProductions, function (currProd) {\n          var prodType = getProdType(currProd);\n          var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n          var currOccurrence = currProd.idx;\n          var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n          var pathsInsideProduction = paths[0];\n          if (isEmpty(flatten(pathsInsideProduction))) {\n            var errMsg = errMsgProvider.buildEmptyRepetitionError({\n              topLevelRule: currTopRule,\n              repetition: currProd\n            });\n            errors.push({\n              message: errMsg,\n              type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n              ruleName: currTopRule.name\n            });\n          }\n        });\n      });\n      return errors;\n    }\n    function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n      var foundAmbiguousPaths = [];\n      var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n          return result;\n        }\n        forEach(currAlt, function (currPath) {\n          var altsCurrPathAppearsIn = [currAltIdx];\n          forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n            if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n              altsCurrPathAppearsIn.push(currOtherAltIdx);\n            }\n          });\n          if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n            foundAmbiguousPaths.push(currPath);\n            result.push({\n              alts: altsCurrPathAppearsIn,\n              path: currPath\n            });\n          }\n        });\n        return result;\n      }, []);\n      var currErrors = map(identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) {\n          return currAltIdx + 1;\n        });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n          topLevelRule: rule,\n          alternation: alternation,\n          ambiguityIndices: ambgIndices,\n          prefixPath: currAmbDescriptor.path\n        });\n        return {\n          message: currMessage,\n          type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n          ruleName: rule.name,\n          occurrence: alternation.idx,\n          alternatives: currAmbDescriptor.alts\n        };\n      });\n      return currErrors;\n    }\n    function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n      var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = map(currAlt, function (currPath) {\n          return {\n            idx: idx,\n            path: currPath\n          };\n        });\n        return result.concat(currPathsAndIdx);\n      }, []);\n      var errors = compact(flatMap(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        if (alternativeGast.ignoreAmbiguities === true) {\n          return [];\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, function (searchPathAndIdx) {\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          );\n        });\n        var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n          var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n          var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n          var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path\n          });\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices\n          };\n        });\n        return currPathPrefixErrors;\n      }));\n      return errors;\n    }\n    function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n      var errors = [];\n      var tokenNames = map(tokenTypes, function (currToken) {\n        return currToken.name;\n      });\n      forEach(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if (includes(tokenNames, currRuleName)) {\n          var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n          errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n            ruleName: currRuleName\n          });\n        }\n      });\n      return errors;\n    }\n    function resolveGrammar(options) {\n      var actualOptions = defaults$1(options, {\n        errMsgProvider: defaultGrammarResolverErrorProvider\n      });\n      var topRulesTable = {};\n      forEach(options.rules, function (rule) {\n        topRulesTable[rule.name] = rule;\n      });\n      return resolveGrammar$1(topRulesTable, actualOptions.errMsgProvider);\n    }\n    function validateGrammar(options) {\n      options = defaults$1(options, {\n        errMsgProvider: defaultGrammarValidatorErrorProvider\n      });\n      return validateGrammar$1(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n    }\n    var MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\n    var NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\n    var EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\n    var NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\n    var RECOGNITION_EXCEPTION_NAMES = [MISMATCHED_TOKEN_EXCEPTION, NO_VIABLE_ALT_EXCEPTION, EARLY_EXIT_EXCEPTION, NOT_ALL_INPUT_PARSED_EXCEPTION];\n    Object.freeze(RECOGNITION_EXCEPTION_NAMES);\n    function isRecognitionException(error) {\n      return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n    }\n    var RecognitionException = /*#__PURE__*/function (_Error) {\n      _inherits(RecognitionException, _Error);\n      var _super27 = _createSuper(RecognitionException);\n      function RecognitionException(message, token) {\n        var _this29;\n        _classCallCheck(this, RecognitionException);\n        _this29 = _super27.call(this, message);\n        _this29.token = token;\n        _this29.resyncedTokens = [];\n        Object.setPrototypeOf(_assertThisInitialized(_this29), (this instanceof RecognitionException ? this.constructor : void 0).prototype);\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(_assertThisInitialized(_this29), _this29.constructor);\n        }\n        return _this29;\n      }\n      return _createClass(RecognitionException);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n    var MismatchedTokenException = /*#__PURE__*/function (_RecognitionException) {\n      _inherits(MismatchedTokenException, _RecognitionException);\n      var _super28 = _createSuper(MismatchedTokenException);\n      function MismatchedTokenException(message, token, previousToken) {\n        var _this30;\n        _classCallCheck(this, MismatchedTokenException);\n        _this30 = _super28.call(this, message, token);\n        _this30.previousToken = previousToken;\n        _this30.name = MISMATCHED_TOKEN_EXCEPTION;\n        return _this30;\n      }\n      return _createClass(MismatchedTokenException);\n    }(RecognitionException);\n    var NoViableAltException = /*#__PURE__*/function (_RecognitionException2) {\n      _inherits(NoViableAltException, _RecognitionException2);\n      var _super29 = _createSuper(NoViableAltException);\n      function NoViableAltException(message, token, previousToken) {\n        var _this31;\n        _classCallCheck(this, NoViableAltException);\n        _this31 = _super29.call(this, message, token);\n        _this31.previousToken = previousToken;\n        _this31.name = NO_VIABLE_ALT_EXCEPTION;\n        return _this31;\n      }\n      return _createClass(NoViableAltException);\n    }(RecognitionException);\n    var NotAllInputParsedException = /*#__PURE__*/function (_RecognitionException3) {\n      _inherits(NotAllInputParsedException, _RecognitionException3);\n      var _super30 = _createSuper(NotAllInputParsedException);\n      function NotAllInputParsedException(message, token) {\n        var _this32;\n        _classCallCheck(this, NotAllInputParsedException);\n        _this32 = _super30.call(this, message, token);\n        _this32.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n        return _this32;\n      }\n      return _createClass(NotAllInputParsedException);\n    }(RecognitionException);\n    var EarlyExitException = /*#__PURE__*/function (_RecognitionException4) {\n      _inherits(EarlyExitException, _RecognitionException4);\n      var _super31 = _createSuper(EarlyExitException);\n      function EarlyExitException(message, token, previousToken) {\n        var _this33;\n        _classCallCheck(this, EarlyExitException);\n        _this33 = _super31.call(this, message, token);\n        _this33.previousToken = previousToken;\n        _this33.name = EARLY_EXIT_EXCEPTION;\n        return _this33;\n      }\n      return _createClass(EarlyExitException);\n    }(RecognitionException);\n    var EOF_FOLLOW_KEY = {};\n    var IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\n    var InRuleRecoveryException = /*#__PURE__*/function (_Error2) {\n      _inherits(InRuleRecoveryException, _Error2);\n      var _super32 = _createSuper(InRuleRecoveryException);\n      function InRuleRecoveryException(message) {\n        var _this34;\n        _classCallCheck(this, InRuleRecoveryException);\n        _this34 = _super32.call(this, message);\n        _this34.name = IN_RULE_RECOVERY_EXCEPTION;\n        return _this34;\n      }\n      return _createClass(InRuleRecoveryException);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n    var Recoverable = /*#__PURE__*/function () {\n      function Recoverable() {\n        _classCallCheck(this, Recoverable);\n      }\n      _createClass(Recoverable, [{\n        key: \"initRecoverable\",\n        value: function initRecoverable(config) {\n          this.firstAfterRepMap = {};\n          this.resyncFollows = {};\n          this.recoveryEnabled = has(config, \"recoveryEnabled\") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n          if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n          }\n        }\n      }, {\n        key: \"getTokenToInsert\",\n        value: function getTokenToInsert(tokType) {\n          var tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n          tokToInsert.isInsertedInRecovery = true;\n          return tokToInsert;\n        }\n      }, {\n        key: \"canTokenTypeBeInsertedInRecovery\",\n        value: function canTokenTypeBeInsertedInRecovery(tokType) {\n          return true;\n        }\n      }, {\n        key: \"canTokenTypeBeDeletedInRecovery\",\n        value: function canTokenTypeBeDeletedInRecovery(tokType) {\n          return true;\n        }\n      }, {\n        key: \"tryInRepetitionRecovery\",\n        value: function tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n          var _this35 = this;\n          var reSyncTokType = this.findReSyncTokenType();\n          var savedLexerState = this.exportLexerState();\n          var resyncedTokens = [];\n          var passedResyncPoint = false;\n          var nextTokenWithoutResync = this.LA(1);\n          var currToken = this.LA(1);\n          var generateErrorMessage = function generateErrorMessage() {\n            var previousToken = _this35.LA(0);\n            var msg = _this35.errorMessageProvider.buildMismatchTokenMessage({\n              expected: expectedTokType,\n              actual: nextTokenWithoutResync,\n              previous: previousToken,\n              ruleName: _this35.getCurrRuleFullName()\n            });\n            var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this35.LA(0));\n            error.resyncedTokens = dropRight(resyncedTokens);\n            _this35.SAVE_ERROR(error);\n          };\n          while (!passedResyncPoint) {\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n              generateErrorMessage();\n              return;\n            } else if (lookAheadFunc.call(this)) {\n              generateErrorMessage();\n              grammarRule.apply(this, grammarRuleArgs);\n              return;\n            } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n              passedResyncPoint = true;\n            } else {\n              currToken = this.SKIP_TOKEN();\n              this.addToResyncTokens(currToken, resyncedTokens);\n            }\n          }\n          this.importLexerState(savedLexerState);\n        }\n      }, {\n        key: \"shouldInRepetitionRecoveryBeTried\",\n        value: function shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n          if (notStuck === false) {\n            return false;\n          }\n          if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n          }\n          if (this.isBackTracking()) {\n            return false;\n          }\n          if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n          }\n          return true;\n        }\n        // Error Recovery functionality\n      }, {\n        key: \"getFollowsForInRuleRecovery\",\n        value: function getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n          var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n          var follows = this.getNextPossibleTokenTypes(grammarPath);\n          return follows;\n        }\n      }, {\n        key: \"tryInRuleRecovery\",\n        value: function tryInRuleRecovery(expectedTokType, follows) {\n          if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n          }\n          if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n          }\n          throw new InRuleRecoveryException(\"sad sad panda\");\n        }\n      }, {\n        key: \"canPerformInRuleRecovery\",\n        value: function canPerformInRuleRecovery(expectedToken, follows) {\n          return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n        }\n      }, {\n        key: \"canRecoverWithSingleTokenInsertion\",\n        value: function canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n          var _this36 = this;\n          if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n          }\n          if (isEmpty(follows)) {\n            return false;\n          }\n          var mismatchedTok = this.LA(1);\n          var isMisMatchedTokInFollows = find$1(follows, function (possibleFollowsTokType) {\n            return _this36.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n          }) !== void 0;\n          return isMisMatchedTokInFollows;\n        }\n      }, {\n        key: \"canRecoverWithSingleTokenDeletion\",\n        value: function canRecoverWithSingleTokenDeletion(expectedTokType) {\n          if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n          }\n          var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n          return isNextTokenWhatIsExpected;\n        }\n      }, {\n        key: \"isInCurrentRuleReSyncSet\",\n        value: function isInCurrentRuleReSyncSet(tokenTypeIdx) {\n          var followKey = this.getCurrFollowKey();\n          var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n          return includes(currentRuleReSyncSet, tokenTypeIdx);\n        }\n      }, {\n        key: \"findReSyncTokenType\",\n        value: function findReSyncTokenType() {\n          var allPossibleReSyncTokTypes = this.flattenFollowSet();\n          var nextToken = this.LA(1);\n          var k = 2;\n          while (true) {\n            var foundMatch = find$1(allPossibleReSyncTokTypes, function (resyncTokType) {\n              var canMatch = tokenMatcher(nextToken, resyncTokType);\n              return canMatch;\n            });\n            if (foundMatch !== void 0) {\n              return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n          }\n        }\n      }, {\n        key: \"getCurrFollowKey\",\n        value: function getCurrFollowKey() {\n          if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n          }\n          var currRuleShortName = this.getLastExplicitRuleShortName();\n          var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n          var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n          return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n          };\n        }\n      }, {\n        key: \"buildFullFollowKeyStack\",\n        value: function buildFullFollowKeyStack() {\n          var _this37 = this;\n          var explicitRuleStack = this.RULE_STACK;\n          var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n          return map(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n              return EOF_FOLLOW_KEY;\n            }\n            return {\n              ruleName: _this37.shortRuleNameToFullName(ruleName),\n              idxInCallingRule: explicitOccurrenceStack[idx],\n              inRule: _this37.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n          });\n        }\n      }, {\n        key: \"flattenFollowSet\",\n        value: function flattenFollowSet() {\n          var _this38 = this;\n          var followStack = map(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this38.getFollowSetFromFollowKey(currKey);\n          });\n          return flatten(followStack);\n        }\n      }, {\n        key: \"getFollowSetFromFollowKey\",\n        value: function getFollowSetFromFollowKey(followKey) {\n          if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n          }\n          var followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n          return this.resyncFollows[followName];\n        }\n        // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n        // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n      }, {\n        key: \"addToResyncTokens\",\n        value: function addToResyncTokens(token, resyncTokens) {\n          if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n          }\n          return resyncTokens;\n        }\n      }, {\n        key: \"reSyncTo\",\n        value: function reSyncTo(tokType) {\n          var resyncedTokens = [];\n          var nextTok = this.LA(1);\n          while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n          }\n          return dropRight(resyncedTokens);\n        }\n      }, {\n        key: \"attemptInRepetitionRecovery\",\n        value: function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {}\n      }, {\n        key: \"getCurrentGrammarPath\",\n        value: function getCurrentGrammarPath(tokType, tokIdxInRule) {\n          var pathRuleStack = this.getHumanReadableRuleStack();\n          var pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK);\n          var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n          };\n          return grammarPath;\n        }\n      }, {\n        key: \"getHumanReadableRuleStack\",\n        value: function getHumanReadableRuleStack() {\n          var _this39 = this;\n          return map(this.RULE_STACK, function (currShortName) {\n            return _this39.shortRuleNameToFullName(currShortName);\n          });\n        }\n      }]);\n      return Recoverable;\n    }();\n    function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n      var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n      var firstAfterRepInfo = this.firstAfterRepMap[key];\n      if (firstAfterRepInfo === void 0) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n      }\n      var expectTokAfterLastMatch = firstAfterRepInfo.token;\n      var nextTokIdx = firstAfterRepInfo.occurrence;\n      var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n      if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n      }\n      if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {\n        return;\n      }\n      if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n      }\n    }\n    var BITS_FOR_METHOD_TYPE = 4;\n    var BITS_FOR_OCCURRENCE_IDX = 8;\n    var OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\n    var OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\n    var MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\n    var AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\n    var MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\n    var AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n    function _getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n      return occurrence | dslMethodIdx | ruleIdx;\n    }\n    var LLkLookaheadStrategy = /*#__PURE__*/function () {\n      function LLkLookaheadStrategy(options) {\n        _classCallCheck(this, LLkLookaheadStrategy);\n        var _a;\n        this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;\n      }\n      _createClass(LLkLookaheadStrategy, [{\n        key: \"validate\",\n        value: function validate(options) {\n          var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n          if (isEmpty(leftRecursionErrors)) {\n            var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            var allErrors = [].concat(_toConsumableArray(leftRecursionErrors), _toConsumableArray(emptyAltErrors), _toConsumableArray(ambiguousAltsErrors), _toConsumableArray(emptyRepetitionErrors));\n            return allErrors;\n          }\n          return leftRecursionErrors;\n        }\n      }, {\n        key: \"validateNoLeftRecursion\",\n        value: function validateNoLeftRecursion(rules) {\n          return flatMap(rules, function (currTopRule) {\n            return _validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider);\n          });\n        }\n      }, {\n        key: \"validateEmptyOrAlternatives\",\n        value: function validateEmptyOrAlternatives(rules) {\n          return flatMap(rules, function (currTopRule) {\n            return validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider);\n          });\n        }\n      }, {\n        key: \"validateAmbiguousAlternationAlternatives\",\n        value: function validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n          return flatMap(rules, function (currTopRule) {\n            return _validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider);\n          });\n        }\n      }, {\n        key: \"validateSomeNonEmptyLookaheadPath\",\n        value: function validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n          return _validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n        }\n      }, {\n        key: \"buildLookaheadForAlternation\",\n        value: function buildLookaheadForAlternation(options) {\n          return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n        }\n      }, {\n        key: \"buildLookaheadForOptional\",\n        value: function buildLookaheadForOptional(options) {\n          return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);\n        }\n      }]);\n      return LLkLookaheadStrategy;\n    }();\n    var LooksAhead = /*#__PURE__*/function () {\n      function LooksAhead() {\n        _classCallCheck(this, LooksAhead);\n      }\n      _createClass(LooksAhead, [{\n        key: \"initLooksAhead\",\n        value: function initLooksAhead(config) {\n          this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n          this.maxLookahead = has(config, \"maxLookahead\") ? config.maxLookahead : DEFAULT_PARSER_CONFIG.maxLookahead;\n          this.lookaheadStrategy = has(config, \"lookaheadStrategy\") ? config.lookaheadStrategy : new LLkLookaheadStrategy({\n            maxLookahead: this.maxLookahead\n          });\n          this.lookAheadFuncsCache = /* @__PURE__ */new Map();\n        }\n      }, {\n        key: \"preComputeLookaheadFunctions\",\n        value: function preComputeLookaheadFunctions(rules) {\n          var _this40 = this;\n          forEach(rules, function (currRule) {\n            _this40.TRACE_INIT(\"\".concat(currRule.name, \" Rule Lookahead\"), function () {\n              var _collectMethods = collectMethods(currRule),\n                alternation = _collectMethods.alternation,\n                repetition = _collectMethods.repetition,\n                option = _collectMethods.option,\n                repetitionMandatory = _collectMethods.repetitionMandatory,\n                repetitionMandatoryWithSeparator = _collectMethods.repetitionMandatoryWithSeparator,\n                repetitionWithSeparator = _collectMethods.repetitionWithSeparator;\n              forEach(alternation, function (currProd) {\n                var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                _this40.TRACE_INIT(\"\".concat(getProductionDslName(currProd)).concat(prodIdx), function () {\n                  var laFunc = _this40.lookaheadStrategy.buildLookaheadForAlternation({\n                    prodOccurrence: currProd.idx,\n                    rule: currRule,\n                    maxLookahead: currProd.maxLookahead || _this40.maxLookahead,\n                    hasPredicates: currProd.hasPredicates,\n                    dynamicTokensEnabled: _this40.dynamicTokensEnabled\n                  });\n                  var key = _getKeyForAutomaticLookahead(_this40.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n                  _this40.setLaFuncCache(key, laFunc);\n                });\n              });\n              forEach(repetition, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, \"Repetition\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n              forEach(option, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, \"Option\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n              forEach(repetitionMandatory, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n              forEach(repetitionMandatoryWithSeparator, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n              forEach(repetitionWithSeparator, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n            });\n          });\n        }\n      }, {\n        key: \"computeLookaheadFunc\",\n        value: function computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n          var _this41 = this;\n          this.TRACE_INIT(\"\".concat(dslMethodName).concat(prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n            var laFunc = _this41.lookaheadStrategy.buildLookaheadForOptional({\n              prodOccurrence: prodOccurrence,\n              rule: rule,\n              maxLookahead: prodMaxLookahead || _this41.maxLookahead,\n              dynamicTokensEnabled: _this41.dynamicTokensEnabled,\n              prodType: prodType\n            });\n            var key = _getKeyForAutomaticLookahead(_this41.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            _this41.setLaFuncCache(key, laFunc);\n          });\n        }\n        // this actually returns a number, but it is always used as a string (object prop key)\n      }, {\n        key: \"getKeyForAutomaticLookahead\",\n        value: function getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n          var currRuleShortName = this.getLastExplicitRuleShortName();\n          return _getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n        }\n      }, {\n        key: \"getLaFuncFromCache\",\n        value: function getLaFuncFromCache(key) {\n          return this.lookAheadFuncsCache.get(key);\n        }\n        /* istanbul ignore next */\n      }, {\n        key: \"setLaFuncCache\",\n        value: function setLaFuncCache(key, value) {\n          this.lookAheadFuncsCache.set(key, value);\n        }\n      }]);\n      return LooksAhead;\n    }();\n    var DslMethodsCollectorVisitor = /*#__PURE__*/function (_GAstVisitor6) {\n      _inherits(DslMethodsCollectorVisitor, _GAstVisitor6);\n      var _super33 = _createSuper(DslMethodsCollectorVisitor);\n      function DslMethodsCollectorVisitor() {\n        var _this42;\n        _classCallCheck(this, DslMethodsCollectorVisitor);\n        _this42 = _super33.apply(this, arguments);\n        _this42.dslMethods = {\n          option: [],\n          alternation: [],\n          repetition: [],\n          repetitionWithSeparator: [],\n          repetitionMandatory: [],\n          repetitionMandatoryWithSeparator: []\n        };\n        return _this42;\n      }\n      _createClass(DslMethodsCollectorVisitor, [{\n        key: \"reset\",\n        value: function reset() {\n          this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n          };\n        }\n      }, {\n        key: \"visitOption\",\n        value: function visitOption(option) {\n          this.dslMethods.option.push(option);\n        }\n      }, {\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(manySep) {\n          this.dslMethods.repetitionWithSeparator.push(manySep);\n        }\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(atLeastOne) {\n          this.dslMethods.repetitionMandatory.push(atLeastOne);\n        }\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n          this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n        }\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(many) {\n          this.dslMethods.repetition.push(many);\n        }\n      }, {\n        key: \"visitAlternation\",\n        value: function visitAlternation(or) {\n          this.dslMethods.alternation.push(or);\n        }\n      }]);\n      return DslMethodsCollectorVisitor;\n    }(GAstVisitor);\n    var collectorVisitor = new DslMethodsCollectorVisitor();\n    function collectMethods(rule) {\n      collectorVisitor.reset();\n      rule.accept(collectorVisitor);\n      var dslMethods = collectorVisitor.dslMethods;\n      collectorVisitor.reset();\n      return dslMethods;\n    }\n    function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n      if (isNaN(currNodeLocation.startOffset) === true) {\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n      }\n    }\n    function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n      if (isNaN(currNodeLocation.startOffset) === true) {\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n      }\n    }\n    function addTerminalToCst(node, token, tokenTypeName) {\n      if (node.children[tokenTypeName] === void 0) {\n        node.children[tokenTypeName] = [token];\n      } else {\n        node.children[tokenTypeName].push(token);\n      }\n    }\n    function addNoneTerminalToCst(node, ruleName, ruleResult) {\n      if (node.children[ruleName] === void 0) {\n        node.children[ruleName] = [ruleResult];\n      } else {\n        node.children[ruleName].push(ruleResult);\n      }\n    }\n    var NAME = \"name\";\n    function defineNameProp(obj, nameValue) {\n      Object.defineProperty(obj, NAME, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: nameValue\n      });\n    }\n    function defaultVisit(ctx, param) {\n      var childrenNames = keys(ctx);\n      var childrenNamesLength = childrenNames.length;\n      for (var _i15 = 0; _i15 < childrenNamesLength; _i15++) {\n        var currChildName = childrenNames[_i15];\n        var currChildArray = ctx[currChildName];\n        var currChildArrayLength = currChildArray.length;\n        for (var j = 0; j < currChildArrayLength; j++) {\n          var currChild = currChildArray[j];\n          if (currChild.tokenTypeIdx === void 0) {\n            this[currChild.name](currChild.children, param);\n          }\n        }\n      }\n    }\n    function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n      var derivedConstructor = function derivedConstructor() {};\n      defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n      var semanticProto = {\n        visit: function visit(cstNode, param) {\n          if (isArray$1(cstNode)) {\n            cstNode = cstNode[0];\n          }\n          if (isUndefined(cstNode)) {\n            return void 0;\n          }\n          return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function validateVisitor() {\n          var semanticDefinitionErrors = _validateVisitor(this, ruleNames);\n          if (!isEmpty(semanticDefinitionErrors)) {\n            var errorMessages = map(semanticDefinitionErrors, function (currDefError) {\n              return currDefError.msg;\n            });\n            throw Error(\"Errors Detected in CST Visitor <\".concat(this.constructor.name, \">:\\n\\t\").concat(errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\t\")));\n          }\n        }\n      };\n      derivedConstructor.prototype = semanticProto;\n      derivedConstructor.prototype.constructor = derivedConstructor;\n      derivedConstructor._RULE_NAMES = ruleNames;\n      return derivedConstructor;\n    }\n    function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n      var derivedConstructor = function derivedConstructor() {};\n      defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n      var withDefaultsProto = Object.create(baseConstructor.prototype);\n      forEach(ruleNames, function (ruleName) {\n        withDefaultsProto[ruleName] = defaultVisit;\n      });\n      derivedConstructor.prototype = withDefaultsProto;\n      derivedConstructor.prototype.constructor = derivedConstructor;\n      return derivedConstructor;\n    }\n    var CstVisitorDefinitionError;\n    (function (CstVisitorDefinitionError2) {\n      CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n      CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n    })(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\n    function _validateVisitor(visitorInstance, ruleNames) {\n      var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n      return missingErrors;\n    }\n    function validateMissingCstMethods(visitorInstance, ruleNames) {\n      var missingRuleNames = filter(ruleNames, function (currRuleName) {\n        return isFunction(visitorInstance[currRuleName]) === false;\n      });\n      var errors = map(missingRuleNames, function (currRuleName) {\n        return {\n          msg: \"Missing visitor method: <\".concat(currRuleName, \"> on \").concat(visitorInstance.constructor.name, \" CST Visitor.\"),\n          type: CstVisitorDefinitionError.MISSING_METHOD,\n          methodName: currRuleName\n        };\n      });\n      return compact(errors);\n    }\n    var TreeBuilder = /*#__PURE__*/function () {\n      function TreeBuilder() {\n        _classCallCheck(this, TreeBuilder);\n      }\n      _createClass(TreeBuilder, [{\n        key: \"initTreeBuilder\",\n        value: function initTreeBuilder(config) {\n          this.CST_STACK = [];\n          this.outputCst = config.outputCst;\n          this.nodeLocationTracking = has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n          if (!this.outputCst) {\n            this.cstInvocationStateUpdate = noop;\n            this.cstFinallyStateUpdate = noop;\n            this.cstPostTerminal = noop;\n            this.cstPostNonTerminal = noop;\n            this.cstPostRule = noop;\n          } else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n              if (this.recoveryEnabled) {\n                this.setNodeLocationFromToken = setNodeLocationFull;\n                this.setNodeLocationFromNode = setNodeLocationFull;\n                this.cstPostRule = noop;\n                this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n              } else {\n                this.setNodeLocationFromToken = noop;\n                this.setNodeLocationFromNode = noop;\n                this.cstPostRule = this.cstPostRuleFull;\n                this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n              }\n            } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n              if (this.recoveryEnabled) {\n                this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n                this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n                this.cstPostRule = noop;\n                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n              } else {\n                this.setNodeLocationFromToken = noop;\n                this.setNodeLocationFromNode = noop;\n                this.cstPostRule = this.cstPostRuleOnlyOffset;\n                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n              }\n            } else if (/none/i.test(this.nodeLocationTracking)) {\n              this.setNodeLocationFromToken = noop;\n              this.setNodeLocationFromNode = noop;\n              this.cstPostRule = noop;\n              this.setInitialNodeLocation = noop;\n            } else {\n              throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\".concat(config.nodeLocationTracking, \"\\\"\"));\n            }\n          }\n        }\n      }, {\n        key: \"setInitialNodeLocationOnlyOffsetRecovery\",\n        value: function setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n          cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n          };\n        }\n      }, {\n        key: \"setInitialNodeLocationOnlyOffsetRegular\",\n        value: function setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n          cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n          };\n        }\n      }, {\n        key: \"setInitialNodeLocationFullRecovery\",\n        value: function setInitialNodeLocationFullRecovery(cstNode) {\n          cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n          };\n        }\n        /**\n             *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n        \n             * @param cstNode\n             */\n      }, {\n        key: \"setInitialNodeLocationFullRegular\",\n        value: function setInitialNodeLocationFullRegular(cstNode) {\n          var nextToken = this.LA(1);\n          cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n          };\n        }\n      }, {\n        key: \"cstInvocationStateUpdate\",\n        value: function cstInvocationStateUpdate(fullRuleName) {\n          var cstNode = {\n            name: fullRuleName,\n            children: /* @__PURE__ */Object.create(null)\n          };\n          this.setInitialNodeLocation(cstNode);\n          this.CST_STACK.push(cstNode);\n        }\n      }, {\n        key: \"cstFinallyStateUpdate\",\n        value: function cstFinallyStateUpdate() {\n          this.CST_STACK.pop();\n        }\n      }, {\n        key: \"cstPostRuleFull\",\n        value: function cstPostRuleFull(ruleCstNode) {\n          var prevToken = this.LA(0);\n          var loc = ruleCstNode.location;\n          if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n          } else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n          }\n        }\n      }, {\n        key: \"cstPostRuleOnlyOffset\",\n        value: function cstPostRuleOnlyOffset(ruleCstNode) {\n          var prevToken = this.LA(0);\n          var loc = ruleCstNode.location;\n          if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n          } else {\n            loc.startOffset = NaN;\n          }\n        }\n      }, {\n        key: \"cstPostTerminal\",\n        value: function cstPostTerminal(key, consumedToken) {\n          var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n          addTerminalToCst(rootCst, consumedToken, key);\n          this.setNodeLocationFromToken(rootCst.location, consumedToken);\n        }\n      }, {\n        key: \"cstPostNonTerminal\",\n        value: function cstPostNonTerminal(ruleCstResult, ruleName) {\n          var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n          addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n          this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n        }\n      }, {\n        key: \"getBaseCstVisitorConstructor\",\n        value: function getBaseCstVisitorConstructor() {\n          if (isUndefined(this.baseCstVisitorConstructor)) {\n            var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n          }\n          return this.baseCstVisitorConstructor;\n        }\n      }, {\n        key: \"getBaseCstVisitorConstructorWithDefaults\",\n        value: function getBaseCstVisitorConstructorWithDefaults() {\n          if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n          }\n          return this.baseCstVisitorWithDefaultsConstructor;\n        }\n      }, {\n        key: \"getLastExplicitRuleShortName\",\n        value: function getLastExplicitRuleShortName() {\n          var ruleStack = this.RULE_STACK;\n          return ruleStack[ruleStack.length - 1];\n        }\n      }, {\n        key: \"getPreviousExplicitRuleShortName\",\n        value: function getPreviousExplicitRuleShortName() {\n          var ruleStack = this.RULE_STACK;\n          return ruleStack[ruleStack.length - 2];\n        }\n      }, {\n        key: \"getLastExplicitRuleOccurrenceIndex\",\n        value: function getLastExplicitRuleOccurrenceIndex() {\n          var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n          return occurrenceStack[occurrenceStack.length - 1];\n        }\n      }]);\n      return TreeBuilder;\n    }();\n    var LexerAdapter = /*#__PURE__*/function () {\n      function LexerAdapter() {\n        _classCallCheck(this, LexerAdapter);\n      }\n      _createClass(LexerAdapter, [{\n        key: \"initLexerAdapter\",\n        value: function initLexerAdapter() {\n          this.tokVector = [];\n          this.tokVectorLength = 0;\n          this.currIdx = -1;\n        }\n      }, {\n        key: \"input\",\n        get: function get() {\n          return this.tokVector;\n        }\n        // skips a token and returns the next token\n        ,\n        set: function set(newInput) {\n          if (this.selfAnalysisDone !== true) {\n            throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n          }\n          this.reset();\n          this.tokVector = newInput;\n          this.tokVectorLength = newInput.length;\n        }\n      }, {\n        key: \"SKIP_TOKEN\",\n        value: function SKIP_TOKEN() {\n          if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n          } else {\n            return END_OF_FILE;\n          }\n        }\n        // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n        // or lexers dependent on parser context.\n      }, {\n        key: \"LA\",\n        value: function LA(howMuch) {\n          var soughtIdx = this.currIdx + howMuch;\n          if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return END_OF_FILE;\n          } else {\n            return this.tokVector[soughtIdx];\n          }\n        }\n      }, {\n        key: \"consumeToken\",\n        value: function consumeToken() {\n          this.currIdx++;\n        }\n      }, {\n        key: \"exportLexerState\",\n        value: function exportLexerState() {\n          return this.currIdx;\n        }\n      }, {\n        key: \"importLexerState\",\n        value: function importLexerState(newState) {\n          this.currIdx = newState;\n        }\n      }, {\n        key: \"resetLexerState\",\n        value: function resetLexerState() {\n          this.currIdx = -1;\n        }\n      }, {\n        key: \"moveToTerminatedState\",\n        value: function moveToTerminatedState() {\n          this.currIdx = this.tokVector.length - 1;\n        }\n      }, {\n        key: \"getLexerPosition\",\n        value: function getLexerPosition() {\n          return this.exportLexerState();\n        }\n      }]);\n      return LexerAdapter;\n    }();\n    var RecognizerApi = /*#__PURE__*/function () {\n      function RecognizerApi() {\n        _classCallCheck(this, RecognizerApi);\n      }\n      _createClass(RecognizerApi, [{\n        key: \"ACTION\",\n        value: function ACTION(impl) {\n          return impl.call(this);\n        }\n      }, {\n        key: \"consume\",\n        value: function consume(idx, tokType, options) {\n          return this.consumeInternal(tokType, idx, options);\n        }\n      }, {\n        key: \"subrule\",\n        value: function subrule(idx, ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, idx, options);\n        }\n      }, {\n        key: \"option\",\n        value: function option(idx, actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, idx);\n        }\n      }, {\n        key: \"or\",\n        value: function or(idx, altsOrOpts) {\n          return this.orInternal(altsOrOpts, idx);\n        }\n      }, {\n        key: \"many\",\n        value: function many(idx, actionORMethodDef) {\n          return this.manyInternal(idx, actionORMethodDef);\n        }\n      }, {\n        key: \"atLeastOne\",\n        value: function atLeastOne(idx, actionORMethodDef) {\n          return this.atLeastOneInternal(idx, actionORMethodDef);\n        }\n      }, {\n        key: \"CONSUME\",\n        value: function CONSUME(tokType, options) {\n          return this.consumeInternal(tokType, 0, options);\n        }\n      }, {\n        key: \"CONSUME1\",\n        value: function CONSUME1(tokType, options) {\n          return this.consumeInternal(tokType, 1, options);\n        }\n      }, {\n        key: \"CONSUME2\",\n        value: function CONSUME2(tokType, options) {\n          return this.consumeInternal(tokType, 2, options);\n        }\n      }, {\n        key: \"CONSUME3\",\n        value: function CONSUME3(tokType, options) {\n          return this.consumeInternal(tokType, 3, options);\n        }\n      }, {\n        key: \"CONSUME4\",\n        value: function CONSUME4(tokType, options) {\n          return this.consumeInternal(tokType, 4, options);\n        }\n      }, {\n        key: \"CONSUME5\",\n        value: function CONSUME5(tokType, options) {\n          return this.consumeInternal(tokType, 5, options);\n        }\n      }, {\n        key: \"CONSUME6\",\n        value: function CONSUME6(tokType, options) {\n          return this.consumeInternal(tokType, 6, options);\n        }\n      }, {\n        key: \"CONSUME7\",\n        value: function CONSUME7(tokType, options) {\n          return this.consumeInternal(tokType, 7, options);\n        }\n      }, {\n        key: \"CONSUME8\",\n        value: function CONSUME8(tokType, options) {\n          return this.consumeInternal(tokType, 8, options);\n        }\n      }, {\n        key: \"CONSUME9\",\n        value: function CONSUME9(tokType, options) {\n          return this.consumeInternal(tokType, 9, options);\n        }\n      }, {\n        key: \"SUBRULE\",\n        value: function SUBRULE(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 0, options);\n        }\n      }, {\n        key: \"SUBRULE1\",\n        value: function SUBRULE1(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 1, options);\n        }\n      }, {\n        key: \"SUBRULE2\",\n        value: function SUBRULE2(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 2, options);\n        }\n      }, {\n        key: \"SUBRULE3\",\n        value: function SUBRULE3(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 3, options);\n        }\n      }, {\n        key: \"SUBRULE4\",\n        value: function SUBRULE4(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 4, options);\n        }\n      }, {\n        key: \"SUBRULE5\",\n        value: function SUBRULE5(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 5, options);\n        }\n      }, {\n        key: \"SUBRULE6\",\n        value: function SUBRULE6(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 6, options);\n        }\n      }, {\n        key: \"SUBRULE7\",\n        value: function SUBRULE7(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 7, options);\n        }\n      }, {\n        key: \"SUBRULE8\",\n        value: function SUBRULE8(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 8, options);\n        }\n      }, {\n        key: \"SUBRULE9\",\n        value: function SUBRULE9(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 9, options);\n        }\n      }, {\n        key: \"OPTION\",\n        value: function OPTION(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 0);\n        }\n      }, {\n        key: \"OPTION1\",\n        value: function OPTION1(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 1);\n        }\n      }, {\n        key: \"OPTION2\",\n        value: function OPTION2(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 2);\n        }\n      }, {\n        key: \"OPTION3\",\n        value: function OPTION3(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 3);\n        }\n      }, {\n        key: \"OPTION4\",\n        value: function OPTION4(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 4);\n        }\n      }, {\n        key: \"OPTION5\",\n        value: function OPTION5(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 5);\n        }\n      }, {\n        key: \"OPTION6\",\n        value: function OPTION6(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 6);\n        }\n      }, {\n        key: \"OPTION7\",\n        value: function OPTION7(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 7);\n        }\n      }, {\n        key: \"OPTION8\",\n        value: function OPTION8(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 8);\n        }\n      }, {\n        key: \"OPTION9\",\n        value: function OPTION9(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 9);\n        }\n      }, {\n        key: \"OR\",\n        value: function OR(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 0);\n        }\n      }, {\n        key: \"OR1\",\n        value: function OR1(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 1);\n        }\n      }, {\n        key: \"OR2\",\n        value: function OR2(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 2);\n        }\n      }, {\n        key: \"OR3\",\n        value: function OR3(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 3);\n        }\n      }, {\n        key: \"OR4\",\n        value: function OR4(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 4);\n        }\n      }, {\n        key: \"OR5\",\n        value: function OR5(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 5);\n        }\n      }, {\n        key: \"OR6\",\n        value: function OR6(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 6);\n        }\n      }, {\n        key: \"OR7\",\n        value: function OR7(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 7);\n        }\n      }, {\n        key: \"OR8\",\n        value: function OR8(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 8);\n        }\n      }, {\n        key: \"OR9\",\n        value: function OR9(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 9);\n        }\n      }, {\n        key: \"MANY\",\n        value: function MANY(actionORMethodDef) {\n          this.manyInternal(0, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY1\",\n        value: function MANY1(actionORMethodDef) {\n          this.manyInternal(1, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY2\",\n        value: function MANY2(actionORMethodDef) {\n          this.manyInternal(2, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY3\",\n        value: function MANY3(actionORMethodDef) {\n          this.manyInternal(3, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY4\",\n        value: function MANY4(actionORMethodDef) {\n          this.manyInternal(4, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY5\",\n        value: function MANY5(actionORMethodDef) {\n          this.manyInternal(5, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY6\",\n        value: function MANY6(actionORMethodDef) {\n          this.manyInternal(6, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY7\",\n        value: function MANY7(actionORMethodDef) {\n          this.manyInternal(7, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY8\",\n        value: function MANY8(actionORMethodDef) {\n          this.manyInternal(8, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY9\",\n        value: function MANY9(actionORMethodDef) {\n          this.manyInternal(9, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY_SEP\",\n        value: function MANY_SEP(options) {\n          this.manySepFirstInternal(0, options);\n        }\n      }, {\n        key: \"MANY_SEP1\",\n        value: function MANY_SEP1(options) {\n          this.manySepFirstInternal(1, options);\n        }\n      }, {\n        key: \"MANY_SEP2\",\n        value: function MANY_SEP2(options) {\n          this.manySepFirstInternal(2, options);\n        }\n      }, {\n        key: \"MANY_SEP3\",\n        value: function MANY_SEP3(options) {\n          this.manySepFirstInternal(3, options);\n        }\n      }, {\n        key: \"MANY_SEP4\",\n        value: function MANY_SEP4(options) {\n          this.manySepFirstInternal(4, options);\n        }\n      }, {\n        key: \"MANY_SEP5\",\n        value: function MANY_SEP5(options) {\n          this.manySepFirstInternal(5, options);\n        }\n      }, {\n        key: \"MANY_SEP6\",\n        value: function MANY_SEP6(options) {\n          this.manySepFirstInternal(6, options);\n        }\n      }, {\n        key: \"MANY_SEP7\",\n        value: function MANY_SEP7(options) {\n          this.manySepFirstInternal(7, options);\n        }\n      }, {\n        key: \"MANY_SEP8\",\n        value: function MANY_SEP8(options) {\n          this.manySepFirstInternal(8, options);\n        }\n      }, {\n        key: \"MANY_SEP9\",\n        value: function MANY_SEP9(options) {\n          this.manySepFirstInternal(9, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE\",\n        value: function AT_LEAST_ONE(actionORMethodDef) {\n          this.atLeastOneInternal(0, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE1\",\n        value: function AT_LEAST_ONE1(actionORMethodDef) {\n          return this.atLeastOneInternal(1, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE2\",\n        value: function AT_LEAST_ONE2(actionORMethodDef) {\n          this.atLeastOneInternal(2, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE3\",\n        value: function AT_LEAST_ONE3(actionORMethodDef) {\n          this.atLeastOneInternal(3, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE4\",\n        value: function AT_LEAST_ONE4(actionORMethodDef) {\n          this.atLeastOneInternal(4, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE5\",\n        value: function AT_LEAST_ONE5(actionORMethodDef) {\n          this.atLeastOneInternal(5, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE6\",\n        value: function AT_LEAST_ONE6(actionORMethodDef) {\n          this.atLeastOneInternal(6, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE7\",\n        value: function AT_LEAST_ONE7(actionORMethodDef) {\n          this.atLeastOneInternal(7, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE8\",\n        value: function AT_LEAST_ONE8(actionORMethodDef) {\n          this.atLeastOneInternal(8, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE9\",\n        value: function AT_LEAST_ONE9(actionORMethodDef) {\n          this.atLeastOneInternal(9, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP\",\n        value: function AT_LEAST_ONE_SEP(options) {\n          this.atLeastOneSepFirstInternal(0, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP1\",\n        value: function AT_LEAST_ONE_SEP1(options) {\n          this.atLeastOneSepFirstInternal(1, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP2\",\n        value: function AT_LEAST_ONE_SEP2(options) {\n          this.atLeastOneSepFirstInternal(2, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP3\",\n        value: function AT_LEAST_ONE_SEP3(options) {\n          this.atLeastOneSepFirstInternal(3, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP4\",\n        value: function AT_LEAST_ONE_SEP4(options) {\n          this.atLeastOneSepFirstInternal(4, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP5\",\n        value: function AT_LEAST_ONE_SEP5(options) {\n          this.atLeastOneSepFirstInternal(5, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP6\",\n        value: function AT_LEAST_ONE_SEP6(options) {\n          this.atLeastOneSepFirstInternal(6, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP7\",\n        value: function AT_LEAST_ONE_SEP7(options) {\n          this.atLeastOneSepFirstInternal(7, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP8\",\n        value: function AT_LEAST_ONE_SEP8(options) {\n          this.atLeastOneSepFirstInternal(8, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP9\",\n        value: function AT_LEAST_ONE_SEP9(options) {\n          this.atLeastOneSepFirstInternal(9, options);\n        }\n      }, {\n        key: \"RULE\",\n        value: function RULE(name, implementation) {\n          var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RULE_CONFIG;\n          if (includes(this.definedRulesNames, name)) {\n            var errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n              topLevelRule: name,\n              grammarName: this.className\n            });\n            var error = {\n              message: errMsg,\n              type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n              ruleName: name\n            };\n            this.definitionErrors.push(error);\n          }\n          this.definedRulesNames.push(name);\n          var ruleImplementation = this.defineRule(name, implementation, config);\n          this[name] = ruleImplementation;\n          return ruleImplementation;\n        }\n      }, {\n        key: \"OVERRIDE_RULE\",\n        value: function OVERRIDE_RULE(name, impl) {\n          var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RULE_CONFIG;\n          var ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n          this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n          var ruleImplementation = this.defineRule(name, impl, config);\n          this[name] = ruleImplementation;\n          return ruleImplementation;\n        }\n      }, {\n        key: \"BACKTRACK\",\n        value: function BACKTRACK(grammarRule, args) {\n          return function () {\n            this.isBackTrackingStack.push(1);\n            var orgState = this.saveRecogState();\n            try {\n              grammarRule.apply(this, args);\n              return true;\n            } catch (e) {\n              if (isRecognitionException(e)) {\n                return false;\n              } else {\n                throw e;\n              }\n            } finally {\n              this.reloadRecogState(orgState);\n              this.isBackTrackingStack.pop();\n            }\n          };\n        }\n        // GAST export APIs\n      }, {\n        key: \"getGAstProductions\",\n        value: function getGAstProductions() {\n          return this.gastProductionsCache;\n        }\n      }, {\n        key: \"getSerializedGastProductions\",\n        value: function getSerializedGastProductions() {\n          return serializeGrammar(values(this.gastProductionsCache));\n        }\n      }]);\n      return RecognizerApi;\n    }();\n    var RecognizerEngine = /*#__PURE__*/function () {\n      function RecognizerEngine() {\n        _classCallCheck(this, RecognizerEngine);\n      }\n      _createClass(RecognizerEngine, [{\n        key: \"initRecognizerEngine\",\n        value: function initRecognizerEngine(tokenVocabulary, config) {\n          this.className = this.constructor.name;\n          this.shortRuleNameToFull = {};\n          this.fullRuleNameToShort = {};\n          this.ruleShortNameIdx = 256;\n          this.tokenMatcher = tokenStructuredMatcherNoCategories;\n          this.subruleIdx = 0;\n          this.definedRulesNames = [];\n          this.tokensMap = {};\n          this.isBackTrackingStack = [];\n          this.RULE_STACK = [];\n          this.RULE_OCCURRENCE_STACK = [];\n          this.gastProductionsCache = {};\n          if (has(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\tFor Further details.\");\n          }\n          if (isArray$1(tokenVocabulary)) {\n            if (isEmpty(tokenVocabulary)) {\n              throw Error(\"A Token Vocabulary cannot be empty.\\n\tNote that the first argument for the parser constructor\\n\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n              throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\tFor Further details.\");\n            }\n          }\n          if (isArray$1(tokenVocabulary)) {\n            this.tokensMap = reduce(tokenVocabulary, function (acc, tokType) {\n              acc[tokType.name] = tokType;\n              return acc;\n            }, {});\n          } else if (has(tokenVocabulary, \"modes\") && every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n            var allTokenTypes2 = flatten(values(tokenVocabulary.modes));\n            var uniqueTokens = uniq(allTokenTypes2);\n            this.tokensMap = reduce(uniqueTokens, function (acc, tokType) {\n              acc[tokType.name] = tokType;\n              return acc;\n            }, {});\n          } else if (isObject(tokenVocabulary)) {\n            this.tokensMap = clone(tokenVocabulary);\n          } else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n          }\n          this.tokensMap[\"EOF\"] = EOF;\n          var allTokenTypes = has(tokenVocabulary, \"modes\") ? flatten(values(tokenVocabulary.modes)) : values(tokenVocabulary);\n          var noTokenCategoriesUsed = every(allTokenTypes, function (tokenConstructor) {\n            return isEmpty(tokenConstructor.categoryMatches);\n          });\n          this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n          augmentTokenTypes(values(this.tokensMap));\n        }\n      }, {\n        key: \"defineRule\",\n        value: function defineRule(ruleName, impl, config) {\n          if (this.selfAnalysisDone) {\n            throw Error(\"Grammar rule <\".concat(ruleName, \"> may not be defined after the 'performSelfAnalysis' method has been called'\\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\"));\n          }\n          var resyncEnabled = has(config, \"resyncEnabled\") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;\n          var recoveryValueFunc = has(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n          var shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;\n          this.ruleShortNameIdx++;\n          this.shortRuleNameToFull[shortName] = ruleName;\n          this.fullRuleNameToShort[ruleName] = shortName;\n          var invokeRuleWithTry;\n          if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry2() {\n              try {\n                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                impl.apply(this, args);\n                var cst = this.CST_STACK[this.CST_STACK.length - 1];\n                this.cstPostRule(cst);\n                return cst;\n              } catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n              } finally {\n                this.ruleFinallyStateUpdate();\n              }\n            };\n          } else {\n            invokeRuleWithTry = function invokeRuleWithTryCst() {\n              try {\n                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n                return impl.apply(this, args);\n              } catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n              } finally {\n                this.ruleFinallyStateUpdate();\n              }\n            };\n          }\n          var wrappedGrammarRule = Object.assign(invokeRuleWithTry, {\n            ruleName: ruleName,\n            originalGrammarAction: impl\n          });\n          return wrappedGrammarRule;\n        }\n      }, {\n        key: \"invokeRuleCatch\",\n        value: function invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n          var isFirstInvokedRule = this.RULE_STACK.length === 1;\n          var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n          if (isRecognitionException(e)) {\n            var recogError = e;\n            if (reSyncEnabled) {\n              var reSyncTokType = this.findReSyncTokenType();\n              if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                if (this.outputCst) {\n                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                  partialCstResult.recoveredNode = true;\n                  return partialCstResult;\n                } else {\n                  return recoveryValueFunc(e);\n                }\n              } else {\n                if (this.outputCst) {\n                  var _partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                  _partialCstResult.recoveredNode = true;\n                  recogError.partialCstResult = _partialCstResult;\n                }\n                throw recogError;\n              }\n            } else if (isFirstInvokedRule) {\n              this.moveToTerminatedState();\n              return recoveryValueFunc(e);\n            } else {\n              throw recogError;\n            }\n          } else {\n            throw e;\n          }\n        }\n        // Implementation of parsing DSL\n      }, {\n        key: \"optionInternal\",\n        value: function optionInternal(actionORMethodDef, occurrence) {\n          var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n          return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n        }\n      }, {\n        key: \"optionInternalLogic\",\n        value: function optionInternalLogic(actionORMethodDef, occurrence, key) {\n          var _this43 = this;\n          var lookAheadFunc = this.getLaFuncFromCache(key);\n          var action;\n          if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate = actionORMethodDef.GATE;\n            if (predicate !== void 0) {\n              var orgLookaheadFunction = lookAheadFunc;\n              lookAheadFunc = function lookAheadFunc() {\n                return predicate.call(_this43) && orgLookaheadFunction.call(_this43);\n              };\n            }\n          } else {\n            action = actionORMethodDef;\n          }\n          if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n          }\n          return void 0;\n        }\n      }, {\n        key: \"atLeastOneInternal\",\n        value: function atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n          var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n          return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n      }, {\n        key: \"atLeastOneInternalLogic\",\n        value: function atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n          var _this44 = this;\n          var lookAheadFunc = this.getLaFuncFromCache(key);\n          var action;\n          if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate = actionORMethodDef.GATE;\n            if (predicate !== void 0) {\n              var orgLookaheadFunction = lookAheadFunc;\n              lookAheadFunc = function lookAheadFunc() {\n                return predicate.call(_this44) && orgLookaheadFunction.call(_this44);\n              };\n            }\n          } else {\n            action = actionORMethodDef;\n          }\n          if (lookAheadFunc.call(this) === true) {\n            var notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true && notStuck === true) {\n              notStuck = this.doSingleRepetition(action);\n            }\n          } else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n          }\n          this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n        }\n      }, {\n        key: \"atLeastOneSepFirstInternal\",\n        value: function atLeastOneSepFirstInternal(prodOccurrence, options) {\n          var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n          this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n      }, {\n        key: \"atLeastOneSepFirstInternalLogic\",\n        value: function atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n          var _this45 = this;\n          var action = options.DEF;\n          var separator = options.SEP;\n          var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n          if (firstIterationLookaheadFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function separatorLookAheadFunc() {\n              return _this45.tokenMatcher(_this45.LA(1), separator);\n            };\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n              this.CONSUME(separator);\n              action.call(this);\n            }\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n          } else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n          }\n        }\n      }, {\n        key: \"manyInternal\",\n        value: function manyInternal(prodOccurrence, actionORMethodDef) {\n          var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n          return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n      }, {\n        key: \"manyInternalLogic\",\n        value: function manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n          var _this46 = this;\n          var lookaheadFunction = this.getLaFuncFromCache(key);\n          var action;\n          if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate = actionORMethodDef.GATE;\n            if (predicate !== void 0) {\n              var orgLookaheadFunction = lookaheadFunction;\n              lookaheadFunction = function lookaheadFunction() {\n                return predicate.call(_this46) && orgLookaheadFunction.call(_this46);\n              };\n            }\n          } else {\n            action = actionORMethodDef;\n          }\n          var notStuck = true;\n          while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n          }\n          this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker,\n          // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n          // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n          // An infinite loop cannot occur as:\n          // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n          // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n          notStuck);\n        }\n      }, {\n        key: \"manySepFirstInternal\",\n        value: function manySepFirstInternal(prodOccurrence, options) {\n          var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n          this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n      }, {\n        key: \"manySepFirstInternalLogic\",\n        value: function manySepFirstInternalLogic(prodOccurrence, options, key) {\n          var _this47 = this;\n          var action = options.DEF;\n          var separator = options.SEP;\n          var firstIterationLaFunc = this.getLaFuncFromCache(key);\n          if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function separatorLookAheadFunc() {\n              return _this47.tokenMatcher(_this47.LA(1), separator);\n            };\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n              this.CONSUME(separator);\n              action.call(this);\n            }\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterManySepWalker], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n          }\n        }\n      }, {\n        key: \"repetitionSepSecondInternal\",\n        value: function repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n          while (separatorLookAheadFunc()) {\n            this.CONSUME(separator);\n            action.call(this);\n          }\n          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n        }\n      }, {\n        key: \"doSingleRepetition\",\n        value: function doSingleRepetition(action) {\n          var beforeIteration = this.getLexerPosition();\n          action.call(this);\n          var afterIteration = this.getLexerPosition();\n          return afterIteration > beforeIteration;\n        }\n      }, {\n        key: \"orInternal\",\n        value: function orInternal(altsOrOpts, occurrence) {\n          var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n          var alts = isArray$1(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n          var laFunc = this.getLaFuncFromCache(laKey);\n          var altIdxToTake = laFunc.call(this, alts);\n          if (altIdxToTake !== void 0) {\n            var chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n          }\n          this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n        }\n      }, {\n        key: \"ruleFinallyStateUpdate\",\n        value: function ruleFinallyStateUpdate() {\n          this.RULE_STACK.pop();\n          this.RULE_OCCURRENCE_STACK.pop();\n          this.cstFinallyStateUpdate();\n          if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            var firstRedundantTok = this.LA(1);\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n              firstRedundant: firstRedundantTok,\n              ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n          }\n        }\n      }, {\n        key: \"subruleInternal\",\n        value: function subruleInternal(ruleToCall, idx, options) {\n          var ruleResult;\n          try {\n            var args = options !== void 0 ? options.ARGS : void 0;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);\n            return ruleResult;\n          } catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n          }\n        }\n      }, {\n        key: \"subruleInternalError\",\n        value: function subruleInternalError(e, options, ruleName) {\n          if (isRecognitionException(e) && e.partialCstResult !== void 0) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);\n            delete e.partialCstResult;\n          }\n          throw e;\n        }\n      }, {\n        key: \"consumeInternal\",\n        value: function consumeInternal(tokType, idx, options) {\n          var consumedToken;\n          try {\n            var nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n              this.consumeToken();\n              consumedToken = nextToken;\n            } else {\n              this.consumeInternalError(tokType, nextToken, options);\n            }\n          } catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n          }\n          this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);\n          return consumedToken;\n        }\n      }, {\n        key: \"consumeInternalError\",\n        value: function consumeInternalError(tokType, nextToken, options) {\n          var msg;\n          var previousToken = this.LA(0);\n          if (options !== void 0 && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n          } else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n              expected: tokType,\n              actual: nextToken,\n              previous: previousToken,\n              ruleName: this.getCurrRuleFullName()\n            });\n          }\n          throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n        }\n      }, {\n        key: \"consumeInternalRecovery\",\n        value: function consumeInternalRecovery(tokType, idx, eFromConsumption) {\n          if (this.recoveryEnabled &&\n          // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n          eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n              return this.tryInRuleRecovery(tokType, follows);\n            } catch (eFromInRuleRecovery) {\n              if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n                throw eFromConsumption;\n              } else {\n                throw eFromInRuleRecovery;\n              }\n            }\n          } else {\n            throw eFromConsumption;\n          }\n        }\n      }, {\n        key: \"saveRecogState\",\n        value: function saveRecogState() {\n          var savedErrors = this.errors;\n          var savedRuleStack = clone(this.RULE_STACK);\n          return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK\n          };\n        }\n      }, {\n        key: \"reloadRecogState\",\n        value: function reloadRecogState(newState) {\n          this.errors = newState.errors;\n          this.importLexerState(newState.lexerState);\n          this.RULE_STACK = newState.RULE_STACK;\n        }\n      }, {\n        key: \"ruleInvocationStateUpdate\",\n        value: function ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n          this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n          this.RULE_STACK.push(shortName);\n          this.cstInvocationStateUpdate(fullName);\n        }\n      }, {\n        key: \"isBackTracking\",\n        value: function isBackTracking() {\n          return this.isBackTrackingStack.length !== 0;\n        }\n      }, {\n        key: \"getCurrRuleFullName\",\n        value: function getCurrRuleFullName() {\n          var shortName = this.getLastExplicitRuleShortName();\n          return this.shortRuleNameToFull[shortName];\n        }\n      }, {\n        key: \"shortRuleNameToFullName\",\n        value: function shortRuleNameToFullName(shortName) {\n          return this.shortRuleNameToFull[shortName];\n        }\n      }, {\n        key: \"isAtEndOfInput\",\n        value: function isAtEndOfInput() {\n          return this.tokenMatcher(this.LA(1), EOF);\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {\n          this.resetLexerState();\n          this.subruleIdx = 0;\n          this.isBackTrackingStack = [];\n          this.errors = [];\n          this.RULE_STACK = [];\n          this.CST_STACK = [];\n          this.RULE_OCCURRENCE_STACK = [];\n        }\n      }]);\n      return RecognizerEngine;\n    }();\n    var ErrorHandler = /*#__PURE__*/function () {\n      function ErrorHandler() {\n        _classCallCheck(this, ErrorHandler);\n      }\n      _createClass(ErrorHandler, [{\n        key: \"initErrorHandler\",\n        value: function initErrorHandler(config) {\n          this._errors = [];\n          this.errorMessageProvider = has(config, \"errorMessageProvider\") ? config.errorMessageProvider : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n        }\n      }, {\n        key: \"SAVE_ERROR\",\n        value: function SAVE_ERROR(error) {\n          if (isRecognitionException(error)) {\n            error.context = {\n              ruleStack: this.getHumanReadableRuleStack(),\n              ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n          } else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n          }\n        }\n      }, {\n        key: \"errors\",\n        get: function get() {\n          return clone(this._errors);\n        },\n        set: function set(newErrors) {\n          this._errors = newErrors;\n        }\n        // TODO: consider caching the error message computed information\n      }, {\n        key: \"raiseEarlyExitException\",\n        value: function raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n          var ruleName = this.getCurrRuleFullName();\n          var ruleGrammar = this.getGAstProductions()[ruleName];\n          var lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n          var insideProdPaths = lookAheadPathsPerAlternative[0];\n          var actualTokens = [];\n          for (var _i16 = 1; _i16 <= this.maxLookahead; _i16++) {\n            actualTokens.push(this.LA(_i16));\n          }\n          var msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n          });\n          throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n        }\n        // TODO: consider caching the error message computed information\n      }, {\n        key: \"raiseNoAltException\",\n        value: function raiseNoAltException(occurrence, errMsgTypes) {\n          var ruleName = this.getCurrRuleFullName();\n          var ruleGrammar = this.getGAstProductions()[ruleName];\n          var lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n          var actualTokens = [];\n          for (var _i17 = 1; _i17 <= this.maxLookahead; _i17++) {\n            actualTokens.push(this.LA(_i17));\n          }\n          var previousToken = this.LA(0);\n          var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n          });\n          throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n        }\n      }]);\n      return ErrorHandler;\n    }();\n    var ContentAssist = /*#__PURE__*/function () {\n      function ContentAssist() {\n        _classCallCheck(this, ContentAssist);\n      }\n      _createClass(ContentAssist, [{\n        key: \"initContentAssist\",\n        value: function initContentAssist() {}\n      }, {\n        key: \"computeContentAssist\",\n        value: function computeContentAssist(startRuleName, precedingInput) {\n          var startRuleGast = this.gastProductionsCache[startRuleName];\n          if (isUndefined(startRuleGast)) {\n            throw Error(\"Rule ->\".concat(startRuleName, \"<- does not exist in this grammar.\"));\n          }\n          return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n        }\n        // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n        // TODO: should this be more explicitly part of the public API?\n      }, {\n        key: \"getNextPossibleTokenTypes\",\n        value: function getNextPossibleTokenTypes(grammarPath) {\n          var topRuleName = head(grammarPath.ruleStack);\n          var gastProductions = this.getGAstProductions();\n          var topProduction = gastProductions[topRuleName];\n          var nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n          return nextPossibleTokenTypes;\n        }\n      }]);\n      return ContentAssist;\n    }();\n    var RECORDING_NULL_OBJECT = {\n      description: \"This Object indicates the Parser is during Recording Phase\"\n    };\n    Object.freeze(RECORDING_NULL_OBJECT);\n    var HANDLE_SEPARATOR = true;\n    var MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\n    var RFT = createToken2({\n      name: \"RECORDING_PHASE_TOKEN\",\n      pattern: Lexer2.NA\n    });\n    augmentTokenTypes([RFT]);\n    var RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n    // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n    -1, -1, -1, -1, -1, -1);\n    Object.freeze(RECORDING_PHASE_TOKEN);\n    var RECORDING_PHASE_CSTNODE = {\n      name: \"This CSTNode indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n      children: {}\n    };\n    var GastRecorder = /*#__PURE__*/function () {\n      function GastRecorder() {\n        _classCallCheck(this, GastRecorder);\n      }\n      _createClass(GastRecorder, [{\n        key: \"initGastRecorder\",\n        value: function initGastRecorder(config) {\n          this.recordingProdStack = [];\n          this.RECORDING_PHASE = false;\n        }\n      }, {\n        key: \"enableRecording\",\n        value: function enableRecording() {\n          var _this48 = this;\n          this.RECORDING_PHASE = true;\n          this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop2 = function _loop2(_i18) {\n              var idx = _i18 > 0 ? _i18 : \"\";\n              _this48[\"CONSUME\".concat(idx)] = function (arg1, arg2) {\n                return this.consumeInternalRecord(arg1, _i18, arg2);\n              };\n              _this48[\"SUBRULE\".concat(idx)] = function (arg1, arg2) {\n                return this.subruleInternalRecord(arg1, _i18, arg2);\n              };\n              _this48[\"OPTION\".concat(idx)] = function (arg1) {\n                return this.optionInternalRecord(arg1, _i18);\n              };\n              _this48[\"OR\".concat(idx)] = function (arg1) {\n                return this.orInternalRecord(arg1, _i18);\n              };\n              _this48[\"MANY\".concat(idx)] = function (arg1) {\n                this.manyInternalRecord(_i18, arg1);\n              };\n              _this48[\"MANY_SEP\".concat(idx)] = function (arg1) {\n                this.manySepFirstInternalRecord(_i18, arg1);\n              };\n              _this48[\"AT_LEAST_ONE\".concat(idx)] = function (arg1) {\n                this.atLeastOneInternalRecord(_i18, arg1);\n              };\n              _this48[\"AT_LEAST_ONE_SEP\".concat(idx)] = function (arg1) {\n                this.atLeastOneSepFirstInternalRecord(_i18, arg1);\n              };\n            };\n            for (var _i18 = 0; _i18 < 10; _i18++) {\n              _loop2(_i18);\n            }\n            _this48[\"consume\"] = function (idx, arg1, arg2) {\n              return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this48[\"subrule\"] = function (idx, arg1, arg2) {\n              return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this48[\"option\"] = function (idx, arg1) {\n              return this.optionInternalRecord(arg1, idx);\n            };\n            _this48[\"or\"] = function (idx, arg1) {\n              return this.orInternalRecord(arg1, idx);\n            };\n            _this48[\"many\"] = function (idx, arg1) {\n              this.manyInternalRecord(idx, arg1);\n            };\n            _this48[\"atLeastOne\"] = function (idx, arg1) {\n              this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this48.ACTION = _this48.ACTION_RECORD;\n            _this48.BACKTRACK = _this48.BACKTRACK_RECORD;\n            _this48.LA = _this48.LA_RECORD;\n          });\n        }\n      }, {\n        key: \"disableRecording\",\n        value: function disableRecording() {\n          var _this49 = this;\n          this.RECORDING_PHASE = false;\n          this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            var that = _this49;\n            for (var _i19 = 0; _i19 < 10; _i19++) {\n              var idx = _i19 > 0 ? _i19 : \"\";\n              delete that[\"CONSUME\".concat(idx)];\n              delete that[\"SUBRULE\".concat(idx)];\n              delete that[\"OPTION\".concat(idx)];\n              delete that[\"OR\".concat(idx)];\n              delete that[\"MANY\".concat(idx)];\n              delete that[\"MANY_SEP\".concat(idx)];\n              delete that[\"AT_LEAST_ONE\".concat(idx)];\n              delete that[\"AT_LEAST_ONE_SEP\".concat(idx)];\n            }\n            delete that[\"consume\"];\n            delete that[\"subrule\"];\n            delete that[\"option\"];\n            delete that[\"or\"];\n            delete that[\"many\"];\n            delete that[\"atLeastOne\"];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n          });\n        }\n        //   Parser methods are called inside an ACTION?\n        //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n        // @ts-expect-error -- noop place holder\n      }, {\n        key: \"ACTION_RECORD\",\n        value: function ACTION_RECORD(impl) {}\n        // Executing backtracking logic will break our recording logic assumptions\n      }, {\n        key: \"BACKTRACK_RECORD\",\n        value: function BACKTRACK_RECORD(grammarRule, args) {\n          return function () {\n            return true;\n          };\n        }\n        // LA is part of the official API and may be used for custom lookahead logic\n        // by end users who may forget to wrap it in ACTION or inside a GATE\n      }, {\n        key: \"LA_RECORD\",\n        value: function LA_RECORD(howMuch) {\n          return END_OF_FILE;\n        }\n      }, {\n        key: \"topLevelRuleRecord\",\n        value: function topLevelRuleRecord(name, def) {\n          try {\n            var newTopLevelRule = new Rule({\n              definition: [],\n              name: name\n            });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n          } catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n              try {\n                originalError.message = originalError.message + '\\n\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\thttps://chevrotain.io/docs/guide/internals.html#grammar-recording';\n              } catch (mutabilityError) {\n                throw originalError;\n              }\n            }\n            throw originalError;\n          }\n        }\n        // Implementation of parsing DSL\n      }, {\n        key: \"optionInternalRecord\",\n        value: function optionInternalRecord(actionORMethodDef, occurrence) {\n          return recordProd.call(this, Option, actionORMethodDef, occurrence);\n        }\n      }, {\n        key: \"atLeastOneInternalRecord\",\n        value: function atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n          recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n        }\n      }, {\n        key: \"atLeastOneSepFirstInternalRecord\",\n        value: function atLeastOneSepFirstInternalRecord(occurrence, options) {\n          recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n        }\n      }, {\n        key: \"manyInternalRecord\",\n        value: function manyInternalRecord(occurrence, actionORMethodDef) {\n          recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n        }\n      }, {\n        key: \"manySepFirstInternalRecord\",\n        value: function manySepFirstInternalRecord(occurrence, options) {\n          recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n        }\n      }, {\n        key: \"orInternalRecord\",\n        value: function orInternalRecord(altsOrOpts, occurrence) {\n          return recordOrProd.call(this, altsOrOpts, occurrence);\n        }\n      }, {\n        key: \"subruleInternalRecord\",\n        value: function subruleInternalRecord(ruleToCall, occurrence, options) {\n          assertMethodIdxIsValid(occurrence);\n          if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\".concat(getIdxSuffix(occurrence), \"> argument is invalid expecting a Parser method reference but got: <\").concat(JSON.stringify(ruleToCall), \">\\n inside top level rule: <\").concat(this.recordingProdStack[0].name, \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n          }\n          var prevProd = last(this.recordingProdStack);\n          var ruleName = ruleToCall.ruleName;\n          var newNoneTerminal = new NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: void 0\n          });\n          prevProd.definition.push(newNoneTerminal);\n          return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n        }\n      }, {\n        key: \"consumeInternalRecord\",\n        value: function consumeInternalRecord(tokType, occurrence, options) {\n          assertMethodIdxIsValid(occurrence);\n          if (!hasShortKeyProperty(tokType)) {\n            var error = new Error(\"<CONSUME\".concat(getIdxSuffix(occurrence), \"> argument is invalid expecting a TokenType reference but got: <\").concat(JSON.stringify(tokType), \">\\n inside top level rule: <\").concat(this.recordingProdStack[0].name, \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n          }\n          var prevProd = last(this.recordingProdStack);\n          var newNoneTerminal = new Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL\n          });\n          prevProd.definition.push(newNoneTerminal);\n          return RECORDING_PHASE_TOKEN;\n        }\n      }]);\n      return GastRecorder;\n    }();\n    function recordProd(prodConstructor, mainProdArg, occurrence) {\n      var handleSep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      assertMethodIdxIsValid(occurrence);\n      var prevProd = last(this.recordingProdStack);\n      var grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n      var newProd = new prodConstructor({\n        definition: [],\n        idx: occurrence\n      });\n      if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n      }\n      if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n      }\n      this.recordingProdStack.push(newProd);\n      grammarAction.call(this);\n      prevProd.definition.push(newProd);\n      this.recordingProdStack.pop();\n      return RECORDING_NULL_OBJECT;\n    }\n    function recordOrProd(mainProdArg, occurrence) {\n      var _this50 = this;\n      assertMethodIdxIsValid(occurrence);\n      var prevProd = last(this.recordingProdStack);\n      var hasOptions = isArray$1(mainProdArg) === false;\n      var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n      var newOrProd = new Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n      });\n      if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n      }\n      var hasPredicates = some(alts, function (currAlt) {\n        return isFunction(currAlt.GATE);\n      });\n      newOrProd.hasPredicates = hasPredicates;\n      prevProd.definition.push(newOrProd);\n      forEach(alts, function (currAlt) {\n        var currAltFlat = new Alternative({\n          definition: []\n        });\n        newOrProd.definition.push(currAltFlat);\n        if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n          currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n        } else if (has(currAlt, \"GATE\")) {\n          currAltFlat.ignoreAmbiguities = true;\n        }\n        _this50.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this50);\n        _this50.recordingProdStack.pop();\n      });\n      return RECORDING_NULL_OBJECT;\n    }\n    function getIdxSuffix(idx) {\n      return idx === 0 ? \"\" : \"\".concat(idx);\n    }\n    function assertMethodIdxIsValid(idx) {\n      if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error( // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\".concat(idx, \">\\n\\tIdx value must be a none negative value smaller than \").concat(MAX_METHOD_IDX + 1));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n      }\n    }\n    var PerformanceTracer = /*#__PURE__*/function () {\n      function PerformanceTracer() {\n        _classCallCheck(this, PerformanceTracer);\n      }\n      _createClass(PerformanceTracer, [{\n        key: \"initPerformanceTracer\",\n        value: function initPerformanceTracer(config) {\n          if (has(config, \"traceInitPerf\")) {\n            var userTraceInitPerf = config.traceInitPerf;\n            var traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;\n            this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;\n          } else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n          }\n          this.traceInitIndent = -1;\n        }\n      }, {\n        key: \"TRACE_INIT\",\n        value: function TRACE_INIT(phaseDesc, phaseImpl) {\n          if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n              console.log(\"\".concat(indent, \"--> <\").concat(phaseDesc, \">\"));\n            }\n            var _timer2 = timer(phaseImpl),\n              time = _timer2.time,\n              value = _timer2.value;\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n              traceMethod(\"\".concat(indent, \"<-- <\").concat(phaseDesc, \"> time: \").concat(time, \"ms\"));\n            }\n            this.traceInitIndent--;\n            return value;\n          } else {\n            return phaseImpl();\n          }\n        }\n      }]);\n      return PerformanceTracer;\n    }();\n    function applyMixins(derivedCtor, baseCtors) {\n      baseCtors.forEach(function (baseCtor) {\n        var baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach(function (propName) {\n          if (propName === \"constructor\") {\n            return;\n          }\n          var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n          if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {\n            Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n          } else {\n            derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n          }\n        });\n      });\n    }\n    var END_OF_FILE = createTokenInstance(EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    Object.freeze(END_OF_FILE);\n    var DEFAULT_PARSER_CONFIG = Object.freeze({\n      recoveryEnabled: false,\n      maxLookahead: 3,\n      dynamicTokensEnabled: false,\n      outputCst: true,\n      errorMessageProvider: defaultParserErrorProvider,\n      nodeLocationTracking: \"none\",\n      traceInitPerf: false,\n      skipValidations: false\n    });\n    var DEFAULT_RULE_CONFIG = Object.freeze({\n      recoveryValueFunc: function recoveryValueFunc() {\n        return void 0;\n      },\n      resyncEnabled: true\n    });\n    var ParserDefinitionErrorType;\n    (function (ParserDefinitionErrorType2) {\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n    })(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\n    var Parser = /*#__PURE__*/function () {\n      function Parser(tokenVocabulary, config) {\n        _classCallCheck(this, Parser);\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        var that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if (has(config, \"ignoredIssues\")) {\n          throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\tPlease use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\tSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\tFor further details.\");\n        }\n        this.skipValidations = has(config, \"skipValidations\") ? config.skipValidations : DEFAULT_PARSER_CONFIG.skipValidations;\n      }\n      _createClass(Parser, [{\n        key: \"performSelfAnalysis\",\n        value: function performSelfAnalysis() {\n          var _this51 = this;\n          this.TRACE_INIT(\"performSelfAnalysis\", function () {\n            var defErrorsMsgs;\n            _this51.selfAnalysisDone = true;\n            var className = _this51.className;\n            _this51.TRACE_INIT(\"toFastProps\", function () {\n              toFastProperties(_this51);\n            });\n            _this51.TRACE_INIT(\"Grammar Recording\", function () {\n              try {\n                _this51.enableRecording();\n                forEach(_this51.definedRulesNames, function (currRuleName) {\n                  var wrappedRule = _this51[currRuleName];\n                  var originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                  var recordedRuleGast;\n                  _this51.TRACE_INIT(\"\".concat(currRuleName, \" Rule\"), function () {\n                    recordedRuleGast = _this51.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                  });\n                  _this51.gastProductionsCache[currRuleName] = recordedRuleGast;\n                });\n              } finally {\n                _this51.disableRecording();\n              }\n            });\n            var resolverErrors = [];\n            _this51.TRACE_INIT(\"Grammar Resolving\", function () {\n              resolverErrors = resolveGrammar({\n                rules: values(_this51.gastProductionsCache)\n              });\n              _this51.definitionErrors = _this51.definitionErrors.concat(resolverErrors);\n            });\n            _this51.TRACE_INIT(\"Grammar Validations\", function () {\n              if (isEmpty(resolverErrors) && _this51.skipValidations === false) {\n                var validationErrors = validateGrammar({\n                  rules: values(_this51.gastProductionsCache),\n                  tokenTypes: values(_this51.tokensMap),\n                  errMsgProvider: defaultGrammarValidatorErrorProvider,\n                  grammarName: className\n                });\n                var lookaheadValidationErrors = validateLookahead({\n                  lookaheadStrategy: _this51.lookaheadStrategy,\n                  rules: values(_this51.gastProductionsCache),\n                  tokenTypes: values(_this51.tokensMap),\n                  grammarName: className\n                });\n                _this51.definitionErrors = _this51.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n              }\n            });\n            if (isEmpty(_this51.definitionErrors)) {\n              if (_this51.recoveryEnabled) {\n                _this51.TRACE_INIT(\"computeAllProdsFollows\", function () {\n                  var allFollows = computeAllProdsFollows(values(_this51.gastProductionsCache));\n                  _this51.resyncFollows = allFollows;\n                });\n              }\n              _this51.TRACE_INIT(\"ComputeLookaheadFunctions\", function () {\n                var _a, _b;\n                (_b = (_a = _this51.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                  rules: values(_this51.gastProductionsCache)\n                });\n                _this51.preComputeLookaheadFunctions(values(_this51.gastProductionsCache));\n              });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty(_this51.definitionErrors)) {\n              defErrorsMsgs = map(_this51.definitionErrors, function (defError) {\n                return defError.message;\n              });\n              throw new Error(\"Parser Definition Errors detected:\\n \".concat(defErrorsMsgs.join(\"\\n-------------------------------\\n\")));\n            }\n          });\n        }\n      }], [{\n        key: \"performSelfAnalysis\",\n        value:\n        /**\n         *  @deprecated use the **instance** method with the same name instead\n         */\n        function performSelfAnalysis(parserInstance) {\n          throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\t\\nUse the **instance** method with the same name instead.\");\n        }\n      }]);\n      return Parser;\n    }();\n    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;\n    applyMixins(Parser, [Recoverable, LooksAhead, TreeBuilder, LexerAdapter, RecognizerEngine, RecognizerApi, ErrorHandler, ContentAssist, GastRecorder, PerformanceTracer]);\n    var CstParser2 = /*#__PURE__*/function (_Parser) {\n      _inherits(CstParser2, _Parser);\n      var _super34 = _createSuper(CstParser2);\n      function CstParser2(tokenVocabulary) {\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_PARSER_CONFIG;\n        _classCallCheck(this, CstParser2);\n        var configClone = clone(config);\n        configClone.outputCst = true;\n        return _super34.call(this, tokenVocabulary, configClone);\n      }\n      return _createClass(CstParser2);\n    }(Parser);\n    return {\n      CstParser: CstParser2,\n      Lexer: Lexer2,\n      createToken: createToken2\n    };\n  }(),\n  CstParser = _ref.CstParser,\n  Lexer = _ref.Lexer,\n  createToken = _ref.createToken;\nexport { CstParser, Lexer, createToken };\n//# sourceMappingURL=chevrotain.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}