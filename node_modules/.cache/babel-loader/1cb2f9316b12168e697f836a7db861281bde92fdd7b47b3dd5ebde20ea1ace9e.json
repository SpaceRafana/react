{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, Skeleton, Vector3, Quaternion, Bone, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip } from \"three\";\nvar BVHLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(BVHLoader, _Loader);\n  var _super = _createSuper(BVHLoader);\n  function BVHLoader(manager) {\n    var _this;\n    _classCallCheck(this, BVHLoader);\n    _this = _super.call(this, manager);\n    _this.animateBonePositions = true;\n    _this.animateBoneRotations = true;\n    return _this;\n  }\n  _createClass(BVHLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      function readBvh(lines2) {\n        if (nextLine(lines2) !== \"HIERARCHY\") {\n          console.error(\"THREE.BVHLoader: HIERARCHY expected.\");\n        }\n        var list = [];\n        var root = readNode(lines2, nextLine(lines2), list);\n        if (nextLine(lines2) !== \"MOTION\") {\n          console.error(\"THREE.BVHLoader: MOTION expected.\");\n        }\n        var tokens = nextLine(lines2).split(/[\\s]+/);\n        var numFrames = parseInt(tokens[1]);\n        if (isNaN(numFrames)) {\n          console.error(\"THREE.BVHLoader: Failed to read number of frames.\");\n        }\n        tokens = nextLine(lines2).split(/[\\s]+/);\n        var frameTime = parseFloat(tokens[2]);\n        if (isNaN(frameTime)) {\n          console.error(\"THREE.BVHLoader: Failed to read frame time.\");\n        }\n        for (var i = 0; i < numFrames; i++) {\n          tokens = nextLine(lines2).split(/[\\s]+/);\n          readFrameData(tokens, i * frameTime, root);\n        }\n        return list;\n      }\n      function readFrameData(data, frameTime, bone) {\n        if (bone.type === \"ENDSITE\") return;\n        var keyframe = {\n          time: frameTime,\n          position: new Vector3(),\n          rotation: new Quaternion()\n        };\n        bone.frames.push(keyframe);\n        var quat = new Quaternion();\n        var vx = new Vector3(1, 0, 0);\n        var vy = new Vector3(0, 1, 0);\n        var vz = new Vector3(0, 0, 1);\n        for (var i = 0; i < bone.channels.length; i++) {\n          switch (bone.channels[i]) {\n            case \"Xposition\":\n              keyframe.position.x = parseFloat(data.shift().trim());\n              break;\n            case \"Yposition\":\n              keyframe.position.y = parseFloat(data.shift().trim());\n              break;\n            case \"Zposition\":\n              keyframe.position.z = parseFloat(data.shift().trim());\n              break;\n            case \"Xrotation\":\n              quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n              keyframe.rotation.multiply(quat);\n              break;\n            case \"Yrotation\":\n              quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n              keyframe.rotation.multiply(quat);\n              break;\n            case \"Zrotation\":\n              quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n              keyframe.rotation.multiply(quat);\n              break;\n            default:\n              console.warn(\"THREE.BVHLoader: Invalid channel type.\");\n          }\n        }\n        for (var _i = 0; _i < bone.children.length; _i++) {\n          readFrameData(data, frameTime, bone.children[_i]);\n        }\n      }\n      function readNode(lines2, firstline, list) {\n        var node = {\n          name: \"\",\n          type: \"\",\n          frames: []\n        };\n        list.push(node);\n        var tokens = firstline.split(/[\\s]+/);\n        if (tokens[0].toUpperCase() === \"END\" && tokens[1].toUpperCase() === \"SITE\") {\n          node.type = \"ENDSITE\";\n          node.name = \"ENDSITE\";\n        } else {\n          node.name = tokens[1];\n          node.type = tokens[0].toUpperCase();\n        }\n        if (nextLine(lines2) !== \"{\") {\n          console.error(\"THREE.BVHLoader: Expected opening { after type & name\");\n        }\n        tokens = nextLine(lines2).split(/[\\s]+/);\n        if (tokens[0] !== \"OFFSET\") {\n          console.error(\"THREE.BVHLoader: Expected OFFSET but got: \" + tokens[0]);\n        }\n        if (tokens.length !== 4) {\n          console.error(\"THREE.BVHLoader: Invalid number of values for OFFSET.\");\n        }\n        var offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n        if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n          console.error(\"THREE.BVHLoader: Invalid values of OFFSET.\");\n        }\n        node.offset = offset;\n        if (node.type !== \"ENDSITE\") {\n          tokens = nextLine(lines2).split(/[\\s]+/);\n          if (tokens[0] !== \"CHANNELS\") {\n            console.error(\"THREE.BVHLoader: Expected CHANNELS definition.\");\n          }\n          var numChannels = parseInt(tokens[1]);\n          node.channels = tokens.splice(2, numChannels);\n          node.children = [];\n        }\n        while (true) {\n          var line = nextLine(lines2);\n          if (line === \"}\") {\n            return node;\n          } else {\n            node.children.push(readNode(lines2, line, list));\n          }\n        }\n      }\n      function toTHREEBone(source, list) {\n        var bone = new Bone();\n        list.push(bone);\n        bone.position.add(source.offset);\n        bone.name = source.name;\n        if (source.type !== \"ENDSITE\") {\n          for (var i = 0; i < source.children.length; i++) {\n            bone.add(toTHREEBone(source.children[i], list));\n          }\n        }\n        return bone;\n      }\n      function toTHREEAnimation(bones2) {\n        var tracks = [];\n        for (var i = 0; i < bones2.length; i++) {\n          var bone = bones2[i];\n          if (bone.type === \"ENDSITE\") continue;\n          var times = [];\n          var positions = [];\n          var rotations = [];\n          for (var j = 0; j < bone.frames.length; j++) {\n            var frame = bone.frames[j];\n            times.push(frame.time);\n            positions.push(frame.position.x + bone.offset.x);\n            positions.push(frame.position.y + bone.offset.y);\n            positions.push(frame.position.z + bone.offset.z);\n            rotations.push(frame.rotation.x);\n            rotations.push(frame.rotation.y);\n            rotations.push(frame.rotation.z);\n            rotations.push(frame.rotation.w);\n          }\n          if (scope.animateBonePositions) {\n            tracks.push(new VectorKeyframeTrack(\".bones[\" + bone.name + \"].position\", times, positions));\n          }\n          if (scope.animateBoneRotations) {\n            tracks.push(new QuaternionKeyframeTrack(\".bones[\" + bone.name + \"].quaternion\", times, rotations));\n          }\n        }\n        return new AnimationClip(\"animation\", -1, tracks);\n      }\n      function nextLine(lines2) {\n        var line;\n        while ((line = lines2.shift().trim()).length === 0) {}\n        return line;\n      }\n      var scope = this;\n      var lines = text.split(/[\\r\\n]+/g);\n      var bones = readBvh(lines);\n      var threeBones = [];\n      toTHREEBone(bones[0], threeBones);\n      var threeClip = toTHREEAnimation(bones);\n      return {\n        skeleton: new Skeleton(threeBones),\n        clip: threeClip\n      };\n    }\n  }]);\n  return BVHLoader;\n}(Loader);\nexport { BVHLoader };\n//# sourceMappingURL=BVHLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}