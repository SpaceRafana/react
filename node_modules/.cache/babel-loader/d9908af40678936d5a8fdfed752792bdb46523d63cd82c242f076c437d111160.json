{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, LoaderUtils, FileLoader, Group, MeshPhongMaterial, DoubleSide, AdditiveBlending, BufferGeometry, Mesh, Float32BufferAttribute, Matrix4, TextureLoader, Color } from \"three\";\nvar TDSLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(TDSLoader, _Loader);\n  var _super = _createSuper(TDSLoader);\n  function TDSLoader(manager) {\n    var _this;\n    _classCallCheck(this, TDSLoader);\n    _this = _super.call(this, manager);\n    _this.debug = false;\n    _this.group = null;\n    _this.position = 0;\n    _this.materials = [];\n    _this.meshes = [];\n    return _this;\n  }\n  /**\n   * Load 3ds file from url.\n   *\n   * @method load\n   * @param {[type]} url URL for the file.\n   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n   * @param {Function} onProgress onProgress callback.\n   * @param {Function} onError onError callback.\n   */\n  _createClass(TDSLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          onLoad(scope.parse(data, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n    /**\n     * Parse arraybuffer data and load 3ds file.\n     *\n     * @method parse\n     * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n     * @param {String} path Path for external resources.\n     * @return {Group} Group loaded from 3ds file.\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(arraybuffer, path) {\n      this.group = new Group();\n      this.position = 0;\n      this.materials = [];\n      this.meshes = [];\n      this.readFile(arraybuffer, path);\n      for (var i = 0; i < this.meshes.length; i++) {\n        this.group.add(this.meshes[i]);\n      }\n      return this.group;\n    }\n    /**\n     * Decode file content to read 3ds data.\n     *\n     * @method readFile\n     * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n     * @param {String} path Path for external resources.\n     */\n  }, {\n    key: \"readFile\",\n    value: function readFile(arraybuffer, path) {\n      var data = new DataView(arraybuffer);\n      var chunk = this.readChunk(data);\n      if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n        var next = this.nextChunk(data, chunk);\n        while (next !== 0) {\n          if (next === M3D_VERSION) {\n            var version = this.readDWord(data);\n            this.debugMessage(\"3DS file version: \" + version);\n          } else if (next === MDATA) {\n            this.resetPosition(data);\n            this.readMeshData(data, path);\n          } else {\n            this.debugMessage(\"Unknown main chunk: \" + next.toString(16));\n          }\n          next = this.nextChunk(data, chunk);\n        }\n      }\n      this.debugMessage(\"Parsed \" + this.meshes.length + \" meshes\");\n    }\n    /**\n     * Read mesh data chunk.\n     *\n     * @method readMeshData\n     * @param {Dataview} data Dataview in use.\n     * @param {String} path Path for external resources.\n     */\n  }, {\n    key: \"readMeshData\",\n    value: function readMeshData(data, path) {\n      var chunk = this.readChunk(data);\n      var next = this.nextChunk(data, chunk);\n      while (next !== 0) {\n        if (next === MESH_VERSION) {\n          var version = +this.readDWord(data);\n          this.debugMessage(\"Mesh Version: \" + version);\n        } else if (next === MASTER_SCALE) {\n          var scale = this.readFloat(data);\n          this.debugMessage(\"Master scale: \" + scale);\n          this.group.scale.set(scale, scale, scale);\n        } else if (next === NAMED_OBJECT) {\n          this.debugMessage(\"Named Object\");\n          this.resetPosition(data);\n          this.readNamedObject(data);\n        } else if (next === MAT_ENTRY) {\n          this.debugMessage(\"Material\");\n          this.resetPosition(data);\n          this.readMaterialEntry(data, path);\n        } else {\n          this.debugMessage(\"Unknown MDATA chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n    }\n    /**\n     * Read named object chunk.\n     *\n     * @method readNamedObject\n     * @param {Dataview} data Dataview in use.\n     */\n  }, {\n    key: \"readNamedObject\",\n    value: function readNamedObject(data) {\n      var chunk = this.readChunk(data);\n      var name = this.readString(data, 64);\n      chunk.cur = this.position;\n      var next = this.nextChunk(data, chunk);\n      while (next !== 0) {\n        if (next === N_TRI_OBJECT) {\n          this.resetPosition(data);\n          var mesh = this.readMesh(data);\n          mesh.name = name;\n          this.meshes.push(mesh);\n        } else {\n          this.debugMessage(\"Unknown named object chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n      this.endChunk(chunk);\n    }\n    /**\n     * Read material data chunk and add it to the material list.\n     *\n     * @method readMaterialEntry\n     * @param {Dataview} data Dataview in use.\n     * @param {String} path Path for external resources.\n     */\n  }, {\n    key: \"readMaterialEntry\",\n    value: function readMaterialEntry(data, path) {\n      var chunk = this.readChunk(data);\n      var next = this.nextChunk(data, chunk);\n      var material = new MeshPhongMaterial();\n      while (next !== 0) {\n        if (next === MAT_NAME) {\n          material.name = this.readString(data, 64);\n          this.debugMessage(\"   Name: \" + material.name);\n        } else if (next === MAT_WIRE) {\n          this.debugMessage(\"   Wireframe\");\n          material.wireframe = true;\n        } else if (next === MAT_WIRE_SIZE) {\n          var value = this.readByte(data);\n          material.wireframeLinewidth = value;\n          this.debugMessage(\"   Wireframe Thickness: \" + value);\n        } else if (next === MAT_TWO_SIDE) {\n          material.side = DoubleSide;\n          this.debugMessage(\"   DoubleSided\");\n        } else if (next === MAT_ADDITIVE) {\n          this.debugMessage(\"   Additive Blending\");\n          material.blending = AdditiveBlending;\n        } else if (next === MAT_DIFFUSE) {\n          this.debugMessage(\"   Diffuse Color\");\n          material.color = this.readColor(data);\n        } else if (next === MAT_SPECULAR) {\n          this.debugMessage(\"   Specular Color\");\n          material.specular = this.readColor(data);\n        } else if (next === MAT_AMBIENT) {\n          this.debugMessage(\"   Ambient color\");\n          material.color = this.readColor(data);\n        } else if (next === MAT_SHININESS) {\n          var shininess = this.readPercentage(data);\n          material.shininess = shininess * 100;\n          this.debugMessage(\"   Shininess : \" + shininess);\n        } else if (next === MAT_TRANSPARENCY) {\n          var transparency = this.readPercentage(data);\n          material.opacity = 1 - transparency;\n          this.debugMessage(\"  Transparency : \" + transparency);\n          material.transparent = material.opacity < 1 ? true : false;\n        } else if (next === MAT_TEXMAP) {\n          this.debugMessage(\"   ColorMap\");\n          this.resetPosition(data);\n          material.map = this.readMap(data, path);\n        } else if (next === MAT_BUMPMAP) {\n          this.debugMessage(\"   BumpMap\");\n          this.resetPosition(data);\n          material.bumpMap = this.readMap(data, path);\n        } else if (next === MAT_OPACMAP) {\n          this.debugMessage(\"   OpacityMap\");\n          this.resetPosition(data);\n          material.alphaMap = this.readMap(data, path);\n        } else if (next === MAT_SPECMAP) {\n          this.debugMessage(\"   SpecularMap\");\n          this.resetPosition(data);\n          material.specularMap = this.readMap(data, path);\n        } else {\n          this.debugMessage(\"   Unknown material chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n      this.endChunk(chunk);\n      this.materials[material.name] = material;\n    }\n    /**\n     * Read mesh data chunk.\n     *\n     * @method readMesh\n     * @param {Dataview} data Dataview in use.\n     * @return {Mesh} The parsed mesh.\n     */\n  }, {\n    key: \"readMesh\",\n    value: function readMesh(data) {\n      var chunk = this.readChunk(data);\n      var next = this.nextChunk(data, chunk);\n      var geometry = new BufferGeometry();\n      var material = new MeshPhongMaterial();\n      var mesh = new Mesh(geometry, material);\n      mesh.name = \"mesh\";\n      while (next !== 0) {\n        if (next === POINT_ARRAY) {\n          var points = this.readWord(data);\n          this.debugMessage(\"   Vertex: \" + points);\n          var vertices = [];\n          for (var i = 0; i < points; i++) {\n            vertices.push(this.readFloat(data));\n            vertices.push(this.readFloat(data));\n            vertices.push(this.readFloat(data));\n          }\n          geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n        } else if (next === FACE_ARRAY) {\n          this.resetPosition(data);\n          this.readFaceArray(data, mesh);\n        } else if (next === TEX_VERTS) {\n          var texels = this.readWord(data);\n          this.debugMessage(\"   UV: \" + texels);\n          var uvs = [];\n          for (var _i = 0; _i < texels; _i++) {\n            uvs.push(this.readFloat(data));\n            uvs.push(this.readFloat(data));\n          }\n          geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n        } else if (next === MESH_MATRIX) {\n          this.debugMessage(\"   Tranformation Matrix (TODO)\");\n          var values = [];\n          for (var _i2 = 0; _i2 < 12; _i2++) {\n            values[_i2] = this.readFloat(data);\n          }\n          var matrix = new Matrix4();\n          matrix.elements[0] = values[0];\n          matrix.elements[1] = values[6];\n          matrix.elements[2] = values[3];\n          matrix.elements[3] = values[9];\n          matrix.elements[4] = values[2];\n          matrix.elements[5] = values[8];\n          matrix.elements[6] = values[5];\n          matrix.elements[7] = values[11];\n          matrix.elements[8] = values[1];\n          matrix.elements[9] = values[7];\n          matrix.elements[10] = values[4];\n          matrix.elements[11] = values[10];\n          matrix.elements[12] = 0;\n          matrix.elements[13] = 0;\n          matrix.elements[14] = 0;\n          matrix.elements[15] = 1;\n          matrix.transpose();\n          var inverse = new Matrix4();\n          inverse.copy(matrix).invert();\n          geometry.applyMatrix4(inverse);\n          matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n        } else {\n          this.debugMessage(\"   Unknown mesh chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n      this.endChunk(chunk);\n      geometry.computeVertexNormals();\n      return mesh;\n    }\n    /**\n     * Read face array data chunk.\n     *\n     * @method readFaceArray\n     * @param {Dataview} data Dataview in use.\n     * @param {Mesh} mesh Mesh to be filled with the data read.\n     */\n  }, {\n    key: \"readFaceArray\",\n    value: function readFaceArray(data, mesh) {\n      var chunk = this.readChunk(data);\n      var faces = this.readWord(data);\n      this.debugMessage(\"   Faces: \" + faces);\n      var index = [];\n      for (var i = 0; i < faces; ++i) {\n        index.push(this.readWord(data), this.readWord(data), this.readWord(data));\n        this.readWord(data);\n      }\n      mesh.geometry.setIndex(index);\n      var materialIndex = 0;\n      var start = 0;\n      while (this.position < chunk.end) {\n        var subchunk = this.readChunk(data);\n        if (subchunk.id === MSH_MAT_GROUP) {\n          this.debugMessage(\"      Material Group\");\n          this.resetPosition(data);\n          var group = this.readMaterialGroup(data);\n          var count = group.index.length * 3;\n          mesh.geometry.addGroup(start, count, materialIndex);\n          start += count;\n          materialIndex++;\n          var material = this.materials[group.name];\n          if (Array.isArray(mesh.material) === false) mesh.material = [];\n          if (material !== void 0) {\n            mesh.material.push(material);\n          }\n        } else {\n          this.debugMessage(\"      Unknown face array chunk: \" + subchunk.toString(16));\n        }\n        this.endChunk(subchunk);\n      }\n      if (mesh.material.length === 1) mesh.material = mesh.material[0];\n      this.endChunk(chunk);\n    }\n    /**\n     * Read texture map data chunk.\n     *\n     * @method readMap\n     * @param {Dataview} data Dataview in use.\n     * @param {String} path Path for external resources.\n     * @return {Texture} Texture read from this data chunk.\n     */\n  }, {\n    key: \"readMap\",\n    value: function readMap(data, path) {\n      var chunk = this.readChunk(data);\n      var next = this.nextChunk(data, chunk);\n      var texture = {};\n      var loader = new TextureLoader(this.manager);\n      loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      while (next !== 0) {\n        if (next === MAT_MAPNAME) {\n          var name = this.readString(data, 128);\n          texture = loader.load(name);\n          this.debugMessage(\"      File: \" + path + name);\n        } else if (next === MAT_MAP_UOFFSET) {\n          texture.offset.x = this.readFloat(data);\n          this.debugMessage(\"      OffsetX: \" + texture.offset.x);\n        } else if (next === MAT_MAP_VOFFSET) {\n          texture.offset.y = this.readFloat(data);\n          this.debugMessage(\"      OffsetY: \" + texture.offset.y);\n        } else if (next === MAT_MAP_USCALE) {\n          texture.repeat.x = this.readFloat(data);\n          this.debugMessage(\"      RepeatX: \" + texture.repeat.x);\n        } else if (next === MAT_MAP_VSCALE) {\n          texture.repeat.y = this.readFloat(data);\n          this.debugMessage(\"      RepeatY: \" + texture.repeat.y);\n        } else {\n          this.debugMessage(\"      Unknown map chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n      this.endChunk(chunk);\n      return texture;\n    }\n    /**\n     * Read material group data chunk.\n     *\n     * @method readMaterialGroup\n     * @param {Dataview} data Dataview in use.\n     * @return {Object} Object with name and index of the object.\n     */\n  }, {\n    key: \"readMaterialGroup\",\n    value: function readMaterialGroup(data) {\n      this.readChunk(data);\n      var name = this.readString(data, 64);\n      var numFaces = this.readWord(data);\n      this.debugMessage(\"         Name: \" + name);\n      this.debugMessage(\"         Faces: \" + numFaces);\n      var index = [];\n      for (var i = 0; i < numFaces; ++i) {\n        index.push(this.readWord(data));\n      }\n      return {\n        name: name,\n        index: index\n      };\n    }\n    /**\n     * Read a color value.\n     *\n     * @method readColor\n     * @param {DataView} data Dataview.\n     * @return {Color} Color value read..\n     */\n  }, {\n    key: \"readColor\",\n    value: function readColor(data) {\n      var chunk = this.readChunk(data);\n      var color = new Color();\n      if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n        var r = this.readByte(data);\n        var g = this.readByte(data);\n        var b = this.readByte(data);\n        color.setRGB(r / 255, g / 255, b / 255);\n        this.debugMessage(\"      Color: \" + color.r + \", \" + color.g + \", \" + color.b);\n      } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n        var _r = this.readFloat(data);\n        var _g = this.readFloat(data);\n        var _b = this.readFloat(data);\n        color.setRGB(_r, _g, _b);\n        this.debugMessage(\"      Color: \" + color.r + \", \" + color.g + \", \" + color.b);\n      } else {\n        this.debugMessage(\"      Unknown color chunk: \" + chunk.toString(16));\n      }\n      this.endChunk(chunk);\n      return color;\n    }\n    /**\n     * Read next chunk of data.\n     *\n     * @method readChunk\n     * @param {DataView} data Dataview.\n     * @return {Object} Chunk of data read.\n     */\n  }, {\n    key: \"readChunk\",\n    value: function readChunk(data) {\n      var chunk = {};\n      chunk.cur = this.position;\n      chunk.id = this.readWord(data);\n      chunk.size = this.readDWord(data);\n      chunk.end = chunk.cur + chunk.size;\n      chunk.cur += 6;\n      return chunk;\n    }\n    /**\n     * Set position to the end of the current chunk of data.\n     *\n     * @method endChunk\n     * @param {Object} chunk Data chunk.\n     */\n  }, {\n    key: \"endChunk\",\n    value: function endChunk(chunk) {\n      this.position = chunk.end;\n    }\n    /**\n     * Move to the next data chunk.\n     *\n     * @method nextChunk\n     * @param {DataView} data Dataview.\n     * @param {Object} chunk Data chunk.\n     */\n  }, {\n    key: \"nextChunk\",\n    value: function nextChunk(data, chunk) {\n      if (chunk.cur >= chunk.end) {\n        return 0;\n      }\n      this.position = chunk.cur;\n      try {\n        var next = this.readChunk(data);\n        chunk.cur += next.size;\n        return next.id;\n      } catch (e) {\n        this.debugMessage(\"Unable to read chunk at \" + this.position);\n        return 0;\n      }\n    }\n    /**\n     * Reset dataview position.\n     *\n     * @method resetPosition\n     */\n  }, {\n    key: \"resetPosition\",\n    value: function resetPosition() {\n      this.position -= 6;\n    }\n    /**\n     * Read byte value.\n     *\n     * @method readByte\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readByte\",\n    value: function readByte(data) {\n      var v = data.getUint8(this.position, true);\n      this.position += 1;\n      return v;\n    }\n    /**\n     * Read 32 bit float value.\n     *\n     * @method readFloat\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readFloat\",\n    value: function readFloat(data) {\n      try {\n        var v = data.getFloat32(this.position, true);\n        this.position += 4;\n        return v;\n      } catch (e) {\n        this.debugMessage(e + \" \" + this.position + \" \" + data.byteLength);\n      }\n    }\n    /**\n     * Read 32 bit signed integer value.\n     *\n     * @method readInt\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readInt\",\n    value: function readInt(data) {\n      var v = data.getInt32(this.position, true);\n      this.position += 4;\n      return v;\n    }\n    /**\n     * Read 16 bit signed integer value.\n     *\n     * @method readShort\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readShort\",\n    value: function readShort(data) {\n      var v = data.getInt16(this.position, true);\n      this.position += 2;\n      return v;\n    }\n    /**\n     * Read 64 bit unsigned integer value.\n     *\n     * @method readDWord\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readDWord\",\n    value: function readDWord(data) {\n      var v = data.getUint32(this.position, true);\n      this.position += 4;\n      return v;\n    }\n    /**\n     * Read 32 bit unsigned integer value.\n     *\n     * @method readWord\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readWord\",\n    value: function readWord(data) {\n      var v = data.getUint16(this.position, true);\n      this.position += 2;\n      return v;\n    }\n    /**\n     * Read string value.\n     *\n     * @method readString\n     * @param {DataView} data Dataview to read data from.\n     * @param {Number} maxLength Max size of the string to be read.\n     * @return {String} Data read from the dataview.\n     */\n  }, {\n    key: \"readString\",\n    value: function readString(data, maxLength) {\n      var s = \"\";\n      for (var i = 0; i < maxLength; i++) {\n        var c = this.readByte(data);\n        if (!c) {\n          break;\n        }\n        s += String.fromCharCode(c);\n      }\n      return s;\n    }\n    /**\n     * Read percentage value.\n     *\n     * @method readPercentage\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readPercentage\",\n    value: function readPercentage(data) {\n      var chunk = this.readChunk(data);\n      var value;\n      switch (chunk.id) {\n        case INT_PERCENTAGE:\n          value = this.readShort(data) / 100;\n          break;\n        case FLOAT_PERCENTAGE:\n          value = this.readFloat(data);\n          break;\n        default:\n          this.debugMessage(\"      Unknown percentage chunk: \" + chunk.toString(16));\n      }\n      this.endChunk(chunk);\n      return value;\n    }\n    /**\n     * Print debug message to the console.\n     *\n     * Is controlled by a flag to show or hide debug messages.\n     *\n     * @method debugMessage\n     * @param {Object} message Debug message to print to the console.\n     */\n  }, {\n    key: \"debugMessage\",\n    value: function debugMessage(message) {\n      if (this.debug) {\n        console.log(message);\n      }\n    }\n  }]);\n  return TDSLoader;\n}(Loader);\nvar M3DMAGIC = 19789;\nvar MLIBMAGIC = 15786;\nvar CMAGIC = 49725;\nvar M3D_VERSION = 2;\nvar COLOR_F = 16;\nvar COLOR_24 = 17;\nvar LIN_COLOR_24 = 18;\nvar LIN_COLOR_F = 19;\nvar INT_PERCENTAGE = 48;\nvar FLOAT_PERCENTAGE = 49;\nvar MDATA = 15677;\nvar MESH_VERSION = 15678;\nvar MASTER_SCALE = 256;\nvar MAT_ENTRY = 45055;\nvar MAT_NAME = 40960;\nvar MAT_AMBIENT = 40976;\nvar MAT_DIFFUSE = 40992;\nvar MAT_SPECULAR = 41008;\nvar MAT_SHININESS = 41024;\nvar MAT_TRANSPARENCY = 41040;\nvar MAT_TWO_SIDE = 41089;\nvar MAT_ADDITIVE = 41091;\nvar MAT_WIRE = 41093;\nvar MAT_WIRE_SIZE = 41095;\nvar MAT_TEXMAP = 41472;\nvar MAT_OPACMAP = 41488;\nvar MAT_BUMPMAP = 41520;\nvar MAT_SPECMAP = 41476;\nvar MAT_MAPNAME = 41728;\nvar MAT_MAP_USCALE = 41812;\nvar MAT_MAP_VSCALE = 41814;\nvar MAT_MAP_UOFFSET = 41816;\nvar MAT_MAP_VOFFSET = 41818;\nvar NAMED_OBJECT = 16384;\nvar N_TRI_OBJECT = 16640;\nvar POINT_ARRAY = 16656;\nvar FACE_ARRAY = 16672;\nvar MSH_MAT_GROUP = 16688;\nvar TEX_VERTS = 16704;\nvar MESH_MATRIX = 16736;\nexport { TDSLoader };\n//# sourceMappingURL=TDSLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}