{"ast":null,"code":"import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nvar _box1, _box2;\nvar boxStack = [];\nvar boxPool = /* @__PURE__ */new PrimitivePool(function () {\n  return new Box3();\n});\nexport function shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {\n  // setup\n  _box1 = boxPool.getPrimitive();\n  _box2 = boxPool.getPrimitive();\n  boxStack.push(_box1, _box2);\n  BufferStack.setBuffer(bvh._roots[root]);\n  var result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n\n  // cleanup\n  BufferStack.clearBuffer();\n  boxPool.releasePrimitive(_box1);\n  boxPool.releasePrimitive(_box2);\n  boxStack.pop();\n  boxStack.pop();\n  var length = boxStack.length;\n  if (length > 0) {\n    _box2 = boxStack[length - 1];\n    _box1 = boxStack[length - 2];\n  }\n  return result;\n}\nfunction shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc) {\n  var nodeScoreFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var nodeIndexByteOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var depth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var float32Array = BufferStack.float32Array,\n    uint16Array = BufferStack.uint16Array,\n    uint32Array = BufferStack.uint32Array;\n  var nodeIndex16 = nodeIndex32 * 2;\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    var offset = OFFSET(nodeIndex32, uint32Array);\n    var count = COUNT(nodeIndex16, uint16Array);\n    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);\n    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);\n  } else {\n    // Define these inside the function so it has access to the local variables needed\n    // when converting to the buffer equivalents\n    var getLeftOffset = function getLeftOffset(nodeIndex32) {\n      var uint16Array = BufferStack.uint16Array,\n        uint32Array = BufferStack.uint32Array;\n      var nodeIndex16 = nodeIndex32 * 2;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        nodeIndex32 = LEFT_NODE(nodeIndex32);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n      return OFFSET(nodeIndex32, uint32Array);\n    };\n    var getRightEndOffset = function getRightEndOffset(nodeIndex32) {\n      var uint16Array = BufferStack.uint16Array,\n        uint32Array = BufferStack.uint32Array;\n      var nodeIndex16 = nodeIndex32 * 2;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        // adjust offset to point to the right node\n        nodeIndex32 = RIGHT_NODE(nodeIndex32, uint32Array);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n\n      // return the end offset of the triangle range\n      return OFFSET(nodeIndex32, uint32Array) + COUNT(nodeIndex16, uint16Array);\n    };\n    var left = LEFT_NODE(nodeIndex32);\n    var right = RIGHT_NODE(nodeIndex32, uint32Array);\n    var c1 = left;\n    var c2 = right;\n    var score1, score2;\n    var box1, box2;\n    if (nodeScoreFunc) {\n      box1 = _box1;\n      box2 = _box2;\n\n      // bounding data is not offset\n      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n      score1 = nodeScoreFunc(box1);\n      score2 = nodeScoreFunc(box2);\n      if (score2 < score1) {\n        c1 = right;\n        c2 = left;\n        var temp = score1;\n        score1 = score2;\n        score2 = temp;\n        box1 = box2;\n        // box2 is always set before use below\n      }\n    }\n\n    // Check box 1 intersection\n    if (!box1) {\n      box1 = _box1;\n      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n    }\n    var isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\n    var c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n    var c1StopTraversal;\n    if (c1Intersection === CONTAINED) {\n      var _offset = getLeftOffset(c1);\n      var end = getRightEndOffset(c1);\n      var _count = end - _offset;\n      c1StopTraversal = intersectsRangeFunc(_offset, _count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n    } else {\n      c1StopTraversal = c1Intersection && shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n    }\n    if (c1StopTraversal) return true;\n\n    // Check box 2 intersection\n    // cached box2 will have been overwritten by previous traversal\n    box2 = _box2;\n    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n    var isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\n    var c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n    var c2StopTraversal;\n    if (c2Intersection === CONTAINED) {\n      var _offset2 = getLeftOffset(c2);\n      var _end = getRightEndOffset(c2);\n      var _count2 = _end - _offset2;\n      c2StopTraversal = intersectsRangeFunc(_offset2, _count2, true, depth + 1, nodeIndexByteOffset + c2, box2);\n    } else {\n      c2StopTraversal = c2Intersection && shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n    }\n    if (c2StopTraversal) return true;\n    return false;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}