{"ast":null,"code":"import _slicedToArray from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\", \"compute\", \"width\", \"height\", \"samples\", \"renderPriority\", \"eventPriority\", \"frames\", \"stencilBuffer\", \"depthBuffer\", \"generateMipmaps\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nvar RenderTexture = /* @__PURE__ */React.forwardRef(function (_ref, forwardRef) {\n  var children = _ref.children,\n    compute = _ref.compute,\n    width = _ref.width,\n    height = _ref.height,\n    _ref$samples = _ref.samples,\n    samples = _ref$samples === void 0 ? 8 : _ref$samples,\n    _ref$renderPriority = _ref.renderPriority,\n    renderPriority = _ref$renderPriority === void 0 ? 0 : _ref$renderPriority,\n    _ref$eventPriority = _ref.eventPriority,\n    eventPriority = _ref$eventPriority === void 0 ? 0 : _ref$eventPriority,\n    _ref$frames = _ref.frames,\n    frames = _ref$frames === void 0 ? Infinity : _ref$frames,\n    _ref$stencilBuffer = _ref.stencilBuffer,\n    stencilBuffer = _ref$stencilBuffer === void 0 ? false : _ref$stencilBuffer,\n    _ref$depthBuffer = _ref.depthBuffer,\n    depthBuffer = _ref$depthBuffer === void 0 ? true : _ref$depthBuffer,\n    _ref$generateMipmaps = _ref.generateMipmaps,\n    generateMipmaps = _ref$generateMipmaps === void 0 ? false : _ref$generateMipmaps,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var _useThree = useThree(),\n    size = _useThree.size,\n    viewport = _useThree.viewport;\n  var fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\n    samples: samples,\n    stencilBuffer: stencilBuffer,\n    depthBuffer: depthBuffer,\n    generateMipmaps: generateMipmaps\n  });\n  var _React$useState = React.useState(function () {\n      return new THREE.Scene();\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    vScene = _React$useState2[0];\n  var uvCompute = React.useCallback(function (event, state, previous) {\n    var _fbo$texture, _previous$previousRoo;\n    // Since this is only a texture it does not have an easy way to obtain the parent, which we\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\n    // next Object3D.\n    var parent = (_fbo$texture = fbo.texture) == null ? void 0 : _fbo$texture.__r3f.parent;\n    while (parent && !(parent instanceof THREE.Object3D)) {\n      parent = parent.__r3f.parent;\n    }\n    if (!parent) return false;\n    // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState());\n    // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n    var _previous$raycaster$i = previous.raycaster.intersectObject(parent),\n      _previous$raycaster$i2 = _slicedToArray(_previous$raycaster$i, 1),\n      intersection = _previous$raycaster$i2[0];\n    if (!intersection) return false;\n    // We take that hits uv coords, set up this layers raycaster, et voil√†, we have raycasting on arbitrary surfaces\n    var uv = intersection.uv;\n    if (!uv) return false;\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\n  }, []);\n  React.useImperativeHandle(forwardRef, function () {\n    return fbo.texture;\n  }, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    fbo: fbo\n  }, children, /*#__PURE__*/React.createElement(\"group\", {\n    onPointerOver: function onPointerOver() {\n      return null;\n    }\n  })), vScene, {\n    events: {\n      compute: compute || uvCompute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)));\n});\n\n// The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\nfunction Container(_ref2) {\n  var frames = _ref2.frames,\n    renderPriority = _ref2.renderPriority,\n    children = _ref2.children,\n    fbo = _ref2.fbo;\n  var count = 0;\n  var oldAutoClear;\n  useFrame(function (state) {\n    if (frames === Infinity || count < frames) {\n      oldAutoClear = state.gl.autoClear;\n      state.gl.autoClear = true;\n      state.gl.setRenderTarget(fbo);\n      state.gl.render(state.scene, state.camera);\n      state.gl.setRenderTarget(null);\n      state.gl.autoClear = oldAutoClear;\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\nexport { RenderTexture };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}