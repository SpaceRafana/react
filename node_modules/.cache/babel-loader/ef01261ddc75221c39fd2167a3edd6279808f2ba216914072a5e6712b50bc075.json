{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nvar cb = new Vector3();\nvar ab = new Vector3();\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\nfunction removeFromArray(array, object) {\n  var k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\nvar Vertex = /*#__PURE__*/function () {\n  function Vertex(v, id) {\n    _classCallCheck(this, Vertex);\n    __publicField(this, \"position\");\n    __publicField(this, \"id\");\n    __publicField(this, \"faces\");\n    __publicField(this, \"neighbors\");\n    __publicField(this, \"collapseCost\");\n    __publicField(this, \"collapseNeighbor\");\n    __publicField(this, \"minCost\", 0);\n    __publicField(this, \"totalCost\", 0);\n    __publicField(this, \"costCount\", 0);\n    this.position = v;\n    this.id = id;\n    this.faces = [];\n    this.neighbors = [];\n    this.collapseCost = 0;\n    this.collapseNeighbor = null;\n  }\n  _createClass(Vertex, [{\n    key: \"addUniqueNeighbor\",\n    value: function addUniqueNeighbor(vertex) {\n      pushIfUnique(this.neighbors, vertex);\n    }\n  }, {\n    key: \"removeIfNonNeighbor\",\n    value: function removeIfNonNeighbor(n) {\n      var neighbors = this.neighbors;\n      var faces = this.faces;\n      var offset = neighbors.indexOf(n);\n      if (offset === -1) return;\n      for (var i = 0; i < faces.length; i++) {\n        if (faces[i].hasVertex(n)) return;\n      }\n      neighbors.splice(offset, 1);\n    }\n  }]);\n  return Vertex;\n}();\nvar Triangle = /*#__PURE__*/function () {\n  function Triangle(v1, v2, v3, a, b, c) {\n    _classCallCheck(this, Triangle);\n    __publicField(this, \"a\");\n    __publicField(this, \"b\");\n    __publicField(this, \"c\");\n    __publicField(this, \"v1\");\n    __publicField(this, \"v2\");\n    __publicField(this, \"v3\");\n    __publicField(this, \"normal\", new Vector3());\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n  _createClass(Triangle, [{\n    key: \"computeNormal\",\n    value: function computeNormal() {\n      var vA = this.v1.position;\n      var vB = this.v2.position;\n      var vC = this.v3.position;\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      this.normal.copy(cb);\n    }\n  }, {\n    key: \"hasVertex\",\n    value: function hasVertex(v) {\n      return v === this.v1 || v === this.v2 || v === this.v3;\n    }\n  }, {\n    key: \"replaceVertex\",\n    value: function replaceVertex(oldv, newv) {\n      if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n      removeFromArray(oldv.faces, this);\n      newv.faces.push(this);\n      oldv.removeIfNonNeighbor(this.v1);\n      this.v1.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v2);\n      this.v2.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v3);\n      this.v3.removeIfNonNeighbor(oldv);\n      this.v1.addUniqueNeighbor(this.v2);\n      this.v1.addUniqueNeighbor(this.v3);\n      this.v2.addUniqueNeighbor(this.v1);\n      this.v2.addUniqueNeighbor(this.v3);\n      this.v3.addUniqueNeighbor(this.v1);\n      this.v3.addUniqueNeighbor(this.v2);\n      this.computeNormal();\n    }\n  }]);\n  return Triangle;\n}();\nvar SimplifyModifier = /*#__PURE__*/function () {\n  function SimplifyModifier() {\n    var _this = this;\n    _classCallCheck(this, SimplifyModifier);\n    __publicField(this, \"computeEdgeCollapseCost\", function (u, v) {\n      var edgelength = v.position.distanceTo(u.position);\n      var curvature = 0;\n      var sideFaces = [];\n      var i,\n        il = u.faces.length,\n        face,\n        sideFace;\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      }\n      for (i = 0; i < il; i++) {\n        var minCurvature = 1;\n        face = u.faces[i];\n        for (var j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j];\n          var dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n        curvature = Math.max(curvature, minCurvature);\n      }\n      var borders = 0;\n      if (sideFaces.length < 2) {\n        curvature = 1;\n      }\n      var amt = edgelength * curvature + borders;\n      return amt;\n    });\n    __publicField(this, \"computeEdgeCostAtVertex\", function (v) {\n      if (v.neighbors.length === 0) {\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n      v.collapseCost = 1e5;\n      v.collapseNeighbor = null;\n      for (var i = 0; i < v.neighbors.length; i++) {\n        var collapseCost = _this.computeEdgeCollapseCost(v, v.neighbors[i]);\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n        v.costCount++;\n        v.totalCost += collapseCost;\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      }\n      v.collapseCost = v.totalCost / v.costCount;\n    });\n    __publicField(this, \"removeFace\", function (f, faces) {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f);\n      var vs = [f.v1, f.v2, f.v3];\n      var v1, v2;\n      for (var i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n    __publicField(this, \"collapse\", function (vertices, faces, u, v) {\n      if (!v) {\n        _this.removeVertex(u, vertices);\n        return;\n      }\n      var i;\n      var tmpVertices = [];\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          _this.removeFace(u.faces[i], faces);\n        }\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n      _this.removeVertex(u, vertices);\n      for (i = 0; i < tmpVertices.length; i++) {\n        _this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n    __publicField(this, \"minimumCostEdge\", function (vertices) {\n      var least = vertices[0];\n      for (var i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n      return least;\n    });\n    __publicField(this, \"modify\", function (geometry, count) {\n      geometry = geometry.clone();\n      var attributes = geometry.attributes;\n      for (var name in attributes) {\n        if (name !== \"position\") geometry.deleteAttribute(name);\n      }\n      geometry = mergeVertices(geometry);\n      var vertices = [];\n      var faces = [];\n      var positionAttribute = geometry.getAttribute(\"position\");\n      for (var i = 0; i < positionAttribute.count; i++) {\n        var v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        var vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      }\n      var geomIndex = geometry.getIndex();\n      if (geomIndex !== null) {\n        for (var _i = 0; _i < geomIndex.count; _i += 3) {\n          var a = geomIndex.getX(_i);\n          var b = geomIndex.getX(_i + 1);\n          var c = geomIndex.getX(_i + 2);\n          var triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (var _i2 = 0; _i2 < positionAttribute.count; _i2 += 3) {\n          var _a = _i2;\n          var _b = _i2 + 1;\n          var _c = _i2 + 2;\n          var _triangle = new Triangle(vertices[_a], vertices[_b], vertices[_c], _a, _b, _c);\n          faces.push(_triangle);\n        }\n      }\n      for (var _i3 = 0, il = vertices.length; _i3 < il; _i3++) {\n        _this.computeEdgeCostAtVertex(vertices[_i3]);\n      }\n      var nextVertex;\n      var z = count;\n      while (z--) {\n        nextVertex = _this.minimumCostEdge(vertices);\n        if (!nextVertex) {\n          console.log(\"THREE.SimplifyModifier: No next vertex\");\n          break;\n        } else {\n          _this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      }\n      var simplifiedGeometry = new BufferGeometry();\n      var position = [];\n      var index = [];\n      for (var _i4 = 0; _i4 < vertices.length; _i4++) {\n        var _vertex = vertices[_i4].position;\n        position.push(_vertex.x, _vertex.y, _vertex.z);\n      }\n      for (var _i5 = 0; _i5 < faces.length; _i5++) {\n        var face = faces[_i5];\n        var _a2 = vertices.indexOf(face.v1);\n        var _b2 = vertices.indexOf(face.v2);\n        var _c2 = vertices.indexOf(face.v3);\n        index.push(_a2, _b2, _c2);\n      }\n      simplifiedGeometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n  _createClass(SimplifyModifier, [{\n    key: \"removeVertex\",\n    value: function removeVertex(v, vertices) {\n      console.assert(v.faces.length === 0);\n      while (v.neighbors.length) {\n        var n = v.neighbors.pop();\n        removeFromArray(n.neighbors, v);\n      }\n      removeFromArray(vertices, v);\n    }\n  }]);\n  return SimplifyModifier;\n}();\nexport { SimplifyModifier };\n//# sourceMappingURL=SimplifyModifier.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}