{"ast":null,"code":"import InputNode from '../core/InputNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { nodeObject, addNodeElement } from '../shadernode/ShaderNode.js';\nimport { InterleavedBufferAttribute, InterleavedBuffer, StaticDrawUsage, DynamicDrawUsage } from 'three';\nclass BufferAttributeNode extends InputNode {\n  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {\n    super(value, bufferType);\n    this.isBufferNode = true;\n    this.bufferType = bufferType;\n    this.bufferStride = bufferStride;\n    this.bufferOffset = bufferOffset;\n    this.usage = StaticDrawUsage;\n    this.instanced = false;\n    this.attribute = null;\n    if (value && value.isBufferAttribute === true) {\n      this.attribute = value;\n      this.usage = value.usage;\n      this.instanced = value.isInstancedBufferAttribute;\n    }\n  }\n  getNodeType(builder) {\n    if (this.bufferType === null) {\n      this.bufferType = builder.getTypeFromAttribute(this.attribute);\n    }\n    return this.bufferType;\n  }\n  setup(builder) {\n    if (this.attribute !== null) return;\n    const type = this.getNodeType(builder);\n    const array = this.value;\n    const itemSize = builder.getTypeLength(type);\n    const stride = this.bufferStride || itemSize;\n    const offset = this.bufferOffset;\n    const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);\n    const bufferAttribute = new InterleavedBufferAttribute(buffer, itemSize, offset);\n    buffer.setUsage(this.usage);\n    this.attribute = bufferAttribute;\n    this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n  }\n\n  generate(builder) {\n    const nodeType = this.getNodeType(builder);\n    const nodeUniform = builder.getBufferAttributeFromNode(this, nodeType);\n    const propertyName = builder.getPropertyName(nodeUniform);\n    let output = null;\n    if (builder.shaderStage === 'vertex') {\n      output = propertyName;\n    } else {\n      const nodeVarying = varying(this);\n      output = nodeVarying.build(builder, nodeType);\n    }\n    return output;\n  }\n  getInputType( /*builder*/\n  ) {\n    return 'bufferAttribute';\n  }\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n  setInstanced(value) {\n    this.instanced = value;\n    return this;\n  }\n}\nexport default BufferAttributeNode;\nexport const bufferAttribute = (array, type, stride, offset) => nodeObject(new BufferAttributeNode(array, type, stride, offset));\nexport const dynamicBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);\nexport const instancedBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setInstanced(true);\nexport const instancedDynamicBufferAttribute = (array, type, stride, offset) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);\naddNodeElement('toAttribute', bufferNode => bufferAttribute(bufferNode.value));\naddNodeClass('BufferAttributeNode', BufferAttributeNode);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}