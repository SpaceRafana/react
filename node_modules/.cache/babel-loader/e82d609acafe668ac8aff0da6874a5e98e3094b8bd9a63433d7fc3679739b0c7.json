{"ast":null,"code":"import _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { OrthographicCamera, Scene, StereoCamera, WebGLRenderTarget, ShaderMaterial, REVISION, Mesh, PlaneGeometry, LinearFilter, NearestFilter, RGBAFormat } from \"three\";\nvar ParallaxBarrierEffect = /*#__PURE__*/_createClass(function ParallaxBarrierEffect(renderer) {\n  _classCallCheck(this, ParallaxBarrierEffect);\n  var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  var _scene = new Scene();\n  var _stereo = new StereoCamera();\n  var _params = {\n    minFilter: LinearFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  };\n  var _renderTargetL = new WebGLRenderTarget(512, 512, _params);\n  var _renderTargetR = new WebGLRenderTarget(512, 512, _params);\n  var _material = new ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      }\n    },\n    vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = vec2( uv.x, uv.y );\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform sampler2D mapLeft;\", \"uniform sampler2D mapRight;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 uv = vUv;\", \"\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {\", \"\t\tgl_FragColor = texture2D( mapLeft, uv );\", \"\t} else {\", \"\t\tgl_FragColor = texture2D( mapRight, uv );\", \"\t}\", \"\t#include <tonemapping_fragment>\", \"\\t#include <\".concat(parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\", \">\"), \"}\"].join(\"\\n\")\n  });\n  var mesh = new Mesh(new PlaneGeometry(2, 2), _material);\n  _scene.add(mesh);\n  this.setSize = function (width, height) {\n    renderer.setSize(width, height);\n    var pixelRatio = renderer.getPixelRatio();\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n  this.render = function (scene, camera) {\n    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n    _stereo.update(camera);\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n  };\n});\nexport { ParallaxBarrierEffect };\n//# sourceMappingURL=ParallaxBarrierEffect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}