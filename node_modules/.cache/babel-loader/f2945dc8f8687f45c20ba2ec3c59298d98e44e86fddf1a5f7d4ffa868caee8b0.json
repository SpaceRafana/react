{"ast":null,"code":"import _objectSpread from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast as _shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint as _closestPointToPoint } from './cast/closestPointToPoint.js';\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit as _refit } from './cast/refit.generated.js';\nimport { raycast as _raycast } from './cast/raycast.generated.js';\nimport { raycastFirst as _raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry as _intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry as _closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast as _bvhcast } from './cast/bvhcast.js';\nvar obb = /* @__PURE__ */new OrientedBox();\nvar tempBox = /* @__PURE__ */new Box3();\nexport var MeshBVH = /*#__PURE__*/function () {\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, MeshBVH);\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    }\n\n    // default options\n    options = Object.assign(_defineProperty({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null,\n      indirect: false\n    }, SKIP_GENERATION, false), options);\n    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n    this.geometry = geometry;\n    this._roots = null;\n    this._indirectBuffer = null;\n    if (!options[SKIP_GENERATION]) {\n      buildPackedTree(this, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n    var _indirectBuffer = this._indirectBuffer;\n    this.resolveTriangleIndex = options.indirect ? function (i) {\n      return _indirectBuffer[i];\n    } : function (i) {\n      return i;\n    };\n  }\n  _createClass(MeshBVH, [{\n    key: \"indirect\",\n    get: function get() {\n      return !!this._indirectBuffer;\n    }\n  }, {\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var refitFunc = this.indirect ? refit_indirect : _refit;\n      return refitFunc(this, nodeIndices);\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n      _traverse(0);\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          // TODO: use node functions here\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    }\n\n    /* Core Cast Functions */\n  }, {\n    key: \"raycast\",\n    value: function raycast(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var intersects = [];\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      var raycastFunc = this.indirect ? raycast_indirect : _raycast;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var startCount = intersects.length;\n        raycastFunc(this, i, materialSide, ray, intersects);\n        if (isArrayMaterial) {\n          var materialIndex = groups[i].materialIndex;\n          for (var j = startCount, jl = intersects.length; j < jl; j++) {\n            intersects[j].face.materialIndex = materialIndex;\n          }\n        }\n      }\n      return intersects;\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var closestResult = null;\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      var raycastFirstFunc = this.indirect ? raycastFirst_indirect : _raycastFirst;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var result = raycastFirstFunc(this, i, materialSide, ray);\n        if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n          closestResult = result;\n          if (isArrayMaterial) {\n            result.face.materialIndex = groups[i].materialIndex;\n          }\n        }\n      }\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(otherGeometry, geomToMesh) {\n      var result = false;\n      var roots = this._roots;\n      var intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : _intersectsGeometry;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n        if (result) {\n          break;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(callbacks) {\n      var _this = this;\n      var triangle = ExtendedTrianglePool.getPrimitive();\n      var iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n      var boundsTraverseOrder = callbacks.boundsTraverseOrder,\n        intersectsBounds = callbacks.intersectsBounds,\n        intersectsRange = callbacks.intersectsRange,\n        intersectsTriangle = callbacks.intersectsTriangle;\n\n      // wrap the intersectsRange function\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateFunc(offset, count, _this, intersectsTriangle, contained, depth, triangle);\n          }\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateFunc(offset, count, _this, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n\n      // run shapecast\n      var result = false;\n      var byteOffset = 0;\n      var roots = this._roots;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var root = roots[i];\n        result = _shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n        if (result) {\n          break;\n        }\n        byteOffset += root.byteLength;\n      }\n      ExtendedTrianglePool.releasePrimitive(triangle);\n      return result;\n    }\n  }, {\n    key: \"bvhcast\",\n    value: function bvhcast(otherBvh, matrixToLocal, callbacks) {\n      var _this2 = this;\n      var intersectsRanges = callbacks.intersectsRanges,\n        intersectsTriangles = callbacks.intersectsTriangles;\n      var triangle1 = ExtendedTrianglePool.getPrimitive();\n      var indexAttr1 = this.geometry.index;\n      var positionAttr1 = this.geometry.attributes.position;\n      var assignTriangle1 = this.indirect ? function (i1) {\n        var ti = _this2.resolveTriangleIndex(i1);\n        setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);\n      } : function (i1) {\n        setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);\n      };\n      var triangle2 = ExtendedTrianglePool.getPrimitive();\n      var indexAttr2 = otherBvh.geometry.index;\n      var positionAttr2 = otherBvh.geometry.attributes.position;\n      var assignTriangle2 = otherBvh.indirect ? function (i2) {\n        var ti2 = otherBvh.resolveTriangleIndex(i2);\n        setTriangle(triangle2, ti2 * 3, indexAttr2, positionAttr2);\n      } : function (i2) {\n        setTriangle(triangle2, i2 * 3, indexAttr2, positionAttr2);\n      };\n\n      // generate triangle callback if needed\n      if (intersectsTriangles) {\n        var iterateOverDoubleTriangles = function iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          for (var i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n            assignTriangle2(i2);\n            triangle2.a.applyMatrix4(matrixToLocal);\n            triangle2.b.applyMatrix4(matrixToLocal);\n            triangle2.c.applyMatrix4(matrixToLocal);\n            triangle2.needsUpdate = true;\n            for (var i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n              assignTriangle1(i1);\n              triangle1.needsUpdate = true;\n              if (intersectsTriangles(triangle1, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n                return true;\n              }\n            }\n          }\n          return false;\n        };\n        if (intersectsRanges) {\n          var originalIntersectsRanges = intersectsRanges;\n          intersectsRanges = function intersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n            if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n              return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n            }\n            return true;\n          };\n        } else {\n          intersectsRanges = iterateOverDoubleTriangles;\n        }\n      }\n      return _bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);\n    }\n\n    /* Derived Cast Functions */\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n      var closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : _closestPointToGeometry;\n      return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(point) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      return _closestPointToPoint(this, point, target, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }], [{\n    key: \"serialize\",\n    value: function serialize(bvh) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      options = _objectSpread({\n        cloneBuffers: true\n      }, options);\n      var geometry = bvh.geometry;\n      var rootData = bvh._roots;\n      var indirectBuffer = bvh._indirectBuffer;\n      var indexAttribute = geometry.getIndex();\n      var result;\n      if (options.cloneBuffers) {\n        result = {\n          roots: rootData.map(function (root) {\n            return root.slice();\n          }),\n          index: indexAttribute.array.slice(),\n          indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n        };\n      } else {\n        result = {\n          roots: rootData,\n          index: indexAttribute.array,\n          indirectBuffer: indirectBuffer\n        };\n      }\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      options = _objectSpread({\n        setIndex: true,\n        indirect: Boolean(data.indirectBuffer)\n      }, options);\n      var index = data.index,\n        roots = data.roots,\n        indirectBuffer = data.indirectBuffer;\n      var bvh = new MeshBVH(geometry, _objectSpread(_objectSpread({}, options), {}, _defineProperty({}, SKIP_GENERATION, true)));\n      bvh._roots = roots;\n      bvh._indirectBuffer = indirectBuffer || null;\n      if (options.setIndex) {\n        var indexAttribute = geometry.getIndex();\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n      return bvh;\n    }\n  }]);\n  return MeshBVH;\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}