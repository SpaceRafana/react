{"ast":null,"code":"import _assertThisInitialized from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Group, LightProbe, DirectionalLight, WebGLCubeRenderTarget } from \"three\";\nvar SessionLightProbe = /*#__PURE__*/function () {\n  function SessionLightProbe(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    var _this = this;\n    _classCallCheck(this, SessionLightProbe);\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    var session = renderer.xr.getSession();\n    if (environmentEstimation && \"XRWebGLBinding\" in window) {\n      var cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      var gl = renderer.getContext();\n      switch (session.preferredReflectionFormat) {\n        case \"srgba8\":\n          gl.getExtension(\"EXT_sRGB\");\n          break;\n        case \"rgba16f\":\n          gl.getExtension(\"OES_texture_half_float\");\n          break;\n      }\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener(\"reflectionchange\", function () {\n        _this.updateReflection();\n      });\n    }\n    session.requestAnimationFrame(this.frameCallback);\n  }\n  _createClass(SessionLightProbe, [{\n    key: \"updateReflection\",\n    value: function updateReflection() {\n      var textureProperties = this.renderer.properties.get(this.xrLight.environment);\n      if (textureProperties) {\n        var cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n        if (cubeMap) {\n          textureProperties.__webglTexture = cubeMap;\n          this.xrLight.environment.needsPMREMUpdate = true;\n        }\n      }\n    }\n  }, {\n    key: \"onXRFrame\",\n    value: function onXRFrame(time, xrFrame) {\n      if (!this.xrLight) {\n        return;\n      }\n      var session = xrFrame.session;\n      session.requestAnimationFrame(this.frameCallback);\n      var lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n      if (lightEstimate) {\n        this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n        this.xrLight.lightProbe.intensity = 1;\n        var intensityScalar = Math.max(1, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n        this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n        this.xrLight.directionalLight.intensity = intensityScalar;\n        this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n        if (this.estimationStartCallback) {\n          this.estimationStartCallback();\n          this.estimationStartCallback = null;\n        }\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.xrLight = null;\n      this.renderer = null;\n      this.lightProbe = null;\n      this.xrWebGLBinding = null;\n    }\n  }]);\n  return SessionLightProbe;\n}();\nvar XREstimatedLight = /*#__PURE__*/function (_Group) {\n  _inherits(XREstimatedLight, _Group);\n  var _super = _createSuper(XREstimatedLight);\n  function XREstimatedLight(renderer) {\n    var _this2;\n    var environmentEstimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    _classCallCheck(this, XREstimatedLight);\n    _this2 = _super.call(this);\n    _this2.lightProbe = new LightProbe();\n    _this2.lightProbe.intensity = 0;\n    _this2.add(_this2.lightProbe);\n    _this2.directionalLight = new DirectionalLight();\n    _this2.directionalLight.intensity = 0;\n    _this2.add(_this2.directionalLight);\n    _this2.environment = null;\n    var sessionLightProbe = null;\n    var estimationStarted = false;\n    renderer.xr.addEventListener(\"sessionstart\", function () {\n      var session = renderer.xr.getSession();\n      if (\"requestLightProbe\" in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(function (probe) {\n          sessionLightProbe = new SessionLightProbe(_assertThisInitialized(_this2), renderer, probe, environmentEstimation, function () {\n            estimationStarted = true;\n            _this2.dispatchEvent({\n              type: \"estimationstart\"\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener(\"sessionend\", function () {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      if (estimationStarted) {\n        _this2.dispatchEvent({\n          type: \"estimationend\"\n        });\n      }\n    });\n    _this2.dispose = function () {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      _this2.remove(_this2.lightProbe);\n      _this2.lightProbe = null;\n      _this2.remove(_this2.directionalLight);\n      _this2.directionalLight = null;\n      _this2.environment = null;\n    };\n    return _this2;\n  }\n  return _createClass(XREstimatedLight);\n}(Group);\nexport { XREstimatedLight };\n//# sourceMappingURL=XREstimatedLight.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}