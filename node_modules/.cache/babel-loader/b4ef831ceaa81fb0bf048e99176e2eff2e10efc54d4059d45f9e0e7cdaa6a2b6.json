{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { DataTexture, FloatType, UnsignedIntType, RGBAFormat, RGIntegerFormat, NearestFilter, BufferAttribute } from 'three';\nimport { FloatVertexAttributeTexture, UIntVertexAttributeTexture } from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, RIGHT_NODE, OFFSET, SPLIT_AXIS } from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\nexport var MeshBVHUniformStruct = /*#__PURE__*/function () {\n  function MeshBVHUniformStruct() {\n    _classCallCheck(this, MeshBVHUniformStruct);\n    this.index = new UIntVertexAttributeTexture();\n    this.position = new FloatVertexAttributeTexture();\n    this.bvhBounds = new DataTexture();\n    this.bvhContents = new DataTexture();\n    this._cachedIndexAttr = null;\n    this.index.overrideItemSize = 3;\n  }\n  _createClass(MeshBVHUniformStruct, [{\n    key: \"updateFrom\",\n    value: function updateFrom(bvh) {\n      var geometry = bvh.geometry;\n      bvhToTextures(bvh, this.bvhBounds, this.bvhContents);\n      this.position.updateFrom(geometry.attributes.position);\n\n      // dereference a new index attribute if we're using indirect storage\n      if (bvh.indirect) {\n        var indirectBuffer = bvh._indirectBuffer;\n        if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== indirectBuffer.length) {\n          if (geometry.index) {\n            this._cachedIndexAttr = geometry.index.clone();\n          } else {\n            var array = getIndexArray(getVertexCount(geometry));\n            this._cachedIndexAttr = new BufferAttribute(array, 1, false);\n          }\n        }\n        dereferenceIndex(geometry, indirectBuffer, this._cachedIndexAttr);\n        this.index.updateFrom(this._cachedIndexAttr);\n      } else {\n        this.index.updateFrom(geometry.index);\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var index = this.index,\n        position = this.position,\n        bvhBounds = this.bvhBounds,\n        bvhContents = this.bvhContents;\n      if (index) index.dispose();\n      if (position) position.dispose();\n      if (bvhBounds) bvhBounds.dispose();\n      if (bvhContents) bvhContents.dispose();\n    }\n  }]);\n  return MeshBVHUniformStruct;\n}();\nfunction dereferenceIndex(geometry, indirectBuffer, target) {\n  var unpacked = target.array;\n  var indexArray = geometry.index ? geometry.index.array : null;\n  for (var i = 0, l = indirectBuffer.length; i < l; i++) {\n    var i3 = 3 * i;\n    var v3 = 3 * indirectBuffer[i];\n    for (var c = 0; c < 3; c++) {\n      unpacked[i3 + c] = indexArray ? indexArray[v3 + c] : v3 + c;\n    }\n  }\n}\nfunction bvhToTextures(bvh, boundsTexture, contentsTexture) {\n  var roots = bvh._roots;\n  if (roots.length !== 1) {\n    throw new Error('MeshBVHUniformStruct: Multi-root BVHs not supported.');\n  }\n  var root = roots[0];\n  var uint16Array = new Uint16Array(root);\n  var uint32Array = new Uint32Array(root);\n  var float32Array = new Float32Array(root);\n\n  // Both bounds need two elements per node so compute the height so it's twice as long as\n  // the width so we can expand the row by two and still have a square texture\n  var nodeCount = root.byteLength / BYTES_PER_NODE;\n  var boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));\n  var boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);\n  var contentsDimension = Math.ceil(Math.sqrt(nodeCount));\n  var contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);\n  for (var i = 0; i < nodeCount; i++) {\n    var nodeIndex32 = i * BYTES_PER_NODE / 4;\n    var nodeIndex16 = nodeIndex32 * 2;\n    var boundsIndex = BOUNDING_DATA_INDEX(nodeIndex32);\n    for (var b = 0; b < 3; b++) {\n      boundsArray[8 * i + 0 + b] = float32Array[boundsIndex + 0 + b];\n      boundsArray[8 * i + 4 + b] = float32Array[boundsIndex + 3 + b];\n    }\n    if (IS_LEAF(nodeIndex16, uint16Array)) {\n      var count = COUNT(nodeIndex16, uint16Array);\n      var offset = OFFSET(nodeIndex32, uint32Array);\n      var mergedLeafCount = 0xffff0000 | count;\n      contentsArray[i * 2 + 0] = mergedLeafCount;\n      contentsArray[i * 2 + 1] = offset;\n    } else {\n      var rightIndex = 4 * RIGHT_NODE(nodeIndex32, uint32Array) / BYTES_PER_NODE;\n      var splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n      contentsArray[i * 2 + 0] = splitAxis;\n      contentsArray[i * 2 + 1] = rightIndex;\n    }\n  }\n  boundsTexture.image.data = boundsArray;\n  boundsTexture.image.width = boundsDimension;\n  boundsTexture.image.height = boundsDimension;\n  boundsTexture.format = RGBAFormat;\n  boundsTexture.type = FloatType;\n  boundsTexture.internalFormat = 'RGBA32F';\n  boundsTexture.minFilter = NearestFilter;\n  boundsTexture.magFilter = NearestFilter;\n  boundsTexture.generateMipmaps = false;\n  boundsTexture.needsUpdate = true;\n  boundsTexture.dispose();\n  contentsTexture.image.data = contentsArray;\n  contentsTexture.image.width = contentsDimension;\n  contentsTexture.image.height = contentsDimension;\n  contentsTexture.format = RGIntegerFormat;\n  contentsTexture.type = UnsignedIntType;\n  contentsTexture.internalFormat = 'RG32UI';\n  contentsTexture.minFilter = NearestFilter;\n  contentsTexture.magFilter = NearestFilter;\n  contentsTexture.generateMipmaps = false;\n  contentsTexture.needsUpdate = true;\n  contentsTexture.dispose();\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}