{"ast":null,"code":"import _classCallCheck from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mon Site/portfolio-react/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { WebGLRenderTarget, HalfFloatType } from \"three\";\nimport { SSAARenderPass } from \"./SSAARenderPass.js\";\nvar TAARenderPass = /*#__PURE__*/function (_SSAARenderPass) {\n  _inherits(TAARenderPass, _SSAARenderPass);\n  var _super = _createSuper(TAARenderPass);\n  function TAARenderPass(scene, camera, clearColor, clearAlpha) {\n    var _this;\n    _classCallCheck(this, TAARenderPass);\n    _this = _super.call(this, scene, camera, clearColor, clearAlpha);\n    _this.sampleLevel = 0;\n    _this.accumulate = false;\n    _this.accumulateIndex = -1;\n    return _this;\n  }\n  _createClass(TAARenderPass, [{\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime) {\n      if (this.accumulate === false) {\n        _get(_getPrototypeOf(TAARenderPass.prototype), \"render\", this).call(this, renderer, writeBuffer, readBuffer, deltaTime);\n        this.accumulateIndex = -1;\n        return;\n      }\n      var jitterOffsets = _JitterVectors[5];\n      if (this.sampleRenderTarget === void 0) {\n        this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n          type: HalfFloatType\n        });\n        this.sampleRenderTarget.texture.name = \"TAARenderPass.sample\";\n      }\n      if (this.holdRenderTarget === void 0) {\n        this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n          type: HalfFloatType\n        });\n        this.holdRenderTarget.texture.name = \"TAARenderPass.hold\";\n      }\n      if (this.accumulateIndex === -1) {\n        _get(_getPrototypeOf(TAARenderPass.prototype), \"render\", this).call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n        this.accumulateIndex = 0;\n      }\n      var autoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      renderer.getClearColor(this._oldClearColor);\n      var oldClearAlpha = renderer.getClearAlpha();\n      var sampleWeight = 1 / jitterOffsets.length;\n      if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n        this.copyUniforms[\"opacity\"].value = sampleWeight;\n        this.copyUniforms[\"tDiffuse\"].value = writeBuffer.texture;\n        var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n        for (var i = 0; i < numSamplesPerFrame; i++) {\n          var j = this.accumulateIndex;\n          var jitterOffset = jitterOffsets[j];\n          if (this.camera.setViewOffset) {\n            this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625,\n            // 0.0625 = 1 / 16\n            readBuffer.width, readBuffer.height);\n          }\n          renderer.setRenderTarget(writeBuffer);\n          renderer.setClearColor(this.clearColor, this.clearAlpha);\n          renderer.clear();\n          renderer.render(this.scene, this.camera);\n          renderer.setRenderTarget(this.sampleRenderTarget);\n          if (this.accumulateIndex === 0) {\n            renderer.setClearColor(0, 0);\n            renderer.clear();\n          }\n          this.fsQuad.render(renderer);\n          this.accumulateIndex++;\n          if (this.accumulateIndex >= jitterOffsets.length) break;\n        }\n        if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n      }\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      var accumulationWeight = this.accumulateIndex * sampleWeight;\n      if (accumulationWeight > 0) {\n        this.copyUniforms[\"opacity\"].value = 1;\n        this.copyUniforms[\"tDiffuse\"].value = this.sampleRenderTarget.texture;\n        renderer.setRenderTarget(writeBuffer);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n      }\n      if (accumulationWeight < 1) {\n        this.copyUniforms[\"opacity\"].value = 1 - accumulationWeight;\n        this.copyUniforms[\"tDiffuse\"].value = this.holdRenderTarget.texture;\n        renderer.setRenderTarget(writeBuffer);\n        this.fsQuad.render(renderer);\n      }\n      renderer.autoClear = autoClear;\n      renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TAARenderPass.prototype), \"dispose\", this).call(this);\n      if (this.sampleRenderTarget !== void 0) this.sampleRenderTarget.dispose();\n      if (this.holdRenderTarget !== void 0) this.holdRenderTarget.dispose();\n    }\n  }]);\n  return TAARenderPass;\n}(SSAARenderPass);\nvar _JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\nexport { TAARenderPass };\n//# sourceMappingURL=TAARenderPass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}